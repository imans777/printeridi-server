{"version":3,"sources":["./src/$_lazy_route_resource lazy","./src/app/app.component.css","./src/app/app.component.html","./src/app/app.component.ts","./src/app/app.module.ts","./src/app/app.routing.ts","./src/app/shared/classes/page-base.class.ts","./src/app/shared/classes/tooltip.class.ts","./src/app/shared/components/camera-viewer/camera-viewer.component.html","./src/app/shared/components/camera-viewer/camera-viewer.component.scss","./src/app/shared/components/camera-viewer/camera-viewer.component.ts","./src/app/shared/components/form-item/form-item.component.html","./src/app/shared/components/form-item/form-item.component.scss","./src/app/shared/components/form-item/form-item.component.ts","./src/app/shared/components/gcode-viewer/gcode-viewer.component.html","./src/app/shared/components/gcode-viewer/gcode-viewer.component.scss","./src/app/shared/components/gcode-viewer/gcode-viewer.component.ts","./src/app/shared/components/generic-dialog/generic-dialog.component.html","./src/app/shared/components/generic-dialog/generic-dialog.component.scss","./src/app/shared/components/generic-dialog/generic-dialog.component.ts","./src/app/shared/components/move/move.component.html","./src/app/shared/components/move/move.component.scss","./src/app/shared/components/move/move.component.ts","./src/app/shared/components/progress/progress.component.css","./src/app/shared/components/progress/progress.component.html","./src/app/shared/components/progress/progress.component.ts","./src/app/shared/components/trl/trl.component.html","./src/app/shared/components/trl/trl.component.scss","./src/app/shared/components/trl/trl.component.ts","./src/app/shared/components/upload-file/upload-file.component.html","./src/app/shared/components/upload-file/upload-file.component.scss","./src/app/shared/components/upload-file/upload-file.component.ts","./src/app/shared/consts/leftnav.const.ts","./src/app/shared/consts/settings-after-action.const.ts","./src/app/shared/enum/dialog.enum.ts","./src/app/shared/enum/msgtype.enum.ts","./src/app/shared/enum/print-status.enum.ts","./src/app/shared/enum/themes.enum.ts","./src/app/shared/lib/gcode/TrackballControls.js","./src/app/shared/lib/gcode/constants.js","./src/app/shared/lib/gcode/gimporter.js","./src/app/shared/lib/gcode/gparser.js","./src/app/shared/lib/gcode/grenderer.js","./src/app/shared/lib/gcode/js/ShaderExtras.js","./src/app/shared/lib/gcode/js/postprocessing/BloomPass.js","./src/app/shared/lib/gcode/js/postprocessing/EffectComposer.js","./src/app/shared/lib/gcode/js/postprocessing/MaskPass.js","./src/app/shared/lib/gcode/js/postprocessing/RenderPass.js","./src/app/shared/lib/gcode/js/postprocessing/ShaderPass.js","./src/app/shared/lib/gcode/three.js","./src/app/shared/lib/round-to.ts","./src/app/shared/lib/stringedTime.ts","./src/app/shared/servermatch.ts","./src/app/shared/services/data.service.ts","./src/app/shared/services/http.service.ts","./src/app/shared/services/message.service.ts","./src/app/shared/services/print.service.ts","./src/app/shared/services/progress.service.ts","./src/app/shared/services/socket.service.ts","./src/app/shared/services/spinner.service.ts","./src/app/shared/services/translator.service.ts","./src/app/shared/services/viewer.service.ts","./src/app/shared/services/window.service.ts","./src/app/site/bedlevel/bedlevel.component.html","./src/app/site/bedlevel/bedlevel.component.scss","./src/app/site/bedlevel/bedlevel.component.ts","./src/app/site/extruder/extruder.component.html","./src/app/site/extruder/extruder.component.scss","./src/app/site/extruder/extruder.component.ts","./src/app/site/home/home.component.html","./src/app/site/home/home.component.scss","./src/app/site/home/home.component.ts","./src/app/site/last-prints/last-prints.component.html","./src/app/site/last-prints/last-prints.component.scss","./src/app/site/last-prints/last-prints.component.ts","./src/app/site/print-page/print-page.component.html","./src/app/site/print-page/print-page.component.scss","./src/app/site/print-page/print-page.component.ts","./src/app/site/settings/settings.component.html","./src/app/site/settings/settings.component.scss","./src/app/site/settings/settings.component.ts","./src/app/site/site.component.css","./src/app/site/site.component.html","./src/app/site/site.component.ts","./src/app/site/site.module.ts","./src/app/site/site.routing.ts","./src/app/site/timelapse/timelapse.component.html","./src/app/site/timelapse/timelapse.component.scss","./src/app/site/timelapse/timelapse.component.ts","./src/environments/environment.ts","./src/main.ts"],"names":[],"mappings":"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;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,2BAA2B;;AAE3B;;AAEA,GAAG,2BAA2B;;AAE9B;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA,yEAAyE,wBAAwB,EAAE;;AAEnG;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;ACzZA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;ACzCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,mBAAmB;AACnB;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0FAA0F;AAC1F,oFAAoF;AACpF,0FAA0F;AAC1F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAC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A;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;;AAGF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAE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A;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;;AAGF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,aAAa,YAAY;AACzB,aAAa,YAAY;AACzB,aAAa,YAAY;AACzB,aAAa,YAAY;;AAEzB;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAE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;;AAEH;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA,gBAAgB,eAAe;;AAE/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;A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jC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAC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A;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,YAAY;;AAE/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,eAAe;;AAE9B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,eAAe;;AAE9B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAE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;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,0CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;A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;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,wCAAwC,QAAQ;;AAEhD;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,sHAAsH;;AAEtH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,OAAO;;AAEP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sGAAsG;;AAEtG;AACA,qDAAqD;AACrD;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,uEAAuE,QAAQ;;AAE/E;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA,eAAe,QAAQ;;AAEvB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,OAAO;;AAEP;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,sBAAsB,WAAW;;AAEjC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH,sCAAsC,0DAA0D,EAAE;;AAElG;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;;AAEA;;AAEA;;AAEA,gCAAgC;;AAEhC;;AAEA;;AAEA;;AAEA,4CAA4C;;AAE5C;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,6CAA6C;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,oDAAoD,QAAQ;;AAE5D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAM;;AAEN;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA,4DAA4D,QAAQ;;AAEpE;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,0BAA0B;;AAEzC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,0BAA0B;;AAEzC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,8CAA8C;;AAE9C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oCAAoC,QAAQ;;AAE5C;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB;;AAExB;;AAEA,IAAI,2BAA2B;;AAE/B;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA,IAAI,2BAA2B;;AAE/B;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI,2BAA2B;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI,6BAA6B;;AAEjC;;AAEA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;;AAEA;;AAEA,IAAI,2BAA2B;;AAE/B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,KAAK;;AAEL;;AAEA;;AAEA,IAAI,4BAA4B;;AAEhC;;AAEA;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;;AAEA;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iDAAiD,QAAQ;AACzD,qDAAqD,QAAQ;AAC7D,mDAAmD,QAAQ;AAC3D,sDAAsD,QAAQ;AAC9D,yDAAyD,QAAQ;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC;;AAEvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B;AAC7B,iCAAiC;AACjC,kCAAkC;AAClC,4BAA4B;AAC5B,8BAA8B;AAC9B,gCAAgC;;AAEhC,4BAA4B;AAC5B,0BAA0B;AAC1B,sBAAsB;AACtB,uBAAuB;;AAEvB;;AAEA,0BAA0B;;AAE1B;;AAEA;;AAEA,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;;AAEjC;;AAEA,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;;AAElC;;AAEA,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;;AAElC;;AAEA;;AAEA;;AAEA,8BAA8B;AAC9B,+BAA+B;;AAE/B;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC;;AAEvC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,gCAAgC;AAChC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAc,gCAAgC;;AAE9C;;AAEA;;AAEA,cAAc,gCAAgC;;AAE9C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,6CAA6C;;AAEhE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,OAAO;;AAE5C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,OAAO;;AAE5C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,QAAQ;;AAEhD;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,OAAO;;AAE3B;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;;AAE3B;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;;AAE3B;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,QAAQ;;AAE1C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA,kCAAkC,QAAQ;;AAE1C;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6DAA6D,kJAAkJ;;AAE/M;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,gCAAgC;;AAElD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,yCAAyC,QAAQ;;AAEjD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,QAAQ;;AAE1C;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA,kDAAkD,QAAQ;;AAE1D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC,QAAQ;;AAExC;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oCAAoC,QAAQ;;AAE5C;;AAEA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA,+BAA+B,QAAQ;;AAEvC;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,QAAQ;;AAEtB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAc,OAAO;;AAErB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;;AAEA,oCAAoC,QAAQ;;AAE5C;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA,4CAA4C,QAAQ;;AAEpD;;AAEA;;AAEA,kDAAkD,QAAQ;;AAE1D;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,oDAAoD,QAAQ;;AAE5D;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA;;AAEA,oDAAoD,QAAQ;;AAE5D;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAkD,QAAQ;;AAE1D;;AAEA;;AAEA,0CAA0C,QAAQ;;AAElD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qDAAqD,QAAQ;;AAE7D;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,QAAQ;;AAER;AACA;;AAEA;AACA;;AAEA;;AAEA,QAAQ;;AAER;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,qDAAqD,QAAQ;;AAE7D;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qDAAqD,QAAQ;;AAE7D;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,QAAQ;;AAER;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,qDAAqD,QAAQ;;AAE7D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;;AAEvC;AACA;;AAEA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;;AAE7B,mBAAmB,YAAY;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,gBAAgB;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,oBAAoB;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,UAAU;;AAE5B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,OAAO;;AAE/C;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB,yBAAyB;AAClD,qBAAqB,wBAAwB;AAC7C,sBAAsB,wBAAwB;AAC9C,sBAAsB,wBAAwB;AAC9C,cAAc;;AAEd,IAAI;;AAEJ;;AAEA,+BAA+B;;AAE/B,2BAA2B;AAC3B,8BAA8B;AAC9B,qCAAqC;;AAErC,kBAAkB;;AAElB,mFAAmF;AACnF,uDAAuD;;AAEvD,wFAAwF;AACxF,wFAAwF;AACxF,wFAAwF;AACxF,6BAA6B;;AAE7B,iGAAiG;;AAEjG,MAAM;;AAEN;;AAEA;;AAEA,oCAAoC;AACpC,gCAAgC;AAChC,iCAAiC;AACjC,iCAAiC;;AAEjC,2BAA2B;AAC3B,8BAA8B;AAC9B,qCAAqC;;AAErC,kBAAkB;;AAElB,gEAAgE;AAChE,2DAA2D;;AAE3D,6GAA6G;;AAE7G,8CAA8C;;AAE9C,sCAAsC;AACtC,wEAAwE;AACxE,+EAA+E;AAC/E,+EAA+E;AAC/E,mHAAmH;;AAEnH,kDAAkD;;AAElD,MAAM;;AAEN;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,sBAAsB;AAC3C,yBAAyB,sBAAsB;AAC/C,yBAAyB,sBAAsB;AAC/C,yBAAyB,sBAAsB;AAC/C,2BAA2B,sBAAsB;;AAEjD,sBAAsB,yBAAyB;AAC/C,qBAAqB,yBAAyB;AAC9C,mBAAmB,yBAAyB;AAC5C,oBAAoB,yBAAyB;AAC7C,sBAAsB,yBAAyB;AAC/C,iBAAiB,yBAAyB;;AAE1C,qBAAqB,+CAA+C;;AAEpE,0BAA0B,wBAAwB;AAClD,2BAA2B,wBAAwB;;AAEnD,sBAAsB,gDAAgD;AACtE,uBAAuB,gDAAgD;AACvE,sBAAsB,gDAAgD;AACtE,mBAAmB,uBAAuB;AAC1C,iBAAiB,sBAAsB;;AAEvC,mBAAmB,sBAAsB;AACzC,yBAAyB,yBAAyB;AAClD,sBAAsB,wBAAwB;;AAE9C,iBAAiB,+CAA+C;AAChE,iBAAiB,+CAA+C;;AAEhE,kBAAkB;;AAElB;;AAEA;;AAEA;;AAEA,gCAAgC;AAChC,gCAAgC;AAChC,iCAAiC;AACjC,8BAA8B;AAC9B,4BAA4B;;AAE5B,gCAAgC;AAChC,iCAAiC;AACjC,2BAA2B;AAC3B,mCAAmC;;AAEnC,gCAAgC;AAChC,+BAA+B;AAC/B,iCAAiC;AACjC,2BAA2B;;AAE3B,+BAA+B;;AAE/B,+BAA+B;;AAE/B,6BAA6B;AAC7B,oCAAoC;AACpC,iCAAiC;;AAEjC,2BAA2B;AAC3B,4BAA4B;AAC5B,0BAA0B;AAC1B,sBAAsB;;AAEtB,oCAAoC;;AAEpC;;AAEA,2DAA2D;AAC3D,+DAA+D;;AAE/D;;AAEA;;AAEA,8DAA8D;AAC9D,iEAAiE;AACjE,8DAA8D;;AAE9D;;AAEA;;AAEA,uDAAuD;AACvD,0DAA0D;AAC1D,2DAA2D;;AAE3D;;AAEA;;AAEA,qDAAqD;AACrD,wDAAwD;AACxD,yDAAyD;AACzD,sDAAsD;AACtD,yDAAyD;AACzD,yDAAyD;;AAEzD;;AAEA;;AAEA,2BAA2B;;AAE3B;;AAEA,iCAAiC;AACjC,gCAAgC;;AAEhC;AACA;;AAEA,kBAAkB;;AAElB,mDAAmD;;AAEnD,qCAAqC;;AAErC,iEAAiE;AACjE,mCAAmC;AACnC,yCAAyC;;AAEzC,2BAA2B;;AAE3B;;AAEA,qDAAqD;AACrD,yCAAyC;;AAEzC,iDAAiD;;AAEjD;;AAEA,iEAAiE;;AAEjE;;AAEA,OAAO;;AAEP,sBAAsB;;AAEtB;;AAEA,6CAA6C;AAC7C,mCAAmC;;AAEnC,0DAA0D;;AAE1D;;AAEA,wEAAwE;;AAExE;;AAEA,OAAO;;AAEP;AACA,qDAAqD;;AAErD,6FAA6F;AAC7F,yCAAyC;;AAEzC;;AAEA,kCAAkC;;AAElC;;AAEA,6CAA6C;AAC7C,qDAAqD;;AAErD;;AAEA;;AAEA,uCAAuC;AACvC,wCAAwC;;AAExC,uBAAuB,sBAAsB,SAAS;;AAEtD,2EAA2E;AAC3E,6DAA6D;;AAE7D,kCAAkC;AAClC;AACA,+FAA+F;;AAE/F,+CAA+C;;AAE/C;;AAEA;;AAEA,+EAA+E;AAC/E,2FAA2F;;AAE3F,mHAAmH;;AAEnH;;AAEA,2EAA2E;;AAE3E;;AAEA,kGAAkG;;AAElG;;AAEA,uEAAuE;AACvE,8EAA8E;AAC9E,sGAAsG;;AAEtG;;AAEA;;AAEA,qEAAqE;;AAErE,8HAA8H;AAC9H,4IAA4I;;AAE5I;;AAEA,2HAA2H;;AAE3H;;AAEA,QAAQ;;AAER;;AAEA;;AAEA;;AAEA,sCAAsC;AACtC,uCAAuC;;AAEvC,uBAAuB,qBAAqB,SAAS;;AAErD,0EAA0E;AAC1E,4DAA4D;;AAE5D,iCAAiC;AACjC;AACA,4FAA4F;;AAE5F,6CAA6C;;AAE7C,gHAAgH;;AAEhH,iDAAiD;;AAEjD,gEAAgE;;AAEhE;;AAEA;;AAEA,8EAA8E;AAC9E,0FAA0F;;AAE1F,iHAAiH;;AAEjH;;AAEA,0EAA0E;;AAE1E;;AAEA,4GAA4G;;AAE5G;;AAEA,sEAAsE;AACtE,6EAA6E;AAC7E,qGAAqG;;AAErG;;AAEA;;AAEA,sEAAsE;;AAEtE,6HAA6H;AAC7H,qJAAqJ;;AAErJ;;AAEA,oIAAoI;;AAEpI;;AAEA,SAAS;;AAET,QAAQ;;AAER;;AAEA;;AAEA;;AAEA,qCAAqC;AACrC,sCAAsC;;AAEtC,sBAAsB,oBAAoB,QAAQ;;AAElD,mFAAmF;AACnF,qDAAqD;;AAErD;;AAEA;;AAEA,oFAAoF;AACpF,gGAAgG;;AAEhG,8HAA8H;;AAE9H;;AAEA,uEAAuE;;AAEvE;;AAEA,oFAAoF;;AAEpF;;AAEA,mEAAmE;AACnE,0EAA0E;AAC1E,kGAAkG;;AAElG;;AAEA;;AAEA,qEAAqE;;AAErE,0HAA0H;AAC1H,4HAA4H;;AAE5H;;AAEA,2GAA2G;;AAE3G;;AAEA,QAAQ;;AAER;;AAEA;;AAEA;;AAEA,uCAAuC;AACvC,uCAAuC;;AAEvC,sBAAsB,qBAAqB,SAAS;;AAEpD,gFAAgF;AAChF,sEAAsE;;AAEtE;;AAEA,kDAAkD;AAClD,yDAAyD;;AAEzD,iHAAiH;;AAEjH,iDAAiD;;AAEjD;;;AAGA,qEAAqE;AACrE,kFAAkF;AAClF,0GAA0G;;AAE1G;;AAEA,6EAA6E;;AAE7E,8EAA8E;AAC9E,wFAAwF;AACxF,gHAAgH;;AAEhH;;AAEA,+DAA+D;;AAE/D;;AAEA,qEAAqE;;AAErE,+HAA+H;AAC/H,2IAA2I;AAC3I,uMAAuM;;AAEvM;;AAEA,+HAA+H;;AAE/H;;AAEA,QAAQ;;AAER;;AAEA;;AAEA,sCAAsC;AACtC,uCAAuC;;AAEvC;;AAEA,kCAAkC;AAClC,oCAAoC;;AAEpC;;AAEA;;AAEA,mCAAmC;AACnC,qCAAqC;;AAErC;;AAEA;;AAEA,oCAAoC;AACpC,sCAAsC;;AAEtC;;AAEA;;AAEA,mCAAmC;AACnC,qCAAqC;;AAErC;;AAEA;;AAEA,kHAAkH;;AAElH;;AAEA,kHAAkH;;AAElH;;AAEA,+BAA+B;;AAE/B,qBAAqB;AACrB,0EAA0E;;AAE1E,0BAA0B;;AAE1B,uEAAuE;;AAEvE,QAAQ,OAAO;;AAEf,qDAAqD;;AAErD,QAAQ;;AAER,+EAA+E;;AAE/E;;AAEA,uCAAuC;;AAEvC;;AAEA,gGAAgG;;AAEhG,OAAO;;AAEP;AACA;AACA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA,4BAA4B;;AAE5B,0BAA0B;AAC1B,0BAA0B;;AAE1B,qCAAqC;;AAErC;;AAEA,sCAAsC;AACtC,uCAAuC;AACvC,sCAAsC;;AAEtC;;AAEA,2BAA2B;AAC3B,4BAA4B;AAC5B,0BAA0B;AAC1B,sBAAsB;;AAEtB,iCAAiC;AACjC,gCAAgC;;AAEhC;AACA;;AAEA,kBAAkB;;AAElB;AACA;;AAEA;;AAEA;;AAEA,kDAAkD;;AAElD,mEAAmE;AACnE,oDAAoD;;AAEpD;;AAEA,uCAAuC;AACvC,6CAA6C;;AAE7C;;AAEA,yDAAyD;;AAEzD,mCAAmC;;AAEnC;;AAEA,6BAA6B;;AAE7B;;AAEA,kCAAkC;;AAElC,qDAAqD;AACrD,iEAAiE;AACjE,gEAAgE;;AAEhE,QAAQ,OAAO;;AAEf;;AAEA,iDAAiD;;AAEjD,8DAA8D;AAC9D,4DAA4D;;AAE5D,0CAA0C;;AAE1C;;AAEA,sCAAsC;;AAEtC;;AAEA,QAAQ;;AAER;;AAEA;;AAEA,gDAAgD;;AAEhD,6DAA6D;AAC7D,2DAA2D;;AAE3D,yCAAyC;;AAEzC;;AAEA,qCAAqC;;AAErC;;AAEA;;AAEA;;AAEA,yEAAyE;AACzE,oEAAoE;;AAEpE,kDAAkD;;AAElD;;AAEA,qCAAqC;AACrC,sCAAsC;;AAEtC;;AAEA;;AAEA,sBAAsB,iBAAiB,SAAS;;AAEhD,0DAA0D;;AAE1D,QAAQ;;AAER;;AAEA,MAAM;;AAEN;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA,cAAc,WAAW,yBAAyB;AAClD,gBAAgB,uBAAuB,EAAE;;AAEzC;;AAEA,gCAAgC;;AAEhC,kBAAkB;;AAElB,2DAA2D;AAC3D,qDAAqD;;AAErD,+EAA+E;;AAE/E,MAAM;;AAEN;;AAEA;;AAEA,+BAA+B;AAC/B,yBAAyB;;AAEzB,gCAAgC;;AAEhC,kBAAkB;;AAElB,iDAAiD;AACjD,2EAA2E;;AAE3E,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,YAAY;;AAE1B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAU;;AAEV,EAAE;;;;;AAKF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,YAAY;;AAE3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,iBAAiB;;AAEhE;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,iBAAiB;;AAEhE;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA,UAAU;AACV;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;;AAE5C;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,OAAO;;AAEtB,GAAG;;AAEH,eAAe,OAAO;;AAEtB;;AAEA;;AAEA;;AAEA,qBAAqB;;AAErB,kBAAkB,QAAQ;;AAE1B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,SAAS,yBAAyB;AAClC,aAAa,uBAAuB;AACpC,aAAa,uBAAuB;;AAEpC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA,0BAA0B,QAAQ;;AAElC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B,OAAO;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;;AAEjB;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,OAAO;;AAEtB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA,qBAAqB,oEAAoE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,gBAAgB;;AAE7B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,gBAAgB;;AAE7B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,gBAAgB;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAc,KAAK,wBAAwB;;AAE3C;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAqB;;AAErB;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,6CAA6C;;AAE7C;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;AAEA,8BAA8B;AAC9B,kCAAkC;AAClC,+BAA+B;AAC/B,8BAA8B;;AAE9B;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;;AAGA,4BAA4B;AAC5B;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAa,QAAQ;;AAErB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,mBAAmB;;AAEpC;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,yCAAyC;AACzC;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC,QAAQ;;AAExC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC,QAAQ;;AAExC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;;AAEA;AACA;;AAEA;;AAEA;AACA,6CAA6C;;AAE7C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,GAAG;;AAEH;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,2CAA2C,OAAO;;AAElD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wCAAwC,UAAU;;AAElD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,qBAAqB,gDAAgD;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gDAAgD;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,2DAA2D;;AAEhF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wDAAwD;;AAE7E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,qDAAqD;;AAE1E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gDAAgD;;AAErE;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,eAAe;;AAEhC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA,eAAe,gBAAgB;;AAE/B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;;AAGA,eAAe,gBAAgB;;AAE/B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,QAAQ;;AAEvB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,iBAAiB;;AAEhC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,eAAe,iBAAiB;;AAEhC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oCAAoC,QAAQ;;AAE5C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA,oCAAoC,QAAQ;;AAE5C;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,QAAQ;;AAErB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,QAAQ;;AAErB;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B;AAC/B;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,kBAAkB;;AAEhC;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;;AAElC;AACA;;AAEA,gBAAgB,kBAAkB;;AAElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,4BAA4B;AACtD;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,4BAA4B;AACvD;;AAEA,0BAA0B,0BAA0B;AACpD;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;;AAEA,eAAe,OAAO;;AAEtB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA,eAAe,OAAO;;AAEtB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA,iBAAiB,oBAAoB;AACrC;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,uBAAuB;;AAEzC;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,0BAA0B;AAC3C;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,iBAAiB,2BAA2B;;AAE5C,kBAAkB,qCAAqC;;AAEvD;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,qCAAqC;;AAEzD,qBAAqB,uDAAuD;;AAE5E;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA,oBAAoB,qCAAqC;;AAEzD;;AAEA;;AAEA,sBAAsB,uDAAuD;;AAE7E;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA,mBAAmB,qCAAqC;;AAExD;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA,mBAAmB,qCAAqC;;AAExD;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;;;AAGA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,cAAc,QAAQ;;AAEtB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,qCAAqC;AACrC,qCAAqC;AACrC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA,6CAA6C,QAAQ;;AAErD;AACA;;AAEA;;AAEA,kBAAkB,OAAO;;AAEzB;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,QAAQ,mBAAmB;;AAE3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;;AAGA,QAAQ,UAAU;;AAElB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;;AAEpC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA,cAAc,QAAQ;;AAEtB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA,iBAAiB,gCAAgC;;AAEjD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,8CAA8C,QAAQ;;AAEtD;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,iBAAiB;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,6CAA6C,QAAQ;;AAErD;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,2BAA2B;;AAE9C;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,QAAQ,mBAAmB;;AAE3B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,QAAQ,UAAU;;AAElB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uFAAuF,wFAAwF;;AAE/K;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gBAAgB,eAAe;;AAE/B;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,eAAe;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,mBAAmB,OAAO;;AAE1B;;AAEA;;AAEA;;AAEA,UAAU,SAAS,SAAS,SAAS,SAAS;;AAE9C,EAAE;;AAEF;;AAEA;;AAEA,eAAe;;AAEf;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mFAAmF;AACnF,qFAAqF;AACrF,mFAAmF;AACnF,qFAAqF;AACrF,mFAAmF;AACnF,qFAAqF;;AAErF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,aAAa;;AAE5B,gBAAgB,aAAa;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,YAAY;;AAE3B,gBAAgB,YAAY;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,gBAAgB;;AAE7B;AACA;;AAEA;AACA;;AAEA,cAAc,gBAAgB;;AAE9B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,aAAa,eAAe;;AAE5B;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wFAAwF;AACxF,0FAA0F;AAC1F;;AAEA,qFAAqF;;AAErF;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;;AAEA;AACA,uBAAuB;;AAEvB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB;;AAElB;;;AAGA;;AAEA;;AAEA,wBAAwB;;AAExB,gCAAgC,SAAS;;AAEzC;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA,sCAAsC;;AAEtC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,8CAA8C;;AAE9C;;AAEA;;AAEA,6DAA6D,QAAQ;;AAErE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC,QAAQ;;AAExC;;AAEA;;AAEA,wDAAwD,QAAQ;;AAEhE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA,aAAa,mBAAmB;AAChC,2BAA2B,OAAO;;AAElC;AACA;;AAEA;AACA,mDAAmD;AACnD,wBAAwB;;AAExB;;AAEA,mCAAmC,QAAQ;;AAE3C;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,UAAU;;AAEvB;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,aAAa,YAAY;;AAEzB,cAAc,UAAU;;AAExB;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA,eAAe,oBAAoB;AACnC,6BAA6B,QAAQ;;AAErC;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;AACA;;AAEA;;AAEA;;AAEA,iCAAiC,QAAQ;;AAEzC;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,kBAAkB;AAClB;;AAEA;;AAEA,eAAe,UAAU;;AAEzB;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,eAAe,UAAU;;AAEzB;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,eAAe,UAAU;;AAEzB;AACA;;AAEA;;AAEA;;AAEA,eAAe,UAAU;;AAEzB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC,SAAS;;AAE1C;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,QAAQ;;AAEvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;;AAE3C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC,OAAO;;AAEvC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,+BAA+B,OAAO;;AAEtC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,UAAU;;AAEvB;;AAEA;;AAEA;;AAEA,aAAa,UAAU;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;;AAEpC;AACA;;AAEA;;AAEA;;AAEA,aAAa,QAAQ;;AAErB,kBAAkB,kBAAkB;;AAEpC;AACA;;AAEA;;AAEA;;AAEA,aAAa,YAAY;;AAEzB,sCAAsC,YAAY;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,aAAa;;AAE3B,eAAe,aAAa;;AAE5B;AACA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,YAAY;;AAE1B,eAAe,YAAY;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,gBAAgB;;AAE7B;AACA;;AAEA,cAAc,gBAAgB;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,aAAa,eAAe;;AAE5B,cAAc,eAAe;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB;;AAExB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,0BAA0B;;AAE3C,kBAAkB,2BAA2B;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA,iBAAiB,0BAA0B;;AAE3C,kBAAkB,2BAA2B;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;;AAE1C;;AAEA,kBAAkB,0BAA0B;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,yBAAyB;;AAE1C,kBAAkB,0BAA0B;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA,aAAa,eAAe;;AAE5B;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,yBAAyB;;AAEvC;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,aAAa,mBAAmB;;AAEhC,cAAc,yBAAyB;;AAEvC;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,eAAe;;AAE5B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kEAAkE;AAClE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA,aAAa,eAAe;;AAE5B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC,OAAO;;AAE7C;;AAEA;;AAEA;;AAEA,mCAAmC,OAAO;;AAE1C;;AAEA;;AAEA;;AAEA;;AAEA,2CAA2C,OAAO;;AAElD;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,8DAA8D;AAC9D,8DAA8D;AAC9D,8DAA8D;AAC9D,8EAA8E;;AAE9E;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB;;AAExB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAa,aAAa;;AAE1B;;AAEA,cAAc,aAAa;;AAE3B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAa,YAAY;;AAEzB,cAAc,YAAY;;AAE1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,qBAAqB;;AAEtC;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;;AAEpC;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;;AAE3B;AACA;;AAEA;AACA,qBAAqB,iBAAiB;;AAEtC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI,OAAO;;AAEX;;AAEA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C;;AAE1C,iBAAiB,kBAAkB;;AAEnC;;AAEA,mBAAmB,OAAO;;AAE1B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,kBAAkB;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,uBAAuB;;AAExC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,mCAAmC;;AAEjF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE,aAAa;AACtF;;AAEA;;AAEA,yEAAyE,aAAa;AACtF;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,+CAA+C,kDAAkD;AACjG;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,wCAAwC,QAAQ;;AAEhD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB,IAAI;AACpB;;AAEA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA,kBAAkB;;AAElB,oBAAoB,qBAAqB;AACzC;;AAEA,wBAAwB,eAAe,OAAO,EAAE,SAAS;;;AAGzD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,MAAM;AACjC,4BAA4B,KAAK;AACjC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,oDAAoD,kCAAkC;AACtF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,0BAA0B,KAAK;AAC/B;;AAEA;AACA;AACA;;AAEA,MAAM,cAAc,qCAAqC;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,kCAAkC,OAAO,MAAM;AAC/C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,sCAAsC,MAAM;AAC5C;;AAEA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;;;AAGA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA,+BAA+B;;AAE/B;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;;AAEA,EAAE;AACF;AACA;;AAEA;;AAEA;;AAEA,4CAA4C;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,GAAG;;AAE7C;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,QAAQ;;AAEpB;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oDAAoD,QAAQ;;AAE5D;AACA;;AAEA;;AAEA;AACA;;AAEA,uDAAuD;;AAEvD;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kDAAkD,QAAQ;;AAE1D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC,iCAAiC;AACnE,iCAAiC,iCAAiC;;AAElE,iCAAiC;AACjC,iCAAiC;;AAEjC,iCAAiC;AACjC,iCAAiC;;AAEjC,kCAAkC;AAClC,iCAAiC;;AAEjC;AACA,8BAA8B,6BAA6B;AAC3D,8BAA8B,6BAA6B;;AAE3D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAc,aAAa;;AAE3B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,8GAA8G;AAC5J,mDAAmD,kIAAkI;AACrL,kDAAkD,8HAA8H;AAChL,uDAAuD,kJAAkJ;;AAEzM;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;;AAElD;;AAEA;;AAEA;;AAEA,gBAAgB,8BAA8B;;AAE9C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,QAAQ;;AAE1C;;AAEA;;AAEA,gBAAgB;;AAEhB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;;AAE/C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;;AAEzB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;;AAEzB;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+BAA+B,8BAA8B;AAC7D,8BAA8B,8BAA8B;;AAE5D,8BAA8B,+BAA+B;AAC7D,8BAA8B,8BAA8B;;AAE5D,8BAA8B,8BAA8B;AAC5D,8BAA8B,8BAA8B;;AAE5D,+BAA+B,6BAA6B;AAC5D,8BAA8B,8BAA8B;;AAE5D;;AAEA,2BAA2B,0BAA0B;AACrD,2BAA2B,0BAA0B;;AAErD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,aAAa,cAAc;;AAE3B;;AAEA;;AAEA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa,cAAc;;AAE3B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,8GAA8G;AAC5J,mDAAmD,kIAAkI;;AAErL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC;AAChC,uBAAuB;AACvB,2BAA2B;AAC3B,2BAA2B;;AAE3B,mCAAmC;;AAEnC,4BAA4B;AAC5B,sBAAsB;;AAEtB,qBAAqB;AACrB,8BAA8B;;AAE9B,iBAAiB;;AAEjB,cAAc;;AAEd,yBAAyB;;AAEzB,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;AACA,wCAAwC;;AAExC,0EAA0E;AAC1E,0EAA0E;;AAE1E,MAAM;;AAEN,yFAAyF;;AAEzF,KAAK;;AAEL;;AAEA;;AAEA,4BAA4B;;AAE5B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,uBAAuB;;AAEvB,qBAAqB;AACrB,8BAA8B;;AAE9B,iBAAiB;;AAEjB;;AAEA,4BAA4B;;AAE5B,gDAAgD;;AAEhD;;AAEA,MAAM,6BAA6B;;AAEnC,2CAA2C;;AAE3C;;AAEA,MAAM,OAAO;;AAEb,2CAA2C;AAC3C,yCAAyC;AACzC,6BAA6B;AAC7B,gCAAgC;;AAEhC,MAAM;;AAEN,KAAK;AACL;;AAEA,EAAE;;;AAGF;;AAEA;;AAEA,gCAAgC;AAChC,uBAAuB;AACvB,2BAA2B;AAC3B,2BAA2B;;AAE3B,4BAA4B;AAC5B,sBAAsB;;AAEtB,qBAAqB;;AAErB,iBAAiB;;AAEjB,cAAc;;AAEd,yBAAyB;;AAEzB,4BAA4B;;AAE5B,0EAA0E;AAC1E,0EAA0E;;AAE1E,MAAM;;AAEN,yFAAyF;;AAEzF,KAAK;;AAEL;;AAEA;;AAEA,4BAA4B;;AAE5B,0BAA0B;AAC1B,mCAAmC;AACnC,0BAA0B;AAC1B,2BAA2B;AAC3B,uBAAuB;;AAEvB,qBAAqB;;AAErB,iBAAiB;;AAEjB;;AAEA,4BAA4B;;AAE5B,4DAA4D;;AAE5D;;AAEA,MAAM,6BAA6B;;AAEnC,2CAA2C;;AAE3C;;AAEA,MAAM,OAAO;;AAEb;AACA;AACA;AACA,2DAA2D;;AAE3D,8CAA8C;;AAE9C,2CAA2C;AAC3C,wCAAwC;AACxC,6BAA6B;AAC7B,gCAAgC;;AAEhC,MAAM;;AAEN,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC;AACrC,mCAAmC;AACnC,gCAAgC;AAChC,iCAAiC;AACjC,kCAAkC;AAClC,2BAA2B;AAC3B,uBAAuB;AACvB,2BAA2B;AAC3B,0BAA0B;AAC1B,yBAAyB;;AAEzB,4BAA4B;AAC5B,sBAAsB;;AAEtB,qBAAqB;;AAErB,iBAAiB;;AAEjB,mCAAmC;;AAEnC,iDAAiD;;AAEjD,0BAA0B;AAC1B,iHAAiH;AACjH,iHAAiH;;AAEjH,wBAAwB;;AAExB,sCAAsC;;AAEtC,yFAAyF;;AAEzF,MAAM,OAAO;;AAEb,sFAAsF;AACtF,gGAAgG;;AAEhG,MAAM;;AAEN,iCAAiC;;AAEjC,KAAK;;AAEL;;AAEA;;AAEA,4BAA4B;;AAE5B,uBAAuB;AACvB,0BAA0B;AAC1B,0BAA0B;;AAE1B,qBAAqB;;AAErB,iBAAiB;;AAEjB,0CAA0C;AAC1C,qEAAqE;;AAErE,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;;;;;;;;ACttjCA;AAAO,iBAAiB,KAAK,EAAE,QAAQ,EAAE,CAAc;IAAd,wBAAI,IAAI,CAAC,KAAK;IACrD,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,QAAQ,CAAC,CAAC;AACvE,CAAC;;;;;;;;;ACFD;AAAA;;;;KAIK;AACE,wBAAwB,CAAC;IAC9B,IAAI,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC;IAClC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;IAC7B,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC;IAClB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAClC,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC;IAClB,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;IAClC,CAAC,IAAI,OAAO,GAAG,EAAE,CAAC;IAClB,OAAO,GAAG,CAAC,GAAG,EAAE,CAAC;IAEjB,MAAM,CAAC;QACL,IAAI;QACJ,IAAI;QACJ,KAAK;QACL,IAAI;QACJ,OAAO;QACP,GAAG;KACJ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACb,CAAC;;;;;;;;;ACvBD;AAAA;IAIE;;;;;;;;;OASG;IAEH;IAAe,CAAC;IAbF,kBAAM,GAAW,UAAU,CAAC;IAe5C,kBAAC;CAAA;AAjBuB;;;;;;;;;;;;;;;;;;;;;;;ACAyB;AACN;AACU;AACN;AAK/C;IAgBE,qBAAoB,EAAe;QAAf,OAAE,GAAF,EAAE,CAAa;QAfnC,4BAA4B;QAC5B,4DAA4D;QAE5D,WAAM,GAAG,EAAE,CAAC;QACZ,eAAU,GAAG,IAAI,6EAAe,CAAa,qEAAU,CAAC,OAAO,CAAC,CAAC;QACjE,WAAM,GAAG,IAAI,6EAAe,CAAsB,EAAC,GAAG,EAAE,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC,EAAE,GAAG,EAAE,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC,EAAC,CAAC,CAAC;QACpG,kBAAa,GAAG,IAAI,6EAAe,CAAM,EAAE,CAAC,CAAC;QAC7C,8BAAyB,GAAG,IAAI,6EAAe,CAAU,IAAI,CAAC,CAAC;QAC/D,aAAQ,GAAG,IAAI,6EAAe,CAAU,IAAI,CAAC,CAAC;QAE9C,qBAAgB,GAAG,IAAI,6EAAe,CAAkB,IAAI,CAAC,CAAC;QAE9D,mBAAmB;QACnB,QAAG,GAAG,IAAI,CAAC;QAGT,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAEO,kCAAY,GAApB;QAAA,iBAMC;QALC,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,WAAW,CAAC,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,EAAE,IAAI,CAAC,CAAC;QAEhD,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,WAAW,CAAC,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,EAAE,IAAI,CAAC,CAAC;IAClD,CAAC;IAEO,qCAAe,GAAvB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,cAAc,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,UAAC,IAAyB;YAC7E,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,qCAAe,GAAvB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,eAAe,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACxD,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,wCAAkB,GAA1B;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,UAAC,GAAoB;YACpE,KAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,kCAAY,GAAnB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,WAAW,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACpD,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACL,CAAC;IAGM,kCAAY,GAAnB,UAAoB,MAAe;QAAnC,iBASC;QARC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,IAAM,SAAS,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;YACzC,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,EAAC,MAAM,EAAE,SAAS,EAAC,EAAE,EAAC,UAAU,EAAE,IAAI,EAAC,CAAC;iBAC/D,SAAS,CAAC,cAAI;gBACb,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC3B,OAAO,EAAE,CAAC;YACZ,CAAC,EAAE,aAAG,IAAI,aAAM,CAAC,GAAG,CAAC,EAAX,CAAW,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,4BAAM,GAAb,UAAc,GAAG;QAAjB,iBAMC;QALC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,EAAC,GAAG,OAAC,CAAC,CAAC,SAAS,CAAC,aAAG;gBACtC,KAAI,CAAC,GAAG,GAAG,GAAG,CAAC;YACjB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,4BAAM,GAAb;QAAA,iBAOC;QANC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,KAAI,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,EAAE,EAAC,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;gBAClD,KAAI,CAAC,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;gBACtB,OAAO,EAAE,CAAC;YACZ,CAAC,EAAE,aAAG,IAAI,aAAM,CAAC,GAAG,CAAC,EAAX,CAAW,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,kCAAY,GAAnB;QAAA,iBAOC;QANC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,EAAC,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;gBACvD,KAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC1B,OAAO,EAAE,CAAC;YACZ,CAAC,EAAE,aAAG,IAAI,aAAM,CAAC,GAAG,CAAC,EAAX,CAAW,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IA1FU,WAAW;QADvB,yEAAU,EAAE;yCAiBa,kEAAW;OAhBxB,WAAW,CA2FvB;IAAD,kBAAC;CAAA;AA3FuB;;;;;;;;;;;;;;;;;;;;;;;;;;;ACR4B;AACS;AAC9B;AACI;AACF;AACE;AACQ;AACM;AAIjD;IAQE,qBAAoB,IAAgB,EAAU,KAAqB;QAA/C,SAAI,GAAJ,IAAI,CAAY;QAAU,UAAK,GAAL,KAAK,CAAgB;QAL3D,kBAAa,GAAG,OAAO,CAAC;QAChC,2BAAsB,GAAoB;YACxC,IAAI,EAAE,IAAI;SACX,CAAC;QAGA,aAAW,CAAC,IAAI,GAAG,0EAAS,EAAE,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,EAAE,CAAC;IAC/D,CAAC;oBAVU,WAAW;IAYtB,yBAAG,GAAH,UAAI,GAAG,EAAE,IAAmD;QAA5D,iBAOC;QAPQ,8BAAwB,IAAI,CAAC,sBAAsB;QAC1D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,EAAC,OAAO,EAAE,UAAU,EAAC,CAAC;aACpD,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAAjD,CAAiD,CAAC;aAC7D,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,6BAAO,GAAP,UAAQ,GAAG,EAAE,IAAmD;QAAhE,iBAOC;QAPY,8BAAwB,IAAI,CAAC,sBAAsB;QAC9D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,OAAO,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,EAAC,OAAO,EAAE,UAAU,EAAC,CAAC;aACxD,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAArD,CAAqD,CAAC;aACjE,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,yBAAG,GAAH,UAAI,GAAG,EAAE,MAAM,EAAE,IAAmD;QAApE,iBAOC;QAPgB,8BAAwB,IAAI,CAAC,sBAAsB;QAClE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,MAAM,EAAE,EAAC,OAAO,EAAE,UAAU,EAAC,CAAC;aAC5D,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAAjD,CAAiD,CAAC;aAC7D,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,0BAAI,GAAJ,UAAK,GAAG,EAAE,MAAM,EAAE,IAAmD;QAArE,iBAOC;QAPiB,8BAAwB,IAAI,CAAC,sBAAsB;QACnE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,IAAI,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,MAAM,EAAE,EAAC,OAAO,EAAE,UAAU,EAAC,CAAC;aAC7D,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAAlD,CAAkD,CAAC;aAC9D,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,8BAAQ,GAAR,UAAS,GAAG,EAAE,IAAI,EAAE,IAAmD;QAAvE,iBAgBC;QAhBmB,8BAAwB,IAAI,CAAC,sBAAsB;QACrE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,IAAM,OAAO,GAAG,IAAI,yEAAW,EAAE,CAAC;QAClC,IAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;QAChC,QAAQ,CAAC,MAAM,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QACpC,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,qBAAqB,CAAC,CAAC;QACtD,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;QACjD,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;QAC7C,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,IAAI,CAAC,aAAW,CAAC,IAAI,GAAG,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,QAAQ,EAAE;YAC3D,OAAO;YACL,OAAO,EAAE,UAAU;SACtB,CAAC;aACD,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,WAAW,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAAvD,CAAuD,CAAC;aACnE,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,4BAAM,GAAN,UAAO,GAAG,EAAE,IAAmD;QAA/D,iBAOC;QAPW,8BAAwB,IAAI,CAAC,sBAAsB;QAC7D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI;aACb,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,GAAG,EAAE,EAAC,OAAO,EAAE,UAAU,EAAC,CAAC;aACvD,GAAG,CAAC,cAAI,IAAI,WAAI,CAAC,IAAI,EAAT,CAAS,CAAC;aACtB,KAAK,CAAC,WAAC,IAAI,YAAI,CAAC,YAAY,CAAC,CAAC,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,EAApD,CAAoD,CAAC;aAChE,OAAO,CAAC,cAAM,YAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC;IAED,gCAAU,GAAV,UAAW,IAAqB;QAC9B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;YACZ,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACpC,CAAC;IAED,kCAAY,GAAZ,UAAa,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,UAAU;QACrC,IAAI,CAAC,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;QAEzC,EAAE,CAAC,CAAC,UAAU,CAAC;YACb,MAAM,CAAC,mEAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,CAAC,mEAAU,CAAC,KAAK,EAAE,CAAC;IAC5B,CAAC;IAED,oCAAc,GAAd,UAAe,IAAqB;QAClC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;YACZ,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;IACrB,CAAC;IAED,yCAAmB,GAAnB,UAAoB,CAAC,EAAE,MAAM,EAAE,GAAG;QAChC,OAAO,CAAC,KAAK,CAAC,YAAU,MAAM,cAAS,GAAG,OAAI,EAAE,CAAC,CAAC,CAAC;IACrD,CAAC;IA/FU,WAAW;QADvB,yEAAU,EAAE;yCASe,wEAAU,EAAiB,wEAAc;OARxD,WAAW,CAgGvB;IAAD,kBAAC;;CAAA;AAhGuB;;;;;;;;;;;;;;;;;;;;;;;ACXiB;AACK;AACS;AACV;AAG7C;IAEE,wBAAoB,QAAqB,EAAU,UAA6B;QAA5D,aAAQ,GAAR,QAAQ,CAAa;QAAU,eAAU,GAAV,UAAU,CAAmB;IAAG,CAAC;IAEpF,6BAAI,GAAJ,UAAK,IAA6B,EAAE,GAAY;QAA3C,8BAAgB,mEAAO,CAAC,KAAK;QAChC,IAAI,cAAsB,CAAC;QAC3B,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACb,KAAK,mEAAO,CAAC,IAAI;gBACf,cAAc,GAAG,UAAU,CAAC;gBAC5B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;oBAAC,GAAG,GAAG,mBAAmB,CAAC;gBACpC,KAAK,CAAC;YACR,QAAS,WAAW;gBAClB,cAAc,GAAG,WAAW,CAAC;gBAC7B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;oBAAC,GAAG,GAAG,0BAA0B,CAAC;gBAC3C,KAAK,CAAC;QACV,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,IAAI,EAClD;YACE,QAAQ,EAAE,IAAI;YACd,YAAY,EAAE,UAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAI;YACxD,UAAU,EAAE,CAAC,cAAc,EAAE,UAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAI,CAAC;SACzE,CAAC,CAAC;IACP,CAAC;IAvBU,cAAc;QAD1B,yEAAU,EAAE;yCAGmB,sEAAW,EAAsB,8EAAiB;OAFrE,cAAc,CAyB1B;IAAD,qBAAC;CAAA;AAzB0B;;;;;;;;;;;;;;;;;;;;;;;;ACNc;AACY;AACV;AACW;AAEX;AAG3C;IAyBE,sBAAoB,EAAe,EAAU,EAAe;QAA5D,iBAGC;QAHmB,OAAE,GAAF,EAAE,CAAa;QAAU,OAAE,GAAF,EAAE,CAAa;QAxB5D,iBAAY,GAAG,IAAI,6EAAe,CAAU,KAAK,CAAC,CAAC;QACnD,iBAAY,GAAG,IAAI,6EAAe,CAAc,4EAAW,CAAC,QAAQ,CAAC,CAAC;QACtE,kBAAa,GAAG,IAAI,6EAAe,CAAS,CAAC,CAAC,CAAC;QAC/C,eAAU,GAAG,IAAI,6EAAe,CAAS,CAAC,CAAC,CAAC;QAC5C,gBAAW,GAAG,IAAI,6EAAe,CAAa,EAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,CAAC,CAAC;QAC1E,eAAU,GAAG,IAAI,6EAAe,CAAS,CAAC,CAAC,CAAC;QAE5C,uEAAuE;QACvE,mEAAmE;QACnE,iFAAiF;QACjF,yEAAyE;QACzE,kFAAkF;QAClF,qFAAqF;QACrF,mFAAmF;QACnF,kFAAkF;QAClF,WAAW;QACX,gDAAgD;QAChD,gDAAgD;QAChD,kBAAa,GAAG,KAAK,CAAC;QAEtB,oCAAoC;QACpC,2BAAsB,GAAG,KAAK,CAAC;QAC/B,oBAAe,GAAG,IAAI,6EAAe,CAAU,IAAI,CAAC,CAAC;QAGnD,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,UAAU,CAAC,cAAM,YAAI,CAAC,aAAa,EAAE,EAApB,CAAoB,CAAC,CAAC;IACzC,CAAC;IAEO,oCAAa,GAArB;QAAA,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,SAAS,CAAC,aAAG;YACpC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YACjB,KAAI,CAAC,sBAAsB,GAAG,GAAG,CAAC,QAAQ,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,mCAAY,GAApB;QAAA,iBAKC;QAJC,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,WAAW,CAAC,cAAM,YAAI,CAAC,cAAc,EAAE,EAArB,CAAqB,EAAE,IAAI,CAAC,CAAC;QAE/C,IAAI,CAAC,2BAA2B,EAAE,CAAC;IACrC,CAAC;IAEO,kDAA2B,GAAnC;QAAA,iBAoBC;QAnBC,IAAI,mBAAmB,CAAC;QACxB,IAAI,YAAY,CAAC;QACjB,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,uBAAa;YACvC,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;gBAClB,KAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,KAAI,CAAC,OAAO,EAAE,CAAC;gBACf,mBAAmB,GAAG,WAAW,CAAC,cAAM,YAAI,CAAC,iBAAiB,EAAE,EAAxB,CAAwB,EAAE,IAAI,CAAC,CAAC;gBACxE,YAAY,GAAG,WAAW,CAAC,cAAM,YAAI,CAAC,OAAO,EAAE,EAAd,CAAc,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;YAClE,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,mBAAmB,CAAC;oBACtB,aAAa,CAAC,mBAAmB,CAAC,CAAC;gBACrC,EAAE,CAAC,CAAC,YAAY,CAAC;oBACf,aAAa,CAAC,YAAY,CAAC,CAAC;gBAE9B,uBAAuB;gBACvB,KAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,KAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,wCAAiB,GAAzB;QACE,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,IAAI,CAAC,aAAa,EAAE,CAAC;QAErB,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC;YAC9B,IAAI,CAAC,aAAa,EAAE,CAAC;IACzB,CAAC;IAED,qCAAc,GAAd;QAAA,iBAWC;QAVC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,cAAc,EAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC/E,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC;gBAC1D,MAAM,CAAC;YAET,2DAA2D;YAC3D,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;gBAClD,MAAM,CAAC;YAET,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,qCAAc,GAAtB;QAAA,iBAOC;QANC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,MAAM,EAAE,YAAY,EAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACzE,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;QAC9C,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAChD,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,8BAAO,GAAf;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACnD,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qCAAqC;IAC9B,oCAAa,GAApB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,UAAC,IAAgB;YAC7D,KAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mEAAmE;IAC3D,oCAAa,GAArB;QAAA,iBASC;QARC,kDAAkD;QAClD,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACnD,IAAM,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,CAAC;YAC7C,yBAAyB;YACvB,UAAU;YAEZ,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,gEAAgE;IAChE,gEAAgE;IACxD,qCAAc,GAAtB;QAAA,iBASC;QARC,IAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;QAC5C,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC7D,IAAM,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,OAAO,CAAC;YAChD,EAAE,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC;gBACpB,MAAM,CAAC;YAET,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;IACL,CAAC;IArIU,YAAY;QADxB,yEAAU,EAAE;yCA0Ba,kEAAW,EAAc,kEAAW;OAzBjD,YAAY,CAsIxB;IAAD,mBAAC;CAAA;AAtIwB;;;;;;;;;;;;;;;;;;;;;;ACRgB;AACQ;AAEjD,IAAY,gBAKX;AALD,WAAY,gBAAgB;IAC1B,+CAA2B;IAC3B,mDAA+B;IAC/B,qCAAiB;IACjB,mCAAe;AACjB,CAAC,EALW,gBAAgB,KAAhB,gBAAgB,QAK3B;AAGD;IAOE;QANA,qBAAgB,GAAG,gBAAgB,CAAC;QACpC,iBAAY,GAA2B,IAAI,yEAAa,CAAC,CAAC,CAAC,CAAC;QAC5D,iBAAY,GAAuB,IAAI,yEAAa,CAAC,CAAC,CAAC,CAAC;QACxD,kBAAa,GAA0B,IAAI,yEAAa,CAAC,CAAC,CAAC,CAAC;QAC5D,wBAAmB,GAA0B,IAAI,yEAAa,CAAC,CAAC,CAAC,CAAC;QAGhE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE9B,qBAAqB;QACrB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAC5D,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC5B,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IAED,gCAAM,GAAN;QACE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAED,iCAAO,GAAP;QACE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAtBU,eAAe;QAD3B,yEAAU,EAAE;;OACA,eAAe,CAwB3B;IAAD,sBAAC;CAAA;AAxB2B;;;;;;;;;;;;;;;;;;;;ACXa;AAKzC;IAOE,2BAA2B;IAE3B,4DAA4D;IAC5D,+CAA+C;IAC/C,2BAA2B;IAC3B,QAAQ;IACR,MAAM;IAEN;QACE,qDAAqD;QAf/C,QAAG,GAAG,kBAAkB,CAAC;QACzB,iBAAY,GAAG;YACrB,UAAU,EAAE,CAAC,WAAW,CAAC;SAC1B,CAAC;QAcA,gDAAgD;QAChD,qCAAqC;QACrC,gDAAgD;QAChD,gFAAgF;QAChF,MAAM;IACR,CAAC;IAvBU,aAAa;QADzB,yEAAU,EAAE;;OACA,aAAa,CAoCzB;IAAD,oBAAC;CAAA;AApCyB;;;;;;;;;;;;;;;;;;;;;ACLe;AACY;AAGrD;IAUE;QATA,0CAA0C;QAC1C,uCAAuC;QACvC,4CAA4C;QAC5C,4CAA4C;QAC5C,UAAK,GAAG,IAAI,6EAAe,CAAU,KAAK,CAAC,CAAC;QAC5C,UAAK,GAAG,CAAC,CAAC;QACV,iBAAY,GAAG,CAAC,CAAC;QACjB,mBAAc,GAAG,CAAC,CAAC;IAGnB,CAAC;IAED,6CAA6C;IAC7C,2BAAE,GAAF,UAAG,cAAoC;QAAvC,iBAOC;QAPE,kDAAiB,IAAI,CAAC,cAAc;QACrC,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,IAAI,CAAC,YAAY,EAAE,CAAC;QAEpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEtB,UAAU,CAAC,cAAM,YAAI,CAAC,UAAU,EAAE,EAAjB,CAAiB,EAAE,cAAc,GAAG,IAAI,CAAC,CAAC;IAC7D,CAAC;IAED,sBAAsB;IACtB,4BAAG,GAAH;QACE,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACvB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACjB,CAAC;IACH,CAAC;IAED,4BAA4B;IAC5B,mCAAU,GAAV;QACE,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,OAAO,CAAC,KAAK,CAAC,aAAW,IAAI,CAAC,KAAK,wBAAmB,IAAI,CAAC,YAAY,MAAG,CAAC,CAAC;QAC5E,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;YACxB,MAAM,CAAC;QAET,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;YAClB,MAAM,CAAC;QAET,OAAO,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC;QACzD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;IACxB,CAAC;IA7CU,cAAc;QAD1B,yEAAU,EAAE;;OACA,cAAc,CA8C1B;IAAD,qBAAC;CAAA;AA9C0B;;;;;;;;;;;;;;;;;;;;;;;;ACJsB;AACN;AACK;AACL;AACU;AAGrD;IAaE,2BAAoB,EAAe,EAAU,IAAgB;QAAzC,OAAE,GAAF,EAAE,CAAa;QAAU,SAAI,GAAJ,IAAI,CAAY;QAZ7D;;;;;;;WAOG;QACH,cAAS,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,+BAA+B;QACnD,UAAK,GAAG,IAAI,6EAAe,CAAS,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,SAAI,GAAG,EAAE,CAAC;QAGR,IAAI,CAAC,eAAe,EAAE,CAAC;IACzB,CAAC;IAED,8DAA8D;IAC9D,8DAA8D;IAC9D,kCAAM,GAAN,UAAO,IAAI;QACT,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED,2CAAe,GAAf;QAAA,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC,SAAS,CAAC,eAAK;YAC1C,KAAI,CAAC,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC;YACnC,KAAI,CAAC,kBAAkB,EAAE,CAAC;QAC5B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,8CAAkB,GAAlB;QAAA,iBASC;QARC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YACxD,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7C,OAAO,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;gBAC5C,MAAM,CAAC;YACT,CAAC;YAED,KAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAgB,GAAhB,UAAiB,GAAG;QAApB,iBAmBC;QAlBC,EAAE,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YAClC,OAAO,CAAC,GAAG,CAAC,eAAa,GAAG,yBAAsB,CAAC,CAAC;YACpD,MAAM,CAAC;QACT,CAAC;QAED,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;YACnE,KAAI,CAAC,IAAI,CAAC,GAAG,CAAI,iEAAW,CAAC,MAAM,yBAAoB,GAAG,UAAO,CAAC,CAAC,SAAS,CAAC,cAAI;gBAC/E,KAAI,CAAC,IAAI,GAAG,IAAI,CAAC;gBACjB,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACvB,CAAC,EAAE,aAAG;gBACJ,EAAE,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC;oBACjB,KAAI,CAAC,IAAI,GAAG,EAAE,CAAC;oBACf,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACrB,MAAM,CAAC;gBACT,CAAC;gBACD,OAAO,CAAC,KAAK,CAAC,mDAAmD,EAAE,GAAG,CAAC,CAAC;YAC1E,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qCAAS,GAAT;QACE,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC;IAChD,CAAC;IApEU,iBAAiB;QAD7B,yEAAU,EAAE;yCAca,kEAAW,EAAgB,wEAAU;OAblD,iBAAiB,CAsE7B;IAAD,wBAAC;CAAA;AAtE6B;;;;;;;;;;;;;;;;;;;;;;ACPW;AACY;AACV;AAG3C;IAME,uBAAoB,EAAe;QAAf,OAAE,GAAF,EAAE,CAAa;QAJnC,kBAAa,GAAG,IAAI,6EAAe,CAAS,IAAI,CAAC,CAAC;QAClD,mBAAc,GAAG,IAAI,6EAAe,CAAS,IAAI,CAAC,CAAC;QACnD,gBAAW,GAAG,IAAI,6EAAe,CAAS,GAAG,CAAC,CAAC;IAG/C,CAAC;IAED,uCAAe,GAAf,UAAgB,IAAI;QAApB,iBAoBC;QAnBC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACV,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/B,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;QAED,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,IAAM,OAAO,GAAG,KAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;YAC/C,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;gBACR,IAAI,GAAG,OAAO,CAAC;YACjB,KAAI,CAAC,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,yBAAyB,EAAE,MAAM,EAAE,IAAI,EAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;gBACzH,EAAE,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC;oBACnB,MAAM,CAAC;gBAET,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC/B,OAAO,EAAE,CAAC;YACZ,CAAC,EAAE,aAAG;gBACJ,MAAM,EAAE,CAAC;YACX,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oCAAY,GAAZ;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,yBAAyB,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC3E,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,0CAAkB,GAAlB,UAAmB,GAAG;QAAtB,iBASC;QARC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,KAAI,CAAC,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,gBAAgB,EAAE,MAAM,EAAE,GAAG,EAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;gBAC/G,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC7B,OAAO,EAAE,CAAC;YACZ,CAAC,EAAE,aAAG;gBACJ,MAAM,EAAE,CAAC;YACX,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,uCAAe,GAAf;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,EAAC,IAAI,EAAE,gBAAgB,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAClE,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qCAAa,GAAb,UAAc,GAAS;QAAT,+BAAS;QACrB,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC;YACvB,MAAM,CAAC;QAET,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IA3DU,aAAa;QADzB,yEAAU,EAAE;yCAOa,kEAAW;OANxB,aAAa,CA6DzB;IAAD,oBAAC;CAAA;AA7DyB;;;;;;;;;;;;;;;;;;;;;ACLe;AACY;AAErD;IACE,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAGD;IAKE;QAAA,iBAIC;QARD,cAAS,GAAG,IAAI,6EAAe,CAAS,IAAI,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,CAAC;QACrE,eAAU,GAAG,IAAI,6EAAe,CAAS,IAAI,CAAC,SAAS,EAAE,CAAC,WAAW,CAAC,CAAC;QACvE,aAAQ,GAAG,KAAK,CAAC;QAGf,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,WAAC;YACxB,KAAI,CAAC,QAAQ,GAAG,CAAC,GAAG,GAAG,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qCAAa,GAAb;QACE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC;IACzC,CAAC;IAED,iCAAS,GAAT;QACE,MAAM,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC;IAjBU,aAAa;QADzB,yEAAU,EAAE;;OACA,aAAa,CAkBzB;IAAD,oBAAC;CAAA;AAlByB;;;;;;;;ACR1B,qdAAqd,QAAQ,obAAob,aAAa,mwGAAmwG,0BAA0B,+BAA+B,8BAA8B,mCAAmC,i2B;;;;;;;ACA3xI,kCAAkC,gBAAgB,EAAE,iBAAiB,gBAAgB,kBAAkB,mBAAmB,2BAA2B,EAAE,mBAAmB,qBAAqB,EAAE,2BAA2B,0FAA0F,2BAA2B,EAAE,mBAAmB,oBAAoB,EAAE,qBAAqB,wBAAwB,2BAA2B,2BAA2B,EAAE,wBAAwB,uBAAuB,WAAW,cAAc,YAAY,aAAa,qBAAqB,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAziB;AACa;AACM;AACd;AACO;AAO5D;IAAuC,qCAAQ;IAE7C,2BAAoB,EAAe,EAAU,EAAkB;QAA/D,YACE,kBAAM,aAAa,CAAC,SACrB;QAFmB,QAAE,GAAF,EAAE,CAAa;QAAU,QAAE,GAAF,EAAE,CAAgB;;IAE/D,CAAC;IAED,oCAAQ,GAAR;IACA,CAAC;IAED,2CAAe,GAAf,UAAgB,KAAK;QAArB,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,EAAC,KAAK,SAAC,CAAC,CAAC,SAAS,CAAC,aAAG;YAChD,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,6EAAO,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAbU,iBAAiB;QAL7B,wEAAS,CAAC;YACT,QAAQ,EAAE,cAAc;;;SAGzB,CAAC;yCAGwB,qFAAW,EAAc,2FAAc;OAFpD,iBAAiB,CAe7B;IAAD,wBAAC;CAAA,CAfsC,oFAAQ,GAe9C;AAf6B;;;;;;;;ACX9B,u2C;;;;;;;ACAA,kCAAkC,kBAAkB,gBAAgB,0BAA0B,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAhD;AACY;AACC;AACA;AACjB;AACyD;AAC9C;AAChB;AAC4B;AACd;AACF;AAOnD;IAAuC,qCAAQ;IAQ7C,2BAAoB,EAAe,EAAU,EAAe,EAClD,MAAiB,EAAU,MAAc,EACzC,EAAkB;QAF5B,YAGE,kBAAM,SAAS,CAAC,SAIjB;QAPmB,QAAE,GAAF,EAAE,CAAa;QAAU,QAAE,GAAF,EAAE,CAAa;QAClD,YAAM,GAAN,MAAM,CAAW;QAAU,YAAM,GAAN,MAAM,CAAQ;QACzC,QAAE,GAAF,EAAE,CAAgB;QAT5B,WAAK,GAAG,CAAC,CAAC;QACV,cAAQ,GAAG,GAAG,CAAC;QACf,cAAQ,GAAG,CAAC,CAAC;QAUX,KAAI,CAAC,OAAO,GAAG,4EAAW,CAAC,MAAM,GAAG,eAAe,CAAC;QACpD,KAAI,CAAC,SAAS,GAAG,4EAAW,CAAC,MAAM,GAAG,iBAAiB,CAAC;;IAC1D,CAAC;IAED,oCAAQ,GAAR;QACE,IAAI,CAAC,uBAAuB,EAAE,CAAC;IACjC,CAAC;IAED,mDAAuB,GAAvB;QAAA,iBAYC;QAXC,UAAU,CAAC;YACT,EAAE,CAAC,CAAC,KAAI,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBAC/C,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6HAAsB,EAAE;oBACvC,IAAI,EAAE;wBACJ,KAAK,EAAE,+EAAU,CAAC,cAAc;qBACjC;iBACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;oBAC5B,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBAClC,CAAC,CAAC,CAAC;YACL,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAO,GAAP,UAAQ,GAAW;QAAnB,iBASC;QATO,iCAAW;QACjB,IAAM,YAAY,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;QACpD,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE;YACtB,KAAK,EAAE,YAAY;YACnB,QAAQ,EAAE,IAAI,CAAC,QAAQ;SACxB,CAAC,CAAC,SAAS,CAAC,aAAG;YACd,KAAI,CAAC,QAAQ,IAAI,YAAY,CAAC;YAC9B,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,6EAAO,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IA5CU,iBAAiB;QAL7B,wEAAS,CAAC;YACT,QAAQ,EAAE,cAAc;;;SAGzB,CAAC;yCASwB,qFAAW,EAAc,qFAAW;YAC1C,oEAAS,EAAkB,+DAAM;YACrC,2FAAc;OAVjB,iBAAiB,CA8C7B;IAAD,wBAAC;CAAA,CA9CsC,oFAAQ,GA8C9C;AA9C6B;;;;;;;;ACjB9B,8XAA8X,s5BAAs5B,cAAc,qLAAqL,qgBAAqgB,oBAAoB,6iBAA6iB,IAAI,odAAod,uDAAuD,4RAA4R,WAAW,6/BAA6/B,2BAA2B,45BAA45B,kBAAkB,sH;;;;;;;ACAzxK,+BAA+B,oBAAoB,0IAA0I,0IAA0I,EAAE,uBAAuB,2IAA2I,2IAA2I,EAAE,sBAAsB,mCAAmC,EAAE,mBAAmB,mBAAmB,EAAE,yBAAyB,mBAAmB,EAAE,mBAAmB,gBAAgB,iBAAiB,oBAAoB,qBAAqB,EAAE,2BAA2B,oBAAoB,cAAc,gBAAgB,YAAY,eAAe,EAAE,oBAAoB,oCAAoC,eAAe,gBAAgB,EAAE,uBAAuB,qBAAqB,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAlhC;AACX;AACT;AACU;AACA;AACI;AACa;AACjB;AACM;AACA;AACd;AACE;AAC8C;AACpC;AAC1B;AACwB;AAG/D,IAAM,SAAS,GAAG,QAAQ,CAAC;AAC3B,IAAM,eAAe,GAAG,WAAW,CAAC;AAOpC;IAAmC,iCAAQ;IAgCzC,uBAAoB,EAAe,EAAU,SAA0B,EAC9D,EAAiB,EAAU,EAAe,EACzC,KAAqB,EAAU,MAAiB,EAChD,EAAkB,EAAU,EAAiB,EAC7C,MAAc,EAAU,EAAgB;QAJlD,YAKE,kBAAM,WAAW,CAAC,SAGnB;QARmB,QAAE,GAAF,EAAE,CAAa;QAAU,eAAS,GAAT,SAAS,CAAiB;QAC9D,QAAE,GAAF,EAAE,CAAe;QAAU,QAAE,GAAF,EAAE,CAAa;QACzC,WAAK,GAAL,KAAK,CAAgB;QAAU,YAAM,GAAN,MAAM,CAAW;QAChD,QAAE,GAAF,EAAE,CAAgB;QAAU,QAAE,GAAF,EAAE,CAAe;QAC7C,YAAM,GAAN,MAAM,CAAQ;QAAU,QAAE,GAAF,EAAE,CAAc;QAzBlD,QAAE,GAAG,EAAE,CAAC;QACR,aAAO,GAAG,EAAE,CAAC;QACb,mBAAa,GAAG,EAAE,CAAC;QACnB,YAAM,GAA4B,EAAE,CAAC;QAGrC,wEAAwE;QACxE,gCAAgC;QAChC,iCAAiC;QACjC,wDAAwD;QACxD,sBAAgB,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAsC,CAAC;QACjF,gBAAU,GAAG,IAAI,6EAAkB,EAAE,CAAC;QACtC,uCAAuC;QACvC,kBAAY,GAAG,EAAC,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAC,CAAC;QAEpC,uDAAuD;QACvD,mBAAa,GAAG,EAAE,CAAC;QAWjB,KAAI,CAAC,QAAQ,GAAG,2EAAW,CAAC,MAAM,GAAG,gBAAgB,CAAC;QACtD,KAAI,CAAC,WAAW,GAAG,2EAAW,CAAC,MAAM,GAAG,yBAAyB,CAAC;;IACpE,CAAC;IAED,gCAAQ,GAAR;QAAA,iBAUC;QATC,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,SAAS,EAAE,CAAC;QAEjB,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,SAAS,CAAC,cAAI;YACnC,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC5B,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,uBAAuB,GAAG,EAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAC,CAAC;QACjD,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC5B,CAAC;IAED,iCAAS,GAAT;QAAA,iBAMC;QALC,UAAU,CAAC;YACT,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,EAAE,CAAC;YAC1B,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,GAAG,EAAE,CAAC;YAC5C,KAAI,CAAC,UAAU,CAAC,SAAS,GAAG,KAAI,CAAC,SAAS,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,0CAAkB,GAAlB;QAAA,iBAuBC;QAtBC,qBAAqB;QACrB,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC;YACpB,EAAE,CAAC,CAAC,KAAI,CAAC,EAAE,CAAC,GAAG,CAAC;gBACd,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAChC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC,IAAI,CAAC,8BAAoB;YAC1B,MAAM,CAAC,KAAI,CAAC,iBAAiB,EAAE,CAAC,IAAI,CAAC,aAAG;gBACtC,KAAI,CAAC,uBAAuB,GAAG,GAAG,CAAC;gBAEnC,EAAE,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC;oBACzB,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,EAAE,KAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC,CAAC;oBACzF,MAAM,CAAC;gBACT,CAAC;gBAED,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC;oBACf,KAAK,EAAE,+BAA+B;oBACtC,IAAI,EAAE,wBAAwB;oBAC9B,MAAM,EAAE,KAAI,CAAC,uBAAuB;iBACrC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC,KAAK,CAAC,aAAG,IAAI,cAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAhB,CAAgB,CAAC,CAAC;IAEpC,CAAC;IAED,iCAAS,GAAT,UAAU,CAAC;QACT,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED,+CAAuB,GAAvB;QAAA,iBASC;QARC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,aAAG;YACpE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACT,KAAI,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,CAAC;gBACpC,MAAM,CAAC;YACT,CAAC;YAED,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,EAAE,KAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC,CAAC;QAC3F,CAAC,CAAC,CAAC,KAAK,CAAC,aAAG,IAAI,cAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAhB,CAAgB,CAAC,CAAC;IACpC,CAAC;IAED,yCAAiB,GAAjB;QAAA,iBAWC;QAVC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,MAAM,EAAE,YAAY,EAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;gBAC1F,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,CAAC;oBAC9B,MAAM,CAAC,qBAAqB,CAAC,CAAC;gBAChC,OAAO,CAAC;oBACN,EAAE,EAAE,GAAG,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC;oBAC3B,IAAI,EAAE,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;iBAChC,CAAC,CAAC;YACL,CAAC,EAAE,aAAG,IAAI,aAAM,CAAC,GAAG,CAAC,EAAX,CAAW,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAoB,GAApB,UAAqB,EAAE;QAAvB,iBAcC;QAbC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,EAAE,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;gBACjC,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;YAEvC,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8HAAsB,EAAE;gBACvC,IAAI,EAAE;oBACJ,KAAK,EAAE,gFAAU,CAAC,qBAAqB;oBACvC,EAAE;iBACH;aACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;gBAC5B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YACtB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAEK,gCAAQ,GAAd,UAAe,MAAM,EAAE,IAAI;;;;;4BACzB,qBAAM,IAAI,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;wBAA3D,SAA2D,CAAC;wBAC5D,UAAU,CAAC;4BACT,KAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;wBAC7B,CAAC,EAAE,GAAG,CAAC,CAAC;;;;;KACT;IAED,kCAAU,GAAV,UAAW,IAAI;QACb,sBAAsB;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAElC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,iEAAiE;QACjE,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,IAAI,CAAC,YAAY,EAAE,CAAC;IACxB,CAAC;IAED,kCAAU,GAAV,UAAW,MAAM,EAAE,IAAI;QAAvB,iBAiBC;QAhBC,MAAM,CAAC,eAAe,EAAE,CAAC;QACzB,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC;YACvC,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAE3B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8HAAsB,EAAE;YACvC,IAAI,EAAE;gBACJ,KAAK,EAAE,gFAAU,CAAC,aAAa;aAChC;SACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;YAC5B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YAEjB,KAAI,CAAC,EAAE,CAAC,MAAM,CAAC,iBAAe,IAAI,CAAC,IAAM,CAAC,CAAC,SAAS,CAAC,cAAI;gBACvD,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,8EAAO,CAAC,IAAI,CAAC,CAAC;gBAC3B,KAAI,CAAC,gBAAgB,EAAE,CAAC;YAC1B,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,iCAAS,GAAT;QAAA,iBAsBC;QArBC,IAAI,YAAY,GAAG,EAAE,CAAC;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YACpB,YAAY,GAAG,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;QAC1D,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,YAAY,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;QACxD,CAAC;QAED,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8HAAsB,EAAE;YACtD,IAAI,EAAE;gBACJ,KAAK,EAAE,gFAAU,CAAC,YAAY;gBAC9B,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI;aAC7B;SACF,CAAC,CAAC;QACH,wCAAwC;QACxC,8CAA8C;QAC9C,MAAM;QACN,MAAM,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;YAChC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YAEjB,KAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,iCAAS,GAAT,UAAU,EAAE,EAAE,IAAQ;QAAtB,iBAUC;QAVa,+BAAQ;QACpB,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,EAAE,MAAE,IAAI,QAAE,MAAM,EAAE,OAAO,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC/D,mDAAmD;YACnD,KAAI,CAAC,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC;YAC7B,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAEtC,+BAA+B;YAC/B,mCAAmC;YACnC,mCAAmC;QACrC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAW,GAAX,UAAY,GAAG;QACb,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC;QACzB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,IAAI;YACF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IACxB,CAAC;IAED,oCAAoC;IACpC,uBAAuB;IACvB,4FAA4F;IAC5F,2FAA2F;IAC3F,iCAAS,GAAT,UAAU,GAAG,EAAE,KAAY;QAA3B,iBA2BC;QA3Bc,oCAAY;QACzB,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,KAAK,EAAE,CAAC;YACrB,MAAM,CAAC;QAET,kBAAkB;QAClB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,8CAA8C;QAC9C,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC;YACjB,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAEhC,IAAI,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC;QACrB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC/B,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,EAAC,EAAE,EAAE,MAAM,EAAC,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,EAAE,KAAK,EAAE,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC5E,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;gBACjC,KAAI,CAAC,YAAY,EAAE,CAAC;YACtB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,EAAE,GAAG,MAAM,CAAC;gBACjB,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YACzD,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAW,GAAX,UAAY,EAAE;QACZ,mEAAmE;QACnE,mEAAmE;QACnE,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;YACrB,4GAA4G;YAC5G,MAAM,CAAC,MAAM,CAAC;gBACZ,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,aAAa,CAAC,SAAS;gBACrC,QAAQ,EAAE,QAAQ;aACnB,CAAC,CAAC;QACL,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;gBACtB,MAAM,EAAE,EAAE;aACX,CAAC,CAAC;QACL,CAAC;QACD,sBAAsB;QACtB,yCAAyC;IAC3C,CAAC;IAED,yCAAyC;IACzC,kCAAU,GAAV;QAAA,iBASC;QARC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,EAAC,EAAE,EAAE,EAAE,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;YACtD,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3E,KAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YACpB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC;gBACxB,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC/B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,wCAAgB,GAAhB;QAAA,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,SAAS,CAAC,aAAG;YACtC,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YACtD,KAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,gCAAQ,GAAhB,UAAiB,IAAI,EAAE,QAAgB;QAAhB,2CAAgB;QACrC,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,OAAO,CAAC,YAAE;YACb,GAAG,CAAC,IAAI,CAAC;gBACP,MAAM,EAAE,EAAE;gBACV,MAAM,EAAE,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ;aAC/D,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,gBAAgB,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACjD,EAAE,CAAC,CAAC,QAAQ,CAAC;YAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEnD,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,oCAAY,GAAZ,UAAa,IAAI;QACf,IAAI,SAAS,GAAG,qFAAW,CAAC,IAAI,GAAG,gBAAgB,CAAC;QAEpD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,SAAS,IAAI,WAAS,IAAM,CAAC;QAC/B,IAAI;YACF,SAAS,IAAI,UAAQ,IAAI,CAAC,EAAE,SAAI,IAAM,CAAC;QAEzC,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC;IAED,yCAAiB,GAAjB;QACE,IAAI,CAAC,YAAY,GAAG;YAClB,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,EAAE;SACT,CAAC;QACF,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED,oCAAY,GAAZ;QACE,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC;IAC7C,CAAC;IAED,uCAAe,GAAf;QACE,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,IAAI,KAAK,CAAC;IACtD,CAAC;IAED,gCAAQ,GAAR;QACE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC;IACxD,CAAC;IAED,8BAAM,GAAN,UAAO,IAAI;QACT,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;IAClC,CAAC;IAED,kCAAU,GAAV,UAAW,GAAG;QACZ,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC;IAClF,CAAC;IAED,iDAAyB,GAAzB;QACE,MAAM,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,MAAM,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;IAC5F,CAAC;IAED,sCAAc,GAAd;QACE,IAAI,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAxVuB;QAAvB,0EAAS,CAAC,WAAW,CAAC;kCAAY,iEAAU;oDAAC;IACzB;QAApB,0EAAS,CAAC,QAAQ,CAAC;kCAAS,iEAAU;iDAAC;IAEf;QAAxB,0EAAS,CAAC,uEAAY,CAAC;kCAAY,uEAAY;oDAAC;IANtC,aAAa;QALzB,wEAAS,CAAC;YACT,QAAQ,EAAE,UAAU;;;SAGrB,CAAC;yCAiCwB,qFAAW,EAAqB,qFAAe;YAC1D,yFAAa,EAAc,qFAAW;YAClC,2FAAc,EAAkB,oEAAS;YAC5C,2FAAc,EAAc,0FAAa;YACrC,gEAAM,EAAc,wFAAY;OApCvC,aAAa,CA4VzB;IAAD,oBAAC;CAAA,CA5VkC,oFAAQ,GA4V1C;AA5VyB;;;;;;;;AC1B1B,ihBAAihB,UAAU,8QAA8Q,gBAAgB,oUAAoU,oBAAoB,uTAAuT,WAAW,iVAAiV,kBAAkB,0nBAA0nB,2BAA2B,wP;;;;;;;ACA38E,wCAAwC,mBAAmB,EAAE,mBAAmB,mBAAmB,EAAE,yBAAyB,mBAAmB,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAxF;AACE;AACM;AACR;AAEC;AAO5D;IAAyC,uCAAQ;IAK/C,6BAAoB,EAAe;QAAnC,YACE,kBAAM,eAAe,CAAC,SACvB;QAFmB,QAAE,GAAF,EAAE,CAAa;QAHnC,sBAAgB,GAAG,CAAC,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;QAC/F,gBAAU,GAAG,IAAI,6EAAkB,EAAE,CAAC;;IAItC,CAAC;IAED,sCAAQ,GAAR;QACE,IAAI,CAAC,SAAS,EAAE,CAAC;QACjB,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED,uCAAS,GAAT;QAAA,iBAKC;QAJC,UAAU,CAAC;YACT,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,GAAG,EAAE,CAAC;YAC5C,KAAI,CAAC,UAAU,CAAC,SAAS,GAAG,KAAI,CAAC,SAAS,CAAC;QAC7C,CAAC,EAAE,CAAC,CAAC,CAAC;IACR,CAAC;IAED,2CAAa,GAAb;QAAA,iBAaC;QAZC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,SAAS,CAAC,UAAC,GAAgB;YACpD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YAEjB,GAAG,CAAC,OAAO,CAAC,UAAC,EAAE,EAAE,CAAC;gBAChB,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAClB,EAAE,CAAC,MAAM,CAAC,GAAG,2FAAc,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;gBACxC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;oBACtC,EAAE,CAAC,eAAe,CAAC,GAAG,UAAU,CAAC;gBACnC,qEAAqE;YACvE,CAAC,CAAC,CAAC;YACH,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,GAAG,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mDAAqB,GAArB,UAAsB,MAAc;QAClC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC;IArCwB;QAAxB,0EAAS,CAAC,uEAAY,CAAC;kCAAY,uEAAY;0DAAC;IADtC,mBAAmB;QAL/B,wEAAS,CAAC;YACT,QAAQ,EAAE,iBAAiB;;;SAG5B,CAAC;yCAMwB,qFAAW;OALxB,mBAAmB,CAwC/B;IAAD,0BAAC;CAAA,CAxCwC,oFAAQ,GAwChD;AAxC+B;;;;;;;;ACZhC,uTAAuT,sBAAsB,qLAAqL,WAAW,6JAA6J,MAAM,weAAwe,cAAc,6/BAA6/B,kBAAkB,8IAA8I,yBAAyB,0UAA0U,kBAAkB,gaAAga,sBAAsB,8IAA8I,yBAAyB,0VAA0V,sBAAsB,sS;;;;;;;ACAroH,2CAA2C,8BAA8B,6CAA6C,qCAAqC,EAAE,eAAe,eAAe,cAAc,EAAE,kBAAkB,eAAe,iBAAiB,EAAE,sBAAsB,oBAAoB,uBAAuB,EAAE,uBAAuB,iBAAiB,EAAE,yBAAyB,qBAAqB,EAAE,6BAA6B,oBAAoB,uBAAuB,EAAE,oBAAoB,wBAAwB,EAAE,mBAAmB,kBAAkB,gBAAgB,0BAA0B,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA1iB;AACE;AACD;AACK;AACrB;AACyD;AACtC;AACxB;AACsB;AACN;AACJ;AACU;AACC;AAEd;AAOhD;IAAwC,sCAAQ;IAmB9C,4BAAoB,EAAe,EAAU,EAAiB,EACpD,MAAiB,EAAU,EAAgB,EAC3C,MAAc,EAAU,EAAe;QAFjD,YAGE,kBAAM,OAAO,CAAC,SAIf;QAPmB,QAAE,GAAF,EAAE,CAAa;QAAU,QAAE,GAAF,EAAE,CAAe;QACpD,YAAM,GAAN,MAAM,CAAW;QAAU,QAAE,GAAF,EAAE,CAAc;QAC3C,YAAM,GAAN,MAAM,CAAQ;QAAU,QAAE,GAAF,EAAE,CAAa;QAhBjD,aAAO,GAAG,CAAC,CAAC;QACZ,UAAI,GAAG,CAAC,CAAC;QACT,aAAO,GAAG,EAAE,CAAC;QACb,eAAS,GAAG,UAAU,CAAC;QACvB,sBAAgB,GAAG,KAAK,CAAC;QAEzB,qBAAe,GAAG,uFAAW,CAAC;QAC9B,iBAAW,GAAgB,uFAAW,CAAC,QAAQ,CAAC;QAEhD,gBAAU,GAAe,EAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,CAAC;QACpD,cAAQ,GAAe,EAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC,CAAC;QAC9C,cAAQ,GAAe,EAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,CAAC;QAClD,sBAAgB,GAAe,EAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC,CAAC;QAMpD,KAAI,CAAC,SAAS,GAAG,4EAAW,CAAC,MAAM,GAAG,iBAAiB,CAAC;QACxD,KAAI,CAAC,UAAU,GAAG,4EAAW,CAAC,MAAM,GAAG,kBAAkB,CAAC;QAC1D,KAAI,CAAC,SAAS,GAAG,4EAAW,CAAC,MAAM,GAAG,iBAAiB,CAAC;;IAC1D,CAAC;IAED,qCAAQ,GAAR;QAAA,iBAYC;QAXC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,uFAAW,CAAC,QAAQ,CAAC,CAAC;QAEhD,UAAU,CAAC;YACT,KAAI,CAAC,eAAe,EAAE,CAAC;YACvB,KAAI,CAAC,qBAAqB,EAAE,CAAC;YAC7B,KAAI,CAAC,cAAc,EAAE,CAAC;YACtB,KAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,KAAI,CAAC,SAAS,EAAE,CAAC;YACjB,KAAI,CAAC,eAAe,EAAE,CAAC;YACvB,KAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,kDAAqB,GAArB;QAAA,iBAUC;QATC,IAAI,CAAC,EAAE,CAAC,YAAY,EAAE,CAAC;QACvB,IAAI,CAAC,EAAE,CAAC,eAAe,EAAE,CAAC;QAC1B,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,SAAS,CAAC,aAAG;YAClC,KAAI,CAAC,EAAE,CAAC,aAAa,CAAC,KAAI,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,aAAG;YACjC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YACjB,KAAI,CAAC,OAAO,GAAG,GAAG,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAe,GAAf;QAAA,iBAaC;QAZC,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,cAAI;YAClC,yCAAyC;YACzC,EAAE,CAAC,CAAC,KAAI,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC;YACT,CAAC;YAED,KAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,KAAI,CAAC,EAAE,CAAC,aAAa,CAAC,KAAI,CAAC,OAAO,CAAC,CAAC;YAEpC,EAAE,CAAC,CAAC,KAAI,CAAC,OAAO,KAAK,GAAG,CAAC;gBACvB,KAAI,CAAC,eAAe,EAAE,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,6CAAgB,GAAhB;QAAA,iBAcC;QAbC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,SAAS,CAAC,YAAE;YAC/B,KAAI,CAAC,WAAW,GAAG,EAAE,CAAC;YAEtB,EAAE,CAAC,CAAC,KAAI,CAAC,WAAW,KAAK,uFAAW,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC1C,oDAAoD;gBACpD,oDAAoD;gBACpD,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBAEhC,uDAAuD;gBACvD,uDAAuD;gBACvD,KAAI,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACnC,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,2CAAc,GAAd;QAAA,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,WAAC;YAC5B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC;YACf,KAAI,CAAC,SAAS,GAAG,wFAAc,CAAC,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,sCAAS,GAAT;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,WAAC;YAC5B,KAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAe,GAAf;QAAA,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,eAAK;YACjC,KAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,KAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,YAAE,IAAI,YAAI,CAAC,YAAY,CAAC,EAAE,CAAC,EAArB,CAAqB,CAAC,CAAC;QACpE,CAAC,CAAC,CAAC;IACL,CAAC;IAED,0CAAa,GAAb;QAAA,iBAoBC;QAnBC,IAAI,CAAC,EAAE,CAAC,eAAe,CAAC,SAAS,CAAC,0BAAgB;YAChD,KAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;YAEzC,EAAE,CAAC,CAAC,CAAC,gBAAgB,CAAC;gBACpB,MAAM,CAAC;YAET,EAAE,CAAC,CAAC,KAAI,CAAC,WAAW,KAAK,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC;gBACnD,MAAM,CAAC;YAET,EAAE,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;gBACjC,MAAM,CAAC;YAET,KAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6HAAsB,EAAE;gBACvC,IAAI,EAAE;oBACJ,KAAK,EAAE,+EAAU,CAAC,gBAAgB;iBACnC;aACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAID,4CAAe,GAAf,UAAgB,KAAK;QACnB,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACpC,CAAC;IAED,mDAAsB,GAAtB,UAAuB,KAAK;QAC1B,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;YACjD,MAAM,CAAC;QACT,CAAC;QAED,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAChC,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QACrD,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;IAED,6CAAgB,GAAhB,UAAiB,KAAK,EAAE,KAAK;QAA7B,iBAKC;QAJC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,KAAK,EAAE,CAAC,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,KAAK,SAAC,EAAE,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC5G,KAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;YAC/B,KAAI,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,yCAAY,GAAZ,UAAa,KAAK;QAChB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,iFAAO,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACrF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,iFAAO,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5E,CAAC;IAED,gDAAmB,GAAnB,UAAoB,KAAK;QAAzB,iBAKC;QAJC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QACnC,UAAU,CAAC;YACT,KAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACnC,CAAC,EAAE,GAAG,CAAC,CAAC;IACV,CAAC;IAID,6CAAgB,GAAhB;QAAA,iBAwBC;QAvBC,IAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,KAAK,uFAAW,CAAC,MAAM,CAAC;QAEzD,2CAA2C;QAC3C,+CAA+C;QAC/C,cAAc;QACd,2CAA2C;QAC3C,QAAQ;QACR,QAAQ;QACR,YAAY;QACZ,IAAI;QAEJ,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;YAC3E,8CAA8C;YAC9C,8CAA8C;YAC9C,uEAAuE;YACvE,sEAAsE;YACtE,uEAAuE;YACvE,4EAA4E;YAC5E,EAAE,CAAC,CAAC,QAAQ,CAAC;gBACX,KAAI,CAAC,WAAW,GAAG,uFAAW,CAAC,QAAQ,CAAC;YAC1C,IAAI;gBACF,KAAI,CAAC,WAAW,GAAG,uFAAW,CAAC,MAAM,CAAC;QAC1C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,sCAAS,GAAT;QAAA,iBAYC;QAXC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6HAAsB,EAAE;YACvC,IAAI,EAAE;gBACJ,KAAK,EAAE,+EAAU,CAAC,gBAAgB;aACnC;SACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;YAC5B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YAEjB,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,MAAM,EAAE,MAAM,EAAC,CAAC,CAAC,SAAS,CAAC,cAAI;gBACpD,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YAClC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAID,4CAAe,GAAf;QAAA,iBAaC;QAZC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YACjC,MAAM,CAAC;QAET,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6HAAsB,EAAE;YACvC,IAAI,EAAE;gBACJ,KAAK,EAAE,+EAAU,CAAC,cAAc;gBAChC,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,IAAI,EAAE,IAAI,CAAC,SAAS;aACrB;SACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;YAC5B,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,wCAAW,GAAX;QACE,IAAI,CAAC,EAAE,CAAC,aAAa,GAAG,KAAK,CAAC;IAChC,CAAC;IAhOU,kBAAkB;QAL9B,wEAAS,CAAC;YACT,QAAQ,EAAE,gBAAgB;;;SAG3B,CAAC;yCAoBwB,qFAAW,EAAc,yFAAa;YAC5C,oEAAS,EAAc,uFAAY;YACnC,+DAAM,EAAc,sFAAW;OArBtC,kBAAkB,CAiO9B;IAAD,yBAAC;CAAA,CAjOuC,oFAAQ,GAiO/C;AAjO8B;;;;;;;;ACrB/B,04BAA04B,owCAAowC,6SAA6S,kTAAkT,mZAAmZ,8DAA8D,sWAAsW,uTAAuT,oeAAoe,iVAAiV,iVAAiV,iVAAiV,6VAA6V,wVAAwV,wWAAwW,sfAAsf,oWAAoW,4eAA4e,4VAA4V,yVAAyV,oVAAoV,+eAA+e,4VAA4V,+SAA+S,gJ;;;;;;;ACAxxT,yBAAyB,iBAAiB,uBAAuB,uBAAuB,mBAAmB,EAAE,iBAAiB,0CAA0C,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA1H;AACY;AACM;AACL;AAEY;AACkB;AAC/C;AACyD;AAC9C;AAOvD;IAAuC,qCAAQ;IAK7C,2BAAoB,EAAe,EAAS,GAAsB,EACxD,MAAiB;QAD3B,YAEE,kBAAM,UAAU,CAAC,SAClB;QAHmB,QAAE,GAAF,EAAE,CAAa;QAAS,SAAG,GAAH,GAAG,CAAmB;QACxD,YAAM,GAAN,MAAM,CAAW;QAH3B,gBAAU,GAAG,KAAK,CAAC;;IAKnB,CAAC;IAED,oCAAQ,GAAR;QAAA,iBAIC;QAHC,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,SAAS,CAAC,gBAAM,IAAI,YAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAChF,CAAC;IAED,kDAAsB,GAAtB;QAAA,iBAQC;QAPC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,UAAC,GAAoB;YACrD,KAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC;YAC7B,KAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,YAAE;gBACzB,KAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;YACnD,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oCAAQ,GAAR;QACE,IAAI,CAAC,YAAY,GAAG,IAAI,mEAAW,EAAE,CAAC,KAAK,CAAC;YAC1C,MAAM,EAAE,CAAC,KAAK,CAAC;YACf,MAAM,EAAE,CAAC,EAAC,KAAK,EAAE,KAAK,EAAC,CAAC;YACxB,GAAG,EAAE,CAAC,KAAK,CAAC;YACZ,SAAS,EAAE,CAAC,KAAK,CAAC;YAClB,QAAQ,EAAE,CAAC,KAAK,CAAC;YACjB,GAAG,EAAE,CAAC,KAAK,CAAC;YACZ,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACjC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAClC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACrC,WAAW,EAAE,CAAC,cAAc,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACpD,QAAQ,EAAE,CAAC,MAAM,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACzC,eAAe,EAAE,CAAC,EAAE,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC5C,cAAc,EAAE,CAAC,EAAE,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC3C,cAAc,EAAE,CAAC,GAAG,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC5C,cAAc,EAAE,CAAC,EAAE,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC3C,cAAc,EAAE,CAAC,GAAG,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC5C,kBAAkB,EAAE,CAAC,IAAI,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACjD,oBAAoB,EAAE,CAAC,EAAE,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACjD,2BAA2B,EAAE,CAAC,IAAI,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC1D,kBAAkB,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC9C,yBAAyB,EAAE,CAAC,IAAI,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACxD,cAAc,EAAE,CAAC,EAAE,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC3C,qBAAqB,EAAE,CAAC,IAAI,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YACpD,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC5C,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAC5C,oBAAoB,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;YAChD,oBAAoB,EAAE,CAAC,CAAC,EAAE,CAAC,kEAAU,CAAC,QAAQ,CAAC,CAAC;SACjD,CAAC,CAAC;IACL,CAAC;IAED,wCAAY,GAAZ,UAAa,MAAa;QAA1B,iBAYC;QAZY,sCAAa;QACxB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC;gBAC3D,CAAC,CAAC,CAAC,CAAC,GAAG,KAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBAC3C,MAAM,CAAC,CAAC,CAAC;YACX,CAAC,EAAE,EAAE,CAAC,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC;YAC1B,MAAM,CAAC;QACT,IAAI,CAAC,UAAU,GAAG,MAAM;aACrB,IAAI,CAAC,MAAM,CAAC;aACZ,IAAI,CAAC,YAAE,IAAI,aAAM,CAAC,EAAE,CAAC,KAAK,KAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,EAAzC,CAAyC,CAAC,CAAC;IAC3D,CAAC;IAED,kCAAM,GAAN;QAAA,iBA+BC;QA9BC,IAAM,aAAa,GAAG,EAAE,CAAC;QACzB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,YAAE;YAC5C,IAAM,aAAa,GAAG,KAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;YACjD,IAAM,SAAS,GAAG,KAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;YACvD,EAAE,CAAC,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;gBAChC,aAAa,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC;YAChC,CAAC;QACH,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC,SAAS,CAAC,cAAI;YACpD,IAAI,YAAY,GAAG,KAAK,EAAE,YAAY,GAAG,KAAK,CAAC;YAC/C,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,YAAE;gBACnC,oBAAoB;gBACpB,KAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;gBAE/C,qCAAqC;gBACrC,YAAY,GAAG,YAAY,IAAI,oGAAa,CAAC,IAAI,CAAC,aAAG,IAAI,UAAG,KAAK,EAAE,EAAV,CAAU,CAAC,CAAC;gBACrE,YAAY,GAAG,YAAY,IAAI,oGAAa,CAAC,IAAI,CAAC,aAAG,IAAI,UAAG,KAAK,EAAE,EAAV,CAAU,CAAC,CAAC;YACvE,CAAC,CAAC,CAAC;YACH,KAAI,CAAC,YAAY,EAAE,CAAC;YAEpB,wCAAwC;YACxC,EAAE,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,YAAY,CAAC;gBACjC,MAAM,CAAC;YACT,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6HAAsB,EAAE;gBACvC,IAAI,EAAE;oBACJ,KAAK,EAAE,+EAAU,CAAC,aAAa;oBAC/B,YAAY,gBAAE,YAAY;iBAC3B;aACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAvGU,iBAAiB;QAL7B,wEAAS,CAAC;YACT,QAAQ,EAAE,cAAc;;;SAGzB,CAAC;yCAMwB,qFAAW,EAAc,iGAAiB;YAChD,oEAAS;OANhB,iBAAiB,CAwG7B;IAAD,wBAAC;CAAA,CAxGsC,oFAAQ,GAwG9C;AAxG6B;;;;;;;;AChB9B,mCAAmC,2BAA2B,2BAA2B,oBAAoB,mCAAmC,oCAAoC,qCAAqC,qCAAqC,yBAAyB,aAAa,gBAAgB,cAAc,eAAe,gCAAgC,gCAAgC,gCAAgC,gCAAgC,KAAK,uBAAuB,sBAAsB,iBAAiB,KAAK,4BAA4B,0BAA0B,sBAAsB,sBAAsB,KAAK,mCAAmC,0BAA0B,6BAA6B,6BAA6B,KAAK,kBAAkB,uBAAuB,sBAAsB,KAAK,yBAAyB,4BAA4B,uBAAuB,KAAK,0BAA0B,uBAAuB,oBAAoB,KAAK,yBAAyB,yBAAyB,KAAK,6BAA6B,mBAAmB,KAAK,0BAA0B,yBAAyB,mBAAmB,kBAAkB,KAAK,2BAA2B,yBAAyB,mBAAmB,kBAAkB,KAAK,sBAAsB,oCAAoC,KAAK,yBAAyB,6BAA6B,4BAA4B,mBAAmB,8BAA8B,KAAK,oCAAoC,oBAAoB,yBAAyB,KAAK,wBAAwB,0BAA0B,KAAK,sBAAsB,oBAAoB,kBAAkB,4BAA4B,KAAK,qBAAqB,yBAAyB,KAAK,wBAAwB,oBAAoB,KAAK,2BAA2B,mBAAmB,mBAAmB,KAAK,wBAAwB,yBAAyB,KAAK,K;;;;;;;ACAn5D,8PAA8P,6uBAA6uB,UAAU,gkBAAgkB,MAAM,+/DAA+/D,2BAA2B,oGAAoG,2BAA2B,oGAAoG,0BAA0B,oGAAoG,0BAA0B,y1BAAy1B,0RAA0R,yEAAyE,qOAAqO,8GAA8G,2EAA2E,uIAAuI,2MAA2M,yEAAyE,8gK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAh3L;AACrB;AACJ;AACa;AACN;AACqB;AAClC;AACP;AACoB;AACN;AACwC;AAC9C;AACU;AACF;AACH;AAGO;AACd;AACmB;AAOxE;IAAmC,iCAAQ;IAyCzC,uBAAmB,EAAiB,EAAU,EAAe,EACnD,EAAe,EAAS,GAAsB,EAC9C,EAAiB,EAAU,EAAgB,EAC3C,MAAc,EAAU,EAAc,EACtC,cAA8B,EAAU,EAAkB,EAC1D,MAAiB;QAL3B,YAME,kBAAM,WAAW,CAAC,SAGnB;QATkB,QAAE,GAAF,EAAE,CAAe;QAAU,QAAE,GAAF,EAAE,CAAa;QACnD,QAAE,GAAF,EAAE,CAAa;QAAS,SAAG,GAAH,GAAG,CAAmB;QAC9C,QAAE,GAAF,EAAE,CAAe;QAAU,QAAE,GAAF,EAAE,CAAc;QAC3C,YAAM,GAAN,MAAM,CAAQ;QAAU,QAAE,GAAF,EAAE,CAAY;QACtC,oBAAc,GAAd,cAAc,CAAgB;QAAU,QAAE,GAAF,EAAE,CAAgB;QAC1D,YAAM,GAAN,MAAM,CAAW;QAvC3B,gBAAgB;QAChB,kBAAY,GAAG,2FAAkB,CAAC;QAElC,kBAAY,GAAG,EAAE,CAAC;QAElB,6BAA6B;QAC7B,sBAAgB,GAAG,IAAI,CAAC;QACxB,gBAAU,GAAG,GAAG,CAAC;QAEjB,iBAAiB;QACjB,eAAS,GAAG,KAAK,CAAC;QAClB,kBAAY,GAAG,EAAE,CAAC;QAClB,WAAK,GAAwB;YAC3B,GAAG,EAAE,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC;YACtB,GAAG,EAAE,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC;YACtB,IAAI,EAAE,EAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAC;SACxB,CAAC;QACF,eAAS,GAAG;YACV,GAAG,EAAE;gBACH,KAAK,EAAE,SAAS;gBAChB,KAAK,EAAE,CAAC;aACT;YACD,GAAG,EAAE;gBACH,KAAK,EAAE,SAAS;gBAChB,KAAK,EAAE,CAAC;aACT;YACD,IAAI,EAAE;gBACJ,KAAK,EAAE,SAAS;gBAChB,KAAK,EAAE,CAAC;aACT;SACF,CAAC;QACF,oBAAc,GAAG,EAAC,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,CAAC;QAChD,yBAAmB,GAAG,IAAI,CAAC;QASzB,KAAI,CAAC,YAAY,GAAG,KAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QACpC,KAAI,CAAC,aAAa,EAAE,CAAC;;IACvB,CAAC;IAED,gCAAQ,GAAR;QACE,oEAAoE;QACpE,oEAAoE;QACpE,oEAAoE;QACpE,oEAAoE;QACpE,6CAA6C;QAL/C,iBASC;QADC,UAAU,CAAC,cAAM,YAAI,CAAC,aAAa,EAAE,EAApB,CAAoB,CAAC,CAAC;IACzC,CAAC;IAED,qCAAa,GAAb;QACE,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE9B,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC9B,CAAC;IAED,qCAAa,GAAb;QAAA,iBAaC;QAZC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,eAAK;YAChC,EAAE,CAAC,CAAC,KAAK,YAAY,sEAAa,CAAC;gBACjC,MAAM,CAAC;YAET,KAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAC9B,IAAM,kBAAkB,GAAG,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAE,IAAI,SAAE,KAAK,KAAK,CAAC,KAAK,CAAC,EAAnB,CAAmB,CAAC,CAAC,CAAC,CAAC;YACzD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBAC9B,KAAI,CAAC,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,yCAAiB,GAAjB;QAAA,iBAOC;QANC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,SAAS,CAAC,cAAI;YACtC,EAAE,CAAC,CAAC,IAAI,CAAC;gBACP,UAAU,CAAC,cAAM,YAAI,CAAC,EAAE,CAAC,KAAK,EAAE,EAAf,CAAe,CAAC,CAAC;YACpC,IAAI;gBACF,UAAU,CAAC,cAAM,YAAI,CAAC,EAAE,CAAC,IAAI,EAAE,EAAd,CAAc,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,0CAAkB,GAAlB;QAAA,iBAIC;QAHC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,aAAG;YAC1B,KAAI,CAAC,gBAAgB,GAAG,GAAG,CAAC;QAC9B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,6CAAqB,GAArB;QAAA,iBAuCC;QAtCC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,SAAS,CAAC,uBAAa;YAC1C,EAAE,CAAC,CAAC,aAAa,KAAK,IAAI,CAAC;gBACzB,MAAM,CAAC;YAET,KAAI,CAAC,mBAAmB,GAAG,CAAC,aAAa,CAAC;YAE1C,IAAI,MAAkB,CAAC;YACvB,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;gBAClB,KAAI,CAAC,YAAY,GAAG,4FAAmB,CAAC;gBACxC,MAAM,GAAG,gFAAU,CAAC,mBAAmB,CAAC;gBACxC,KAAI,CAAC,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC;YAC/B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,YAAY,GAAG,2FAAkB,CAAC;gBACvC,MAAM,GAAG,gFAAU,CAAC,cAAc,CAAC;YACrC,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,GAAG,CAAC,YAAE,IAAI,SAAE,CAAC,OAAO,CAAC,EAAX,CAAW,CAAC,CAAC,QAAQ,CAAC,KAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxE,KAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,EAAE,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;oBACjC,MAAM,CAAC;gBAET,EAAE,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,GAAG,KAAK,aAAa,IAAI,KAAI,CAAC,EAAE,CAAC,aAAa,CAAC;oBAC7D,MAAM,CAAC;gBAET,yDAAyD;gBACzD,EAAE,CAAC,CAAC,MAAM,KAAK,gFAAU,CAAC,cAAc,CAAC;oBACvC,MAAM,CAAC;gBAET,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8HAAsB,EAAE;oBACvC,IAAI,EAAE;wBACJ,KAAK,EAAE,MAAM;qBACd;iBACF,CAAC,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,aAAG;oBAC5B,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACnD,KAAI,CAAC,UAAU,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC9C,CAAC,CAAC,CAAC;YACL,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,8CAAsB,GAAtB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,cAAI;YAClC,KAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAC3B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,2CAAmB,GAAnB;QAAA,iBAOC;QANC,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,SAAS,CAAC,cAAI;YACnC,KAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;QAC/B,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,aAAG;YAC/B,KAAI,CAAC,UAAU,GAAG,GAAG,CAAC;QACxB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,qCAAa,GAAb;QACE,IAAM,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QAC9D,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,WAAC;YAC5B,EAAE,CAAC,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC;QAC3B,CAAC,CAAC,CAAC;QACH,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;IAChD,CAAC;IAED,sCAAc,GAAd;QACE,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACnD,CAAC;IAED,sCAAc,GAAd;QACE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;IACtB,CAAC;IAED,yCAAiB,GAAjB;QACE,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;IACzB,CAAC;IAED,8BAAM,GAAN,UAAO,MAAM;QACX,EAAE,CAAC,CAAC,MAAM,CAAC;YAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;QAClC,IAAI;YAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QAE5B,6DAA6D;QAC7D,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YACpE,EAAE,CAAC,CAAC,MAAM,CAAC;gBAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;YAClC,IAAI;gBAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QAC5B,CAAC;QAED,4CAA4C;QAC5C,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;YAClC,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC5B,CAAC;IAED,kCAAU,GAAV,UAAW,IAAI,EAAE,MAAa;QAAb,sCAAa;QAC5B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YAAC,MAAM,CAAC;QAClB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACX,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YACvB,CAAC;QACH,CAAC;IACH,CAAC;IAED,wCAAgB,GAAhB;QACE,IAAI,CAAC,EAAE,CAAC,YAAY,EAAE,CAAC;QAEvB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtD,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC3B,CAAC;IAED,4BAA4B;IAC5B,8CAAsB,GAAtB;QAAA,iBASC;QARC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,aAAG;YAC1B,KAAI,CAAC,KAAK,GAAG,GAAG,CAAC;QACnB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,aAAG;YAC5B,EAAE,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC;gBAAC,MAAM,CAAC;YACzB,KAAI,CAAC,SAAS,GAAG,GAAG,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,uCAAe,GAAf,UAAgB,MAAe;QAA/B,iBAEC;QADC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,cAAM,YAAI,CAAC,SAAS,GAAG,MAAM,EAAvB,CAAuB,CAAC,CAAC;IACnE,CAAC;IAED,kCAAU,GAAV,UAAW,KAAK,EAAE,IAAI;QACpB,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IAC5C,CAAC;IAED,yCAAiB,GAAjB;QAAA,iBAIC;QAHC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,YAAE;YACvB,KAAI,CAAC,uBAAuB,CAAC,KAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;IACL,CAAC;IAED,+CAAuB,GAAvB,UAAwB,KAAK,EAAE,IAAI;QACjC,EAAE,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC;QACtC,IAAI;YACF,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC;IAC3C,CAAC;IAED,kCAAU,GAAV,UAAW,IAAI;QACb,IAAI,SAAS,CAAC;QACd,EAAE,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC;YACnB,SAAS,GAAG;gBACV,KAAK,EAAE,KAAK;gBACZ,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM;gBAC5D,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK;aAChC,CAAC;QACJ,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC;YAC1B,SAAS,GAAG;gBACV,KAAK,EAAE,QAAQ;gBACf,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM;gBAC5D,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK;gBAC/B,OAAO,EAAE,CAAC;aACX,CAAC;QACJ,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;YAC3B,SAAS,GAAG;gBACV,KAAK,EAAE,QAAQ;gBACf,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM;gBAC7D,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK;gBAChC,OAAO,EAAE,CAAC;aACX;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC;QACT,CAAC;QAED,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,SAAS,CAAC,aAAG;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,gCAAQ,GAAR;QACE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,iGAAa,EAAE;YAC9B,KAAK,EAAE,OAAO;SACf,CAAC,CAAC;IACL,CAAC;IAED,qCAAa,GAAb;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC,SAAS,CAAC,aAAG;YAC7C,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,8EAAO,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAW,GAAX,UAAY,IAAc;QAA1B,iBAQC;QAPC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC;QAClC,IAAI,CAAC;YACH,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAE,IAAI,SAAE,CAAC,KAAK,KAAK,KAAI,CAAC,MAAM,CAAC,GAAG,EAA5B,CAA4B,CAAC,CAAC,KAAK,CAAC,CAAC;QACpF,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,OAAO,CAAC,KAAK,CAAC,8CAA8C,CAAC,CAAC;YAC9D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAGD,gCAAQ,GAAR,UAAS,KAAK,EAAE,KAAM,EAAE,MAAO;QACvB,6FAA6F,EAA5F,SAAC,EAAE,SAAC,CAAyF;QACpG,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YACrC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC5B,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YACtC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAE7B,8EAA8E;QAE9E,+CAA+C;QAC/C,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC;YAC1B,MAAM,CAAC;QAET,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC5B,CAAC;IAED,0CAAkB,GAAlB;QACE,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC;YAC1B,MAAM,CAAC;QAET,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QACrB,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACtB,qBAAqB;QACrB,yBAAyB;QACzB,0BAA0B;QAC1B,WAAW;IACb,CAAC;IAED,4CAAoB,GAApB;QAAA,iBAOC;QANC,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,SAAS,CAAC,aAAG;YACpC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC;YAEjB,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;gBACd,KAAI,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC;QAC9C,CAAC,CAAC,CAAC;IACL,CAAC;IAhVqB;QAArB,0EAAS,CAAC,SAAS,CAAC;kCAAU,qEAAU;kDAAC;IACnB;QAAtB,0EAAS,CAAC,UAAU,CAAC;kCAAW,qEAAU;mDAAC;IACtB;QAArB,0EAAS,CAAC,SAAS,CAAC;kCAAU,oEAAS;kDAAC;IACb;QAA3B,0EAAS,CAAC,eAAe,CAAC;kCAAgB,iEAAU;wDAAC;IAC3C;QAAV,oEAAO,EAAE;;6CAAe;IAySzB;QADC,2EAAY,CAAC,eAAe,EAAE,CAAC,QAAQ,CAAC,CAAC;;;;iDAezC;IA5TU,aAAa;QALzB,wEAAS,CAAC;YACT,QAAQ,EAAE,UAAU;;;SAGrB,CAAC;yCA0CuB,sFAAa,EAAc,kFAAW;YAC/C,qFAAW,EAAc,iGAAiB;YAC1C,0FAAa,EAAc,wFAAY;YACnC,+DAAM,EAAc,iEAAU;YACtB,2FAAc,EAAc,4FAAc;YAClD,oEAAS;OA9ChB,aAAa,CAkVzB;IAAD,oBAAC;CAAA,CAlVkC,qFAAQ,GAkV1C;AAlVyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1Ba;AACI;AACE;AACE;AAsBpB;AACwD;AAC3B;AACqB;AACb;AACV;AACwC;AACF;AACrC;AAC2C;AAC9C;AACiB;AACL;AACJ;AAClB;AAC2B;AACM;AAC0B;AAG7B;AACR;AACA;AACG;AACmB;AACd;AA+DxE;IAAA;IACA,CAAC;IADY,UAAU;QA7DtB,uEAAQ,CAAC;YACR,OAAO,EAAE;gBACP,qGAAuB;gBACvB,gFAAa;gBACb,mEAAW;gBACX,2EAAmB;gBACnB,kEAAW;gBACX,qEAAY;gBACZ,8EAAgB;gBAChB,2EAAgB;gBAChB,wEAAa;gBACb,0EAAe;gBACf,yEAAc;gBACd,2EAAgB;gBAChB,wEAAa;gBACb,wEAAa;gBACb,0EAAe;gBACf,+EAAoB;gBACpB,6EAAkB;gBAClB,gFAAkB;gBAClB,6EAAkB;gBAClB,wEAAa;gBACb,0EAAe;gBACf,qFAAc,CAAC,OAAO,EAAE;gBACxB,yEAAc;gBACd,6EAAkB;gBAClB,2EAAgB;gBAChB,mEAAa,CAAC,OAAO,EAAE;gBACvB,yFAAoB,CAAC,OAAO,EAAE;gBAC9B,uBAAuB;gBACvB,0EAAe;gBACf,4EAAiB;gBACjB,0EAAe;gBACf,+EAAoB;aACrB;YACD,YAAY,EAAE;gBACZ,sEAAa;gBACb,yGAAiB;gBACjB,qHAAoB;gBACpB,qHAAmB;gBACnB,2HAAqB;gBACrB,8FAAY;gBACZ,4EAAa;gBACb,wFAAiB;gBACjB,6FAAkB;gBAClB,8HAAsB;gBACtB,gGAAmB;gBACnB,wFAAiB;gBACjB,wFAAiB;gBACjB,2FAAkB;gBAClB,+GAAiB;gBACjB,iGAAa;aACd;YACD,eAAe,EAAE;gBACf,8HAAsB;gBACtB,iGAAa;aACd;YACD,SAAS,EAAE,EAEV;SACF,CAAC;OACW,UAAU,CACtB;IAAD,iBAAC;CAAA;AADsB;;;;;;;;;ACjHvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AACO;AACb;AACK;AAC8C;AAClC;AACK;AACG;AACR;AACA;AACG;AAEnE,IAAM,WAAW,GAAW;IAC1B;QACE,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,sEAAa,EAAE,QAAQ,EAAE;YAC5C,EAAC,IAAI,EAAE,EAAE,EAAE,UAAU,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAC;YAEjD,yEAAyE;YACzE,wEAAwE;YACxE,uEAAuE;YACvE,EAAC,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,2EAAa,EAAC;YACxC,EAAC,IAAI,EAAE,YAAY,EAAE,SAAS,EAAE,4FAAkB,EAAC;YAEnD,EAAC,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,0HAAqB,EAAC;YAClD,EAAC,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,uFAAiB,EAAC;YAC/C,EAAC,IAAI,EAAE,aAAa,EAAE,SAAS,EAAE,uFAAiB,EAAC;YACnD,EAAC,IAAI,EAAE,aAAa,EAAE,SAAS,EAAE,+FAAmB,EAAC;YACrD,EAAC,IAAI,EAAE,WAAW,EAAE,SAAS,EAAE,2FAAkB,EAAC;YAClD,EAAC,IAAI,EAAE,UAAU,EAAE,SAAS,EAAE,uFAAiB,EAAC;SAEjD;KACF;CACF,CAAC;AAEK,IAAM,WAAW,GAAG,qEAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;AACvD,IAAM,eAAe,GAAG,oFAAmB,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;;;;;;;;ACnC3E,ifAAif,cAAc,6LAA6L,ynBAAynB,WAAW,ggBAAggB,2BAA2B,ytB;;;;;;;ACA31D,0CAA0C,oBAAoB,cAAc,gBAAgB,YAAY,eAAe,EAAE,oBAAoB,gBAAgB,iBAAiB,oBAAoB,qBAAqB,EAAE,mBAAmB,mBAAmB,EAAE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAtM;AACC;AACC;AACV;AACgB;AACA;AACd;AACY;AAOjE;IAAwC,sCAAQ;IAW9C,4BAAoB,EAAe,EAAU,EAAkB,EACtD,EAAiB;QAD1B,YAEE,kBAAM,WAAW,CAAC,SAEnB;QAJmB,QAAE,GAAF,EAAE,CAAa;QAAU,QAAE,GAAF,EAAE,CAAgB;QACtD,QAAE,GAAF,EAAE,CAAe;QAR1B,gBAAU,GAAG,EAAE,CAAC;QAChB,uBAAiB,GAAG,EAAE,CAAC;QAEvB,sBAAgB,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,qCAAqC;QAC5E,gBAAU,GAAG,IAAI,6EAAkB,EAAE,CAAC;QACtC,uBAAiB,GAAG,EAAE,CAAC;QAKrB,KAAI,CAAC,QAAQ,GAAG,2EAAW,CAAC,MAAM,GAAG,gBAAgB,CAAC;;IACxD,CAAC;IAED,qCAAQ,GAAR;QACE,IAAI,CAAC,SAAS,EAAE,CAAC;QACjB,IAAI,CAAC,aAAa,EAAE,CAAC;QACrB,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC;IAED,sCAAS,GAAT;QAAA,iBAMC;QALC,UAAU,CAAC;YACT,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,EAAE,CAAC;YAC1B,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,GAAG,EAAE,CAAC;YAC5C,KAAI,CAAC,UAAU,CAAC,SAAS,GAAG,KAAI,CAAC,SAAS,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,0CAAa,GAAb;QAAA,iBAQC;QAPC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,EAAC,EAAE,EAAE,EAAE,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;YAC/C,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3E,KAAI,CAAC,UAAU,GAAG,EAAE,CAAC;YACvB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC;YAC7B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAe,GAAf,UAAgB,GAAG;QACjB,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC;IAC/B,CAAC;IAED,6CAAgB,GAAhB;QAAA,iBAIC;QAHC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,SAAS,CAAC,aAAG;YACxC,KAAI,CAAC,UAAU,CAAC,IAAI,GAAG,KAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;IACL,CAAC;IAED,4CAAe,GAAf;QAAA,iBAcC;QAbC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE;YACxB,OAAO,EAAE,IAAI,CAAC,iBAAiB;YAC/B,OAAO,EAAE,IAAI,CAAC,iBAAiB;SAChC,EAAE;YACC,IAAI,EAAE,IAAI;YACV,WAAW,EAAE,EAAE;YACf,UAAU,EAAE,IAAI;SACjB,CAAC,CAAC,SAAS,CAAC,aAAG;YACd,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,6EAAO,CAAC,IAAI,CAAC,CAAC;YAC3B,KAAI,CAAC,QAAQ,EAAE,CAAC;QAClB,CAAC,EAAE,aAAG;YACJ,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,6EAAO,CAAC,KAAK,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;IACP,CAAC;IAED,4CAAe,GAAf,UAAgB,MAAM,EAAE,IAAI;QAA5B,iBAMC;QALC,MAAM,CAAC,eAAe,EAAE,CAAC;QACzB,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,WAAW,EAAE,EAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC,CAAC,SAAS,CAAC,aAAG;YAC1D,KAAI,CAAC,EAAE,CAAC,IAAI,CAAC,6EAAO,CAAC,IAAI,CAAC,CAAC;YAC3B,KAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,0CAAa,GAArB,UAAsB,IAAI;QACxB,IAAM,GAAG,GAAG,EAAE;QACd,IAAI,CAAC,OAAO,CAAC,YAAE;YACb,GAAG,CAAC,IAAI,CAAC;gBACP,MAAM,EAAE,EAAE;aACX,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,qCAAQ,GAAR;QACE,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAC5B,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;IAC9B,CAAC;IAED,4CAAe,GAAf,UAAgB,IAAI;QAClB,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,IAAI,CAAC;IACrC,CAAC;IAED,uCAAU,GAAV,UAAW,GAAG;QACZ,MAAM,CAAC,IAAI,CAAC,iBAAiB,KAAK,GAAG,CAAC,IAAI,CAAC;IAC7C,CAAC;IAED,sDAAyB,GAAzB;QACE,MAAM,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAC9D,CAAC;IApGwB;QAAxB,0EAAS,CAAC,uEAAY,CAAC;kCAAY,uEAAY;yDAAC;IADtC,kBAAkB;QAL9B,wEAAS,CAAC;YACT,QAAQ,EAAE,eAAe;;;SAG1B,CAAC;yCAYwB,qFAAW,EAAc,2FAAc;YAClD,yFAAa;OAZf,kBAAkB,CAsG9B;IAAD,yBAAC;CAAA,CAtGuC,oFAAQ,GAsG/C;AAtG8B;;;;;;;;;ACd/B;AAAA,mFAAmF;AACnF,8FAA8F;AAC9F,yEAAyE;AACzE,gFAAgF;AAEzE,IAAM,WAAW,GAAG;IACzB,UAAU,EAAE,KAAK;CAClB,CAAC;;;;;;;;;ACPF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AAC4B;AAE9B;AACY;AAErC;AAElB,EAAE,CAAC,CAAC,8EAAW,CAAC,UAAU,CAAC,CAAC,CAAC;IAC3B,+EAAc,EAAE,CAAC;AACnB,CAAC;AAED,yGAAsB,EAAE,CAAC,eAAe,CAAC,kEAAS,CAAC,CAAC","file":"main.bundle.js","sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncatched exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./src/$$_lazy_route_resource lazy recursive\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/$$_lazy_route_resource lazy\n// module id = ./src/$$_lazy_route_resource lazy recursive\n// module chunks = main","module.exports = \"\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/app.component.css\n// module id = ./src/app/app.component.css\n// module chunks = main","module.exports = \"<div class=\\\"whole-app\\\" [ngClass]=\\\"{'theme1': isTheme1, 'theme2': !isTheme1}\\\">\\r\\n  <!-- <button mat-button (click)=toggle()>toggle</button> -->\\r\\n  <router-outlet></router-outlet>\\r\\n</div>\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/app.component.html\n// module id = ./src/app/app.component.html\n// module chunks = main","import {Component, OnInit, ViewContainerRef} from '@angular/core';\r\nimport {MatIconRegistry} from '@angular/material';\r\nimport {SocketService} from './shared/services/socket.service';\r\nimport {DataService} from './shared/services/data.service';\r\nimport {ThemesEnum} from './shared/enum/themes.enum';\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.css']\r\n})\r\nexport class AppComponent implements OnInit {\r\n  isTheme1 = true;\r\n\r\n  constructor(private iconRegistry: MatIconRegistry, private vcs: ViewContainerRef, private ds: DataService) {\r\n    // this.iconRegistry.addSvgIcon('custom-mat-icon-label', 'url-of-svg-file-using-dom-sanitizer');\r\n    // usage: <mat-icon svgIcon=\"custom-mat-icon-label></mat-icon>\"\r\n    this.vcs.element.nativeElement.parentElement.classList.add(ThemesEnum.default);\r\n    this.ds.usedTheme$.subscribe(theme => {\r\n      for (const th in ThemesEnum) {\r\n        if (ThemesEnum.hasOwnProperty(th)) {\r\n          this.vcs.element.nativeElement.parentElement.classList.remove(th);\r\n        }\r\n      }\r\n      this.vcs.element.nativeElement.parentElement.classList.add(theme);\r\n    });\r\n  }\r\n\r\n  ngOnInit() {\r\n\r\n  }\r\n\r\n  toggle() {\r\n    this.isTheme1 = !this.isTheme1;\r\n    // WORKS!!!!!!!!!!!!!!!!!!!!!!!!!\r\n    // GENERALIZE THEMEING THING!!!!! -> certain components won't work (e.g. menu)\r\n    // -> do this trick:\r\n    //  set a default theme that uses general things\r\n    //  then anyone wants to add new theme, they're added in a class\r\n    //  and for those certain components, always the default theme applies!\r\n    //  (test overlayContainer to see if it's extensible to these)\r\n    // THINK ABOUT PAGES -> Standalone / tablet / mobile\r\n    // THINK ABOUT Multi-language -> words / directions / fonts / styles ...\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/app.component.ts","import {BrowserModule} from '@angular/platform-browser';\r\nimport {NgModule} from '@angular/core';\r\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\r\n\r\nimport {AppComponent} from './app.component';\r\nimport {MatButtonModule, MatIconModule, MatProgressBarModule} from '@angular/material';\r\nimport {FlexLayoutModule} from '@angular/flex-layout';\r\nimport {SiteModule} from './site/site.module';\r\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\r\nimport {WindowService} from './shared/services/window.service';\r\nimport {HttpService} from './shared/services/http.service';\r\nimport {SocketService} from './shared/services/socket.service';\r\nimport {HttpClientModule} from '@angular/common/http';\r\nimport {ProgressService} from './shared/services/progress.service';\r\nimport {AppRouting} from './app.routing';\r\nimport {DataService} from './shared/services/data.service';\r\nimport {TranslatorService} from './shared/services/translator.service';\r\nimport {OverlayContainer} from '@angular/cdk/overlay';\r\nimport {SpinnerService} from './shared/services/spinner.service';\r\nimport {MessageService} from './shared/services/message.service';\r\nimport {ViewerService} from './shared/services/viewer.service';\r\nimport {PrintService} from './shared/services/print.service';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n  ],\r\n  imports: [\r\n    BrowserAnimationsModule,\r\n    BrowserModule,\r\n    SiteModule,\r\n    HttpClientModule,\r\n    FormsModule,\r\n    ReactiveFormsModule,\r\n    AppRouting,\r\n    FlexLayoutModule,\r\n    MatButtonModule,\r\n    MatIconModule,\r\n    MatProgressBarModule,\r\n  ],\r\n  providers: [\r\n    WindowService,\r\n    HttpService,\r\n    SocketService,\r\n    ProgressService,\r\n    DataService,\r\n    TranslatorService,\r\n    SpinnerService,\r\n    MessageService,\r\n    ViewerService,\r\n    PrintService,\r\n  ],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule {\r\n  constructor(overlayContainer: OverlayContainer) {\r\n    overlayContainer.getContainerElement().classList.add('theme1');\r\n    overlayContainer.getContainerElement().classList.add('theme2');\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/app.module.ts","import {Routes, RouterModule} from '@angular/router';\r\nimport {AppComponent} from './app.component';\r\n\r\nconst APP_ROUTES: Routes = [\r\n  {\r\n    path: '', component: AppComponent,\r\n    // children: []\r\n  },\r\n];\r\n\r\nexport const AppRouting = RouterModule.forRoot(APP_ROUTES);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/app.routing.ts","/**\r\n * An abstract class name that indicates the base\r\n * properties that each page needs.\r\n * So, all the pages should be extended from this\r\n */\r\n\r\nexport class PageBase {\r\n  title;\r\n\r\n  constructor(title) {\r\n    this.title = title;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/classes/page-base.class.ts","import {TranslatorService} from \"../services/translator.service\";\r\n\r\nconst SETTINGS_TOOLTIPS = {\r\n  view3d: 'Whether to show 3D model of the selected gcode or not. Assume high CPU consumption',\r\n};\r\n\r\nexport class Tooltip {\r\n  /**\r\n   * @param trl provide a Translator Service class to this\r\n   * then make an instance in your component and use that\r\n   * anywhere in HTML with these given functionalities!\r\n   */\r\n  constructor(private trl: TranslatorService) {\r\n  }\r\n\r\n  get(key) {\r\n    return SETTINGS_TOOLTIPS.hasOwnProperty(key) && this.trl.lookup(SETTINGS_TOOLTIPS[key]) || '';\r\n  }\r\n\r\n  class() {\r\n    return 'font-' + this.trl.lang$.getValue();\r\n  }\r\n\r\n  pos() {\r\n    return 'above';\r\n  }\r\n\r\n  delay() {\r\n    return 20;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/classes/tooltip.class.ts","module.exports = \"<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Select Camera:'\\\"></ptrl>\\n</h4>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" *ngFor=\\\"let cam of cameraList\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple (click)=\\\"changeCameraTo(cam.link)\\\" class=\\\"card-base\\\" [class.active-item]=\\\"selectedItem.link === cam.link\\\">\\n      <mat-card-header class=\\\"card-name-header\\\">\\n        <mat-card-title>\\n          <ptrl [text]=\\\"cam.name\\\"></ptrl>\\n        </mat-card-title>\\n      </mat-card-header>\\n      <img mat-card-image [src]=\\\"host + cam.icon\\\">\\n    </mat-card>\\n  </div>\\n</div>\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n<div *ngIf=\\\"isFeeding\\\" class=\\\"viewer-wrapper\\\">\\n  <img *ngIf=\\\"isFeeding\\\" [src]=\\\"cameraLink\\\" alt=\\\"\\\" width=\\\"100%\\\" height=\\\"100%\\\">\\n</div>\\n<br><br><br>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/camera-viewer/camera-viewer.component.html\n// module id = ./src/app/shared/components/camera-viewer/camera-viewer.component.html\n// module chunks = main","module.exports = \".viewer-wrapper {\\n  border: 2px dashed rebeccapurple;\\n  width: 90%;\\n  left: 5%;\\n  position: relative; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/camera-viewer/camera-viewer.component.scss\n// module id = ./src/app/shared/components/camera-viewer/camera-viewer.component.scss\n// module chunks = main","import {Component, OnInit, OnDestroy} from '@angular/core';\nimport {DataService} from 'app/shared/services/data.service';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {PageBase} from 'app/shared/classes/page-base.class';\n\n@Component({\n  selector: 'app-camera-viewer',\n  templateUrl: './camera-viewer.component.html',\n  styleUrls: ['./camera-viewer.component.scss']\n})\nexport class CameraViewerComponent extends PageBase implements OnInit {\n\n  cameraLink = '';\n  host = '';\n  cameraList = [];\n  isFeeding = false;\n  selectedItem = {name: '', link: '', icon: ''};\n\n  constructor(private dataService: DataService, private hs: HttpService) {\n    super(\"Camera\");\n  }\n\n  ngOnInit() {\n    this.getCameraList();\n\n    if (!this.dataService.ipList.length) {\n      this.dataService.updateIpList().then(() => {\n        this.updateHostAndLink(this.dataService.ipList[0]);\n      }).catch(() => {});\n    } else {\n      this.updateHostAndLink(this.dataService.ipList[0]);\n    }\n  }\n\n  updateHostAndLink(ip) {\n    this.host = `http://${ip}`;\n    this.cameraLink = this.buildCameraLink();\n  }\n\n  getCameraList() {\n    this.hs.get('camera-list').subscribe(data => {\n      this.cameraList = data['cameras'];\n    });\n  }\n\n  changeCameraTo(link) {\n    this.clearSelectedItem();\n    this.isFeeding = false;\n    this.hs.post('camera-set', {cam: link}).subscribe(res => {\n      this.isFeeding = true;\n      this.selectedItem = this.cameraList.find(el => el.link === link);\n    });\n  }\n\n  clearSelectedItem() {\n    this.selectedItem = {\n      name: '', link: '', icon: ''\n    };\n  }\n\n  buildCameraLink() {\n    return `${this.host}/api/camera-feed`;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/camera-viewer/camera-viewer.component.ts","module.exports = \"<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\" class=\\\"form-item\\\">\\n  <div [fxFlex]=\\\"title\\\" class=\\\"form-title\\\" [matTooltip]=\\\"tt.get(name)\\\" [matTooltipPosition]=\\\"tt.pos()\\\"\\n    [matTooltipClass]=\\\"tt.class()\\\" [matTooltipHideDelay]=\\\"tt.delay()\\\">\\n    <ng-content select=\\\"[title]\\\"></ng-content>\\n  </div>\\n  <div [fxFlex]=\\\"control\\\">\\n    <ng-content select=\\\"[control]\\\"></ng-content>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/form-item/form-item.component.html\n// module id = ./src/app/shared/components/form-item/form-item.component.html\n// module chunks = main","module.exports = \".form-title {\\n  cursor: help; }\\n\\n.form-item {\\n  text-align: center;\\n  margin-bottom: 8px;\\n  padding: 8px 0;\\n  height: 50px; }\\n\\n.form-item:hover {\\n  background: rgba(255, 255, 255, 0.04); }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/form-item/form-item.component.scss\n// module id = ./src/app/shared/components/form-item/form-item.component.scss\n// module chunks = main","import {Component, OnInit, Input} from '@angular/core';\nimport {FormGroup} from '@angular/forms';\nimport {Tooltip} from 'app/shared/classes/tooltip.class';\nimport {TranslatorService} from 'app/shared/services/translator.service';\n\n@Component({\n  selector: 'app-form-item',\n  templateUrl: './form-item.component.html',\n  styleUrls: ['./form-item.component.scss']\n})\nexport class FormItemComponent implements OnInit {\n  @Input() name;\n  @Input() title = 60;\n  @Input() control = 40;\n  @Input() form: FormGroup;\n  tt: Tooltip;\n\n  constructor(private trl: TranslatorService) {\n    this.tt = new Tooltip(this.trl);\n  }\n\n  ngOnInit() {\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/form-item/form-item.component.ts","module.exports = \"<!-- <p> -->\\n<!-- gcode-viewer works! -->\\n<!-- </p> -->\\n<div #container id=\\\"container\\\" [ngStyle]=\\\"{\\n    'width': Constants.width + 'px',\\n    'height': Constants.height + 'px'\\n  }\\\"></div>\\n<!-- <input matInput type=\\\"number\\\" placeholder=\\\"X\\\" value=\\\"100\\\" [(ngModel)]=\\\"camera?.position.x\\\"> -->\\n<!-- <input matInput type=\\\"number\\\"  placeholder=\\\"Y\\\" value=\\\"100\\\" [(ngModel)]=\\\"camera?.position.y\\\"> -->\\n<!-- <input matInput type=\\\"number\\\"  placeholder=\\\"Z\\\" value=\\\"100\\\" [(ngModel)]=\\\"camera?.position.z\\\"> -->\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/gcode-viewer/gcode-viewer.component.html\n// module id = ./src/app/shared/components/gcode-viewer/gcode-viewer.component.html\n// module chunks = main","module.exports = \"\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/gcode-viewer/gcode-viewer.component.scss\n// module id = ./src/app/shared/components/gcode-viewer/gcode-viewer.component.scss\n// module chunks = main","import {Component, OnInit, ViewChild, ElementRef, Renderer2, Input, ChangeDetectionStrategy} from '@angular/core';\nimport * as $ from 'jquery/dist/jquery.min';\nimport * as THREE from '../../lib/gcode/three';\nwindow['$'] = $;\nwindow['THREE'] = THREE;\nimport * as Constants from '../../lib/gcode/constants';\nwindow['Constants'] = Constants;\n\n/**\n * These codes are heavily based on: https://github.com/jherrm/gcode-viewer\n * But some changes have been made to the code for customization of this project\n*/\nimport '../../lib/gcode/TrackballControls';\nimport '../../lib/gcode/js/ShaderExtras';\nimport '../../lib/gcode/js/postprocessing/EffectComposer';\nimport '../../lib/gcode/js/postprocessing/MaskPass';\nimport '../../lib/gcode/js/postprocessing/RenderPass';\nimport '../../lib/gcode/js/postprocessing/ShaderPass';\nimport '../../lib/gcode/js/postprocessing/BloomPass';\n\nimport {\n  FileIO,\n  GCodeImporter,\n} from '../../lib/gcode/gimporter';\nimport {\n  GCodeModel,\n  GCode,\n  GWord,\n  GCodeParser,\n} from '../../lib/gcode/gparser';\nimport {\n  GCodeViewModel,\n  GCodeRenderer,\n} from '../../lib/gcode/grenderer';\nimport {SpinnerService} from 'app/shared/services/spinner.service';\nimport {DataService} from 'app/shared/services/data.service';\n\n@Component({\n  selector: 'app-gcode-viewer',\n  templateUrl: './gcode-viewer.component.html',\n  styleUrls: ['./gcode-viewer.component.scss'],\n})\nexport class GcodeViewerComponent implements OnInit {\n  width = Constants.width;\n  height = Constants.height;\n  isRotating = true;\n\n  @ViewChild('container', {}) container: ElementRef;\n  @Input()\n  set model(value) {\n    if (!value)\n      return;\n    this.addModel(value);\n  }\n\n  @Input()\n  set percent(value) { // 0 - 100\n    if (!value)\n      return;\n\n    if (this.gr) {\n      const idx = Math.floor(this.gr.viewModels.length * value / 100);\n      console.log(`(percent: ${value}, index: ${idx}, lines: ${this.gr.viewModels.length})`);\n      this.gr.setIndex(idx, true); // TODO: check functionality!\n    }\n  }\n\n\n  // accepts links like:\n  // 'http://192.168.1.3/api/download/files/part.gcode',\n  // 'http://192.168.1.3/api/download/usbs/SHB/part.gcode',\n\n  gr;\n  scene = null;\n  object = null;\n  effectFXAA;\n  camera;\n  controls;\n  renderer;\n  composer;\n  layerIndex = 0;\n  Constants;\n\n  constructor(private domRenderer: Renderer2, private ss: SpinnerService,\n    private ds: DataService) {\n  }\n\n  ngOnInit() {\n    this.Constants = window['Constants'];\n    setTimeout(() => {\n      this.createScene();\n      this.checkRotation();\n    }, 0);\n  }\n\n  checkRotation() {\n    this.ds.printerSettings$.subscribe(res => {\n      if (!res) return;\n\n      this.isRotating = res.rotate;\n    });\n  }\n\n  addModel(gcodeFile) {\n    const self = this;\n    this.ss.en(180);\n    try {\n      GCodeImporter.importPath(gcodeFile, gcode => {\n        const gp = new GCodeParser();\n        const parsedGcodes = gp.parse(gcode);\n        const changed = gp.centerizeGCodes(parsedGcodes);\n\n        self.gr = new GCodeRenderer();\n        const gcodeObj = self.gr.render(changed);\n        self.layerIndex = self.gr.viewModels.length - 1;\n        self.gr.setIndex(self.layerIndex - 2, false);\n\n        self.camera.position.z = 500;\n        self.camera.position.y = -1000;\n        self.camera.lookAt(self.gr.center);\n\n        if (self.object) {\n          self.scene.remove(self.object);\n        }\n\n        self.object = gcodeObj;\n        self.scene.add(this.object);\n        this.ss.dis();\n      });\n    } catch (e) {\n      this.ss.dis();\n      console.error(\"ERROR adding gcode model: \", e);\n    }\n  }\n\n  createScene() {\n    this.initSceneInfo();\n    this.animateScene();\n  }\n\n  initSceneInfo() {\n    this.scene = new THREE.Scene();\n    this.renderer = new THREE.WebGLRenderer({\n      clearColor: 0x000000,\n      clearAlpha: 1,\n      antialias: false\n    });\n    this.renderer.autoClear = false;\n    this.domRenderer.appendChild(this.container.nativeElement, this.renderer.domElement);\n\n    // camera things\n    const fov = 45,\n      aspect = this.width / this.height,\n      near = 1,\n      far = 10000;\n    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    this.camera.position.z = 300;\n    this.scene.add(this.camera);\n\n    this.controls = new THREE.TrackballControls(this.camera);\n    this.controls.dynamicDampingFactor = 0.1;\n    this.controls.rotateSpeed = 1.0;\n\n    const renderModel = new THREE.RenderPass(this.scene, this.camera);\n    const effectBloom = new THREE.BloomPass(0.4);\n    const effectScreen = new THREE.ShaderPass(THREE.ShaderExtras['screen']);\n    this.effectFXAA = new THREE.ShaderPass(THREE.ShaderExtras['fxaa']);\n    effectScreen.renderToScreen = true;\n\n    this.composer = new THREE.EffectComposer(this.renderer);\n    this.composer.addPass(renderModel);\n    this.composer.addPass(this.effectFXAA);\n    this.composer.addPass(effectBloom);\n    this.composer.addPass(effectScreen);\n\n    this.setContainerSize();\n\n    // handle resizing\n    // window.addEventListener('resize', () => {\n    // this.setContainerSize(window.innerWidth, window.innerHeight)\n    // this.setContainerSize();\n    // }, false);\n    window.addEventListener('keydown', (event) => {\n      if (event.keyCode == 32) { // toggle rotation on space\n        this.isRotating = !this.isRotating;\n      }\n    }, false);\n  }\n\n  animateScene() {\n    const self = this;\n    function animate() {\n      requestAnimationFrame(animate);\n      self.renderScene();\n    }\n\n    animate();\n  }\n\n  renderScene() {\n    if (this.isRotating) {\n      for (let i = 0; i < this.scene.children.length; i++) {\n        const object = this.scene.children[i];\n        if (object instanceof THREE.Object3D) {\n          object.rotation.z += 0.015;\n        }\n      }\n    }\n\n    // if (this.gr) {\n    //   try {\n    //     this.gr.setIndex(this.gr.index + 10);\n    //     this.layerIndex = this.gr.index;\n    //   } catch (e) {\n    //     this.gr.setIndex(this.gr.viewModels.length - 1);\n    //     this.layerIndex = this.gr.index;\n    //   }\n    // }\n\n    this.controls.update();\n    this.renderer.clear();\n    this.composer.render();\n  }\n\n  setContainerSize(width = this.width, height = this.height) {\n    this.camera.aspect = width / height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(width, height);\n    this.effectFXAA.uniforms['resolution'].value.set(\n      1 / width,\n      1 / height\n    );\n    this.controls.handleResize(width, height);\n    this.composer.reset();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/gcode-viewer/gcode-viewer.component.ts","module.exports = \"<div *ngIf=\\\"data.usage === usage.shouldGoToPrintPage\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Ongoing Print'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'There is already an ongoing printing'\\\"></ptrl>\\n    </div>\\n    <div>\\n      <ptrl [text]=\\\"'Redirecting to print page...'\\\"></ptrl>\\n    </div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.pageNotAllowed\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Inaccessible Page'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Accessing this page is not allowed'\\\"></ptrl>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.confirmPrint\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Confirm Print'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <p>\\n      <ptrl [text]=\\\"'Are you sure you want to print this file?'\\\"></ptrl>\\n    </p>\\n    <p>\\n      <span>{{data && data.name || 'ERR'}}</span>\\n    </p>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.confirmStopPrint\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Confirm Stop'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Are you sure you want to stop printing?'\\\"></ptrl>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.confirmDelete\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Confirm Delete'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Are you sure you want to delete this file?'\\\"></ptrl>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.printCompleted\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Print Completed'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'Specifications'\\\"></ptrl>\\n    </div>\\n    <div>\\n      <ptrl [text]=\\\"'File Name'\\\"></ptrl>\\n    </div>\\n    <div class=\\\"dialog-completion-filename\\\">{{data.fileDir}}</div>\\n    <div>\\n      <ptrl [text]=\\\"'Time'\\\"></ptrl>\\n    </div>\\n    <div>{{data.time}}</div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.askForUnfinishedPrint\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Unfinished Print'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <p>\\n      <ptrl [text]=\\\"'You have an unfinished print. Would you like to continue?'\\\"></ptrl>\\n    </p>\\n    <p>\\n      <span>{{data && data.cd || 'ERR'}}</span>\\n    </p>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"false\\\" class=\\\"button\\\">\\n      <mat-icon>clear</mat-icon>\\n    </button>\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.afterSettings\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Action Needed'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'Changes take effect after:'\\\"></ptrl>\\n    </div>\\n    <div *ngIf=\\\"data.needsRefresh\\\">\\n      <a href=\\\"settings\\\" (click)=\\\"reloadPage()\\\">\\n        <ptrl [text]=\\\"'- Refreshing Page'\\\"></ptrl>\\n      </a>\\n    </div>\\n    <div *ngIf=\\\"data.needsRestart\\\">\\n      <ptrl [text]=\\\"'- Restarting Device'\\\"></ptrl>\\n    </div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.filamentFinished\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Filament Finished'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'Please change filament and then resume'\\\"></ptrl>\\n    </div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.needPreheating\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Low Temperature'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'You need to heat extruder to at least 180 before extruding'\\\"></ptrl>\\n    </div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\\n<div *ngIf=\\\"data.usage === usage.needHoming\\\">\\n  <h3 mat-dialog-title class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Not Homed'\\\"></ptrl>\\n  </h3>\\n  <div mat-dialog-content class=\\\"centerize\\\">\\n    <div>\\n      <ptrl [text]=\\\"'You must home before you can move'\\\"></ptrl>\\n    </div>\\n  </div>\\n  <div mat-dialog-actions class=\\\"centerize\\\">\\n    <button mat-icon-button [mat-dialog-close]=\\\"true\\\" class=\\\"button\\\">\\n      <mat-icon>check</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/generic-dialog/generic-dialog.component.html\n// module id = ./src/app/shared/components/generic-dialog/generic-dialog.component.html\n// module chunks = main","module.exports = \".centerize {\\n  text-align: center;\\n  -webkit-box-pack: center;\\n      -ms-flex-pack: center;\\n          justify-content: center; }\\n\\n.button {\\n  margin-left: 20px;\\n  margin-right: 20px; }\\n\\n.dialog-completion-filename {\\n  min-width: 200px;\\n  max-width: 200px;\\n  overflow-wrap: break-word; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/generic-dialog/generic-dialog.component.scss\n// module id = ./src/app/shared/components/generic-dialog/generic-dialog.component.scss\n// module chunks = main","import {Component, OnInit, Inject} from '@angular/core';\nimport {MatDialogRef, MAT_DIALOG_DATA} from '@angular/material';\nimport {DialogType} from 'app/shared/enum/dialog.enum';\n\n@Component({\n  selector: 'app-generic-dialog',\n  templateUrl: './generic-dialog.component.html',\n  styleUrls: ['./generic-dialog.component.scss']\n})\nexport class GenericDialogComponent implements OnInit {\n  usage = DialogType;\n  immediatelyDisappearUsages = [this.usage.shouldGoToPrintPage];\n\n  constructor(public dialogRef: MatDialogRef<GenericDialogComponent>, @Inject(MAT_DIALOG_DATA) public data: any) {\n  }\n\n  ngOnInit() {\n    if (this.immediatelyDisappearUsages.includes(this.data.usage))\n      setTimeout(() => {\n        this.dialogRef.close(false);\n      }, 5000);\n  }\n\n  reloadPage() {\n    window.location.reload();\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/generic-dialog/generic-dialog.component.ts","module.exports = \"<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"40\\\" (click)=\\\"home('All')\\\">\\n    <h5 class=\\\"title\\\">\\n      <button mat-raised-button class=\\\"home-button-width\\\">\\n        <ptrl [text]=\\\"'Axis'\\\"></ptrl>\\n      </button>\\n    </h5>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"30\\\" class=\\\"centerize\\\" (click)=\\\"move('X', false)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>remove</mat-icon>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"home('X')\\\">\\n    <button mat-raised-button class=\\\"home-button-width\\\">\\n      <span class=\\\"font-en\\\">X</span>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"move('X', true)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>add</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n<br>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"30\\\" class=\\\"centerize\\\" (click)=\\\"move('Y', false)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>remove</mat-icon>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"home('Y')\\\">\\n    <button mat-raised-button class=\\\"home-button-width\\\">\\n      <span class=\\\"font-en\\\">Y</span>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"move('Y', true)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>add</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n<br>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"30\\\" class=\\\"centerize\\\" (click)=\\\"move('Z', false)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>remove</mat-icon>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"home('Z')\\\">\\n    <button mat-raised-button class=\\\"home-button-width\\\">\\n      <span class=\\\"font-en\\\">Z</span>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"30\\\" fxFlexOffset=\\\"5\\\" class=\\\"centerize\\\" (click)=\\\"move('Z', true)\\\">\\n    <button mat-icon-button [disabled]=\\\"!allowMove\\\">\\n      <mat-icon>add</mat-icon>\\n    </button>\\n  </div>\\n</div>\\n<br>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\" [dir]=\\\"trl.direction()\\\">\\n  <div fxFlex=\\\"45\\\" class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Accuracy'\\\"></ptrl>\\n  </div>\\n  <div fxFlex=\\\"45\\\" fxFlexOffset=\\\"10\\\" class=\\\"centerize\\\">\\n    <input matInput type=\\\"number\\\" [(ngModel)]=\\\"accuracy\\\" step=\\\"1\\\" min=\\\"0\\\" max=\\\"50\\\">\\n  </div>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<h5 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Handwheel'\\\"></ptrl>\\n</h5>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"45\\\" class=\\\"centerize\\\" (click)=\\\"handWheel(true)\\\">\\n    <button mat-raised-button class=\\\"home-button-width\\\">\\n      <ptrl [text]=\\\"'Set'\\\"></ptrl>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"45\\\" fxFlexOffset=\\\"10\\\" class=\\\"centerize\\\" (click)=\\\"handWheel(false)\\\">\\n    <button mat-raised-button class=\\\"home-button-width\\\">\\n      <ptrl [text]=\\\"'Remove'\\\"></ptrl>\\n    </button>\\n  </div>\\n</div>\\n<br>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\" [dir]=\\\"trl.direction()\\\">\\n  <div fxFlex=\\\"45\\\" class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Extruder'\\\"></ptrl>\\n  </div>\\n  <div fxFlex=\\\"45\\\" fxFlexOffset=\\\"10\\\" class=\\\"centerize\\\">\\n    <mat-select color=\\\"primary\\\" [(ngModel)]=\\\"ext_num\\\">\\n      <mat-option [value]=\\\"1\\\">1</mat-option>\\n      <mat-option *ngIf=\\\"extruders_number > 1\\\" [value]=\\\"2\\\">2</mat-option>\\n    </mat-select>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/move/move.component.html\n// module id = ./src/app/shared/components/move/move.component.html\n// module chunks = main","module.exports = \".home-button-width {\\n  min-width: 100%; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/move/move.component.scss\n// module id = ./src/app/shared/components/move/move.component.scss\n// module chunks = main","import {Component, OnInit, Inject} from '@angular/core';\nimport {MatDialogRef, MAT_DIALOG_DATA} from '@angular/material';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {MessageService} from 'app/shared/services/message.service';\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\nimport {Axis} from 'app/shared/classes/axis.interface';\nimport {DataService} from 'app/shared/services/data.service';\nimport {TranslatorService} from 'app/shared/services/translator.service';\n\n@Component({\n  selector: 'app-move',\n  templateUrl: './move.component.html',\n  styleUrls: ['./move.component.scss']\n})\nexport class MoveComponent implements OnInit {\n  allowMove = false;\n  moveValue = 20;\n  pos: Axis = {X: 0, Y: 0, Z: 0};\n  ext_num = 1;\n  extruders_number = 1;\n  accuracy = 1;\n\n  constructor(public dialogRef: MatDialogRef<MoveComponent>, @Inject(MAT_DIALOG_DATA) public data: any,\n    private hs: HttpService, private ms: MessageService, private ds: DataService,\n    public trl: TranslatorService) {\n  }\n\n  ngOnInit() {\n    this.checkHome();\n    this.checkExtrudersNumber();\n  }\n\n  checkExtrudersNumber() {\n    this.ds.printerSettings$.subscribe(res => {\n      this.extruders_number = res.extruders;\n    });\n  }\n\n  move(axis, isPos) {\n    // TODO: check for extruder number\n    const value = isPos ? this.accuracy : -this.accuracy;\n    this.hs.post('move_axis', {axis, value}).subscribe(res => {\n      this.pos[axis] += value;\n    });\n  }\n\n  checkHome() {\n    this.hs.options('move_axis').subscribe(res => {\n      if (res['access'])\n        this.allowMove = true;\n      else\n        this.allowMove = false;\n    });\n  }\n\n  home(axis) { // 'X' | 'Y' | 'Z' | 'All'\n    this.hs.post('home', {axis}).subscribe(res => {\n      this.ms.open(MsgType.info);\n      this.checkHome();\n    });\n  }\n\n  handWheel(isSet) {\n    // TODO: not needed yet\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/move/move.component.ts","module.exports = \"\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/progress/progress.component.css\n// module id = ./src/app/shared/components/progress/progress.component.css\n// module chunks = main","module.exports = \"<section>\\n  <mat-progress-bar\\n    *ngIf=\\\"showProgressing\\\"\\n    [color]=\\\"color\\\"\\n    [mode]=\\\"mode\\\"\\n    [value]=\\\"value\\\"\\n    [bufferValue]=\\\"bufferValue\\\">\\n  </mat-progress-bar>\\n</section>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/progress/progress.component.html\n// module id = ./src/app/shared/components/progress/progress.component.html\n// module chunks = main","import {Component, OnInit} from '@angular/core';\nimport {ProgressService} from '../../services/progress.service';\n\n@Component({\n  selector: 'app-progress',\n  templateUrl: './progress.component.html',\n  styleUrls: ['./progress.component.css']\n})\nexport class ProgressComponent implements OnInit {\n\n  // only works with one module! (current: site module)\n  // if needs to be on several modules, we need a separate progress.module.ts!\n  // but it is assumed that we can use it in one module without problem :)\n\n  showProgressing = false;\n  color: any = 'primary';\n  mode: any;\n  value: any;\n  bufferValue: any;\n\n  constructor(private progressService: ProgressService) {\n  }\n\n  ngOnInit() {\n    this.progressService.showProgress.subscribe(\n      (data) => this.showProgressing = data,\n      (err) => {\n        this.showProgressing = false;\n        console.error('An error occurred when subscribing on showProgress in progressService: ', err);\n      }\n    );\n\n    this.progressService.progressMode.subscribe(\n      (data) => this.mode = data,\n      (err) => {\n        this.mode = null;\n        console.error('An error occurred when subscribing on progressMode in progressService: ', err);\n      }\n    );\n\n    this.progressService.progressValue.subscribe(\n      (data) => this.value = data,\n      (err) => {\n        this.value = null;\n        console.error('An error occurred when subscribing on progressValue in progressService: ', err);\n      }\n    );\n\n    this.progressService.progressBufferValue.subscribe(\n      (data) => this.bufferValue = data,\n      (err) => {\n        this.bufferValue = null;\n        console.error('An error occurred when subscribing on progressBufferValue in progressService: ', err);\n      }\n    );\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/progress/progress.component.ts","module.exports = \"<span [ngClass]=\\\"'font-' + (lang || 'en')\\\">{{translatedWord}}</span>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/trl/trl.component.html\n// module id = ./src/app/shared/components/trl/trl.component.html\n// module chunks = main","module.exports = \"\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/trl/trl.component.scss\n// module id = ./src/app/shared/components/trl/trl.component.scss\n// module chunks = main","import {Component, OnInit, Input} from '@angular/core';\nimport {TranslatorService} from 'app/shared/services/translator.service';\n\n@Component({\n  selector: 'ptrl', // The unique universal selector of translation component (abbr. printer translator)\n  templateUrl: './trl.component.html',\n  styleUrls: ['./trl.component.scss']\n})\nexport class TrlComponent implements OnInit {\n  @Input()\n  set text(value) {\n    this._text = value;\n    this.updateWord();\n  }\n\n  _text = '';\n  translatedWord = this._text;\n  lang = '';\n\n  constructor(private trlService: TranslatorService) {}\n\n  ngOnInit() {\n    this.trlService.lang$.subscribe(lng => {\n      this.lang = lng;\n      this.updateWord();\n    });\n  }\n\n  updateWord() {\n    // uppercase / lowercase ?\n    if (this.trlService.dict.hasOwnProperty(this._text)) {\n      this.translatedWord = this.trlService.dict[this._text];\n    } else {\n      this.translatedWord = this._text;\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/trl/trl.component.ts","module.exports = \"<div fxLayout=\\\"row\\\" class=\\\"upload-wrapper\\\">\\n  <mat-form-field tdFileDrop [disabled]=\\\"disabled\\\" (fileDrop)=\\\"files = $event\\\" (click)=\\\"fileInput.inputElement.click()\\\"\\n    (keyup.enter)=\\\"fileInput.inputElement.click()\\\" (keyup.delete)=\\\"fileInput.clear()\\\" (keyup.backspace)=\\\"fileInput.clear()\\\"\\n    flex>\\n    <!-- Generic for multiple files is:\\n    [value]=\\\"files?.length ? (files?.length + ' files') : files?.name\\\" -->\\n    <input matInput placeholder=\\\"select or drop files\\\"\\n    [value]=\\\"files && files['name'] || ''\\\"\\n      [disabled]=\\\"disabled\\\" readonly />\\n  </mat-form-field>\\n  <button mat-icon-button *ngIf=\\\"files\\\" (click)=\\\"fileInput.clear()\\\" (keyup.enter)=\\\"fileInput.clear()\\\">\\n    <mat-icon>cancel</mat-icon>\\n  </button>\\n\\n  <td-file-input class=\\\"push-left-sm push-right-sm\\\" #fileInput [(ngModel)]=\\\"files\\\" [disabled]=\\\"disabled\\\" [multiple]=\\\"!single\\\"\\n    [hidden]=\\\"files\\\" accept=\\\".gcode\\\">\\n    <mat-icon>folder</mat-icon>\\n    <span class=\\\"text-upper\\\">\\n      <ptrl [text]=\\\"'Browse...'\\\"></ptrl>\\n    </span>\\n  </td-file-input>\\n\\n  <span *ngIf=\\\"files\\\">\\n    <button mat-raised-button color=\\\"accent\\\" class=\\\"text-upper\\\" (click)=\\\"submitFiles()\\\">\\n      <mat-icon>send</mat-icon>\\n      <ptrl [text]=\\\"'Submit'\\\"></ptrl>\\n    </button>\\n  </span>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/upload-file/upload-file.component.html\n// module id = ./src/app/shared/components/upload-file/upload-file.component.html\n// module chunks = main","module.exports = \".upload-wrapper {\\n  margin: 1em; }\\n\\n.drop-zone {\\n  font-weight: 600; }\\n\\n.drop-zone ::ng-deep * {\\n    pointer-events: none; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/components/upload-file/upload-file.component.scss\n// module id = ./src/app/shared/components/upload-file/upload-file.component.scss\n// module chunks = main","import {Component, OnInit, Input, Output, EventEmitter, ViewChild} from '@angular/core';\nimport {ProgressService} from 'app/shared/services/progress.service';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {TdFileInputComponent} from '@covalent/core/file';\nimport {SpinnerService} from 'app/shared/services/spinner.service';\n\n@Component({\n  selector: 'app-upload-file',\n  templateUrl: './upload-file.component.html',\n  styleUrls: ['./upload-file.component.scss']\n})\nexport class UploadFileComponent implements OnInit {\n  // TODO2: for now only works in single mode.\n  // if multi-mode was needed, this must change!\n  @Input() single = true;\n  @Input() url = 'upload-file';\n  @Output() onsubmit = new EventEmitter<any>();\n  @ViewChild('fileInput') fileInput: TdFileInputComponent;\n\n  files: File | FileList;\n  disabled = false;\n\n  constructor(private ps: ProgressService, private hs: HttpService,\n    private ss: SpinnerService) {\n  }\n\n  ngOnInit() {\n  }\n\n  submitFiles() {\n    this.ss.en(180);\n    this.hs.postFile(this.url, this.files, {spin: false, throwError: true}).subscribe(\n      res => {\n        this.ss.dis();\n        this.onsubmit.emit(true);\n        this.fileInput.clear();\n      },\n      err => {\n        this.ss.dis();\n        this.onsubmit.emit(false);\n      }\n    );\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/components/upload-file/upload-file.component.ts","import {NavLink} from \"../classes/navlink.interface\";\r\n\r\nexport const leftNavNormalItems: NavLink[] = [\r\n  {\r\n    label: 'Home',\r\n    route: '/home',\r\n    icon: 'home',\r\n  }, {\r\n    label: 'Camera',\r\n    route: '/camera',\r\n    icon: 'camera_alt',\r\n  }, {\r\n    label: 'Extrude',\r\n    route: '/extrude',\r\n    icon: 'flip_in_front',\r\n  }, {\r\n    label: 'Bedleveling',\r\n    route: '/bedleveling',\r\n    icon: 'settings_input_composite',\r\n  }, {\r\n    label: 'Recent Prints',\r\n    route: '/last-prints',\r\n    icon: 'watch_later',\r\n  }, {\r\n    label: 'Timelapse',\r\n    route: '/timelapse',\r\n    icon: 'timelapse',\r\n  }, {\r\n    label: 'Settings',\r\n    route: '/settings',\r\n    icon: 'settings_applications',\r\n  }\r\n];\r\n\r\nexport const leftNavOnPrintItems: NavLink[] = [\r\n  {\r\n    label: 'Print',\r\n    route: '/print-page',\r\n    icon: 'print',\r\n  }, {\r\n    label: 'Camera',\r\n    route: '/camera',\r\n    icon: 'camera_alt',\r\n  }, {\r\n    label: 'Settings',\r\n    route: '/settings',\r\n    icon: 'settings_input_composite',\r\n  }\r\n]\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/consts/leftnav.const.ts","export const NEEDS_REFRESH = [\r\n  'view3d',\r\n  // 'rotate',\r\n];\r\n\r\nexport const NEEDS_RESTART = [\r\n  'extruders',\r\n  'lcd',\r\n  'serial_port',\r\n  'baudrate',\r\n  // maybe all the other machine settings?\r\n  // should check for that!\r\n];\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/consts/settings-after-action.const.ts","export enum DialogType {\r\n  confirmDelete, //\r\n  confirmPrint, //\r\n  shouldGoToPrintPage, //\r\n  pageNotAllowed, //\r\n  printCompleted, //\r\n  filamentFinished, //\r\n  confirmStopPrint, //\r\n  askForUnfinishedPrint, //\r\n\r\n  needPreheating, //\r\n  needHoming, //\r\n  afterSettings, //\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/enum/dialog.enum.ts","export enum MsgType {\r\n  info = 'info',\r\n  error = 'error'\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/enum/msgtype.enum.ts","export enum PrintStatus {\r\n  idle = 0,\r\n  printing = 1,\r\n  paused = 2\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/enum/print-status.enum.ts","export enum ThemesEnum {\r\n  default = \"default\",\r\n  light = \"light\"\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/enum/themes.enum.ts","/**\r\n * @author Eberhard Graether / http://egraether.com/\r\n */\r\n\r\nTHREE.TrackballControls = function ( object, domElement ) {\r\n\r\n\tTHREE.EventTarget.call( this );\r\n\r\n\tvar _this = this;\r\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.screen = { width: 0, height: 0, offsetLeft: 0, offsetTop: 0 };\r\n\tthis.radius = ( this.screen.width + this.screen.height ) / 4;\r\n\r\n\tthis.rotateSpeed = 1.0;\r\n\tthis.zoomSpeed = 1.2;\r\n\tthis.panSpeed = 0.3;\r\n\r\n\tthis.noRotate = false;\r\n\tthis.noZoom = false;\r\n\tthis.noPan = false;\r\n\r\n\tthis.staticMoving = false;\r\n\tthis.dynamicDampingFactor = 0.2;\r\n\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\r\n\r\n\t// internals\r\n\r\n\tthis.target = new THREE.Vector3();\r\n\r\n\tvar lastPosition = new THREE.Vector3();\r\n\r\n\tvar _state = STATE.NONE,\r\n\t_prevState = STATE.NONE,\r\n\r\n\t_eye = new THREE.Vector3(),\r\n\r\n\t_rotateStart = new THREE.Vector3(),\r\n\t_rotateEnd = new THREE.Vector3(),\r\n\r\n\t_zoomStart = new THREE.Vector2(),\r\n\t_zoomEnd = new THREE.Vector2(),\r\n\r\n\t_panStart = new THREE.Vector2(),\r\n\t_panEnd = new THREE.Vector2();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\r\n\r\n\t// methods\r\n\r\n\tthis.handleResize = function (width, height) {\r\n\r\n\t\tthis.screen.width = width;\r\n\t\tthis.screen.height = height;\r\n\r\n\t\tthis.screen.offsetLeft = 0;\r\n\t\tthis.screen.offsetTop = 0;\r\n\r\n\t\tthis.radius = ( this.screen.width + this.screen.height ) / 4;\r\n\t};\r\n\r\n\tthis.handleEvent = function ( event ) {\r\n\r\n\t\tif ( typeof this[ event.type ] == 'function' ) {\r\n\r\n\t\t\tthis[ event.type ]( event );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getMouseOnScreen = function ( clientX, clientY ) {\r\n\r\n\t\treturn new THREE.Vector2(\r\n\t\t\t( clientX - _this.screen.offsetLeft ) / _this.radius * 0.5,\r\n\t\t\t( clientY - _this.screen.offsetTop ) / _this.radius * 0.5\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.getMouseProjectionOnBall = function ( clientX, clientY ) {\r\n\r\n\t\tvar mouseOnBall = new THREE.Vector3(\r\n\t\t\t( clientX - _this.screen.width * 0.5 - _this.screen.offsetLeft ) / _this.radius,\r\n\t\t\t( _this.screen.height * 0.5 + _this.screen.offsetTop - clientY ) / _this.radius,\r\n\t\t\t0.0\r\n\t\t);\r\n\r\n\t\tvar length = mouseOnBall.length();\r\n\r\n\t\tif ( length > 1.0 ) {\r\n\r\n\t\t\tmouseOnBall.normalize();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\r\n\r\n\t\t}\r\n\r\n\t\t_eye.copy( _this.object.position ).subSelf( _this.target );\r\n\r\n\t\tvar projection = _this.object.up.clone().setLength( mouseOnBall.y );\r\n\t\tprojection.addSelf( _this.object.up.clone().crossSelf( _eye ).setLength( mouseOnBall.x ) );\r\n\t\tprojection.addSelf( _eye.setLength( mouseOnBall.z ) );\r\n\r\n\t\treturn projection;\r\n\r\n\t};\r\n\r\n\tthis.rotateCamera = function () {\r\n\r\n\t\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\r\n\r\n\t\tif ( angle ) {\r\n\r\n\t\t\tvar axis = ( new THREE.Vector3() ).cross( _rotateStart, _rotateEnd ).normalize(),\r\n\t\t\t\tquaternion = new THREE.Quaternion();\r\n\r\n\t\t\tangle *= _this.rotateSpeed;\r\n\r\n\t\t\tquaternion.setFromAxisAngle( axis, -angle );\r\n\r\n\t\t\tquaternion.multiplyVector3( _eye );\r\n\t\t\tquaternion.multiplyVector3( _this.object.up );\r\n\r\n\t\t\tquaternion.multiplyVector3( _rotateEnd );\r\n\r\n\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t_rotateStart.copy( _rotateEnd );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\r\n\t\t\t\tquaternion.multiplyVector3( _rotateStart );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.zoomCamera = function () {\r\n\r\n\t\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\r\n\r\n\t\tif ( factor !== 1.0 && factor > 0.0 ) {\r\n\r\n\t\t\t_eye.multiplyScalar( factor );\r\n\r\n\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t_zoomStart.copy( _zoomEnd );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.panCamera = function () {\r\n\r\n\t\tvar mouseChange = _panEnd.clone().subSelf( _panStart );\r\n\r\n\t\tif ( mouseChange.lengthSq() ) {\r\n\r\n\t\t\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\r\n\r\n\t\t\tvar pan = _eye.clone().crossSelf( _this.object.up ).setLength( mouseChange.x );\r\n\t\t\tpan.addSelf( _this.object.up.clone().setLength( mouseChange.y ) );\r\n\r\n\t\t\t_this.object.position.addSelf( pan );\r\n\t\t\t_this.target.addSelf( pan );\r\n\r\n\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t_panStart = _panEnd;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_panStart.addSelf( mouseChange.sub( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.checkDistances = function () {\r\n\r\n\t\tif ( !_this.noZoom || !_this.noPan ) {\r\n\r\n\t\t\tif ( _this.object.position.lengthSq() > _this.maxDistance * _this.maxDistance ) {\r\n\r\n\t\t\t\t_this.object.position.setLength( _this.maxDistance );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\r\n\r\n\t\t\t\t_this.object.position.add( _this.target, _eye.setLength( _this.minDistance ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\t_eye.copy( _this.object.position ).subSelf( _this.target );\r\n\r\n\t\tif ( !_this.noRotate ) {\r\n\r\n\t\t\t_this.rotateCamera();\r\n\r\n\t\t}\r\n\r\n\t\tif ( !_this.noZoom ) {\r\n\r\n\t\t\t_this.zoomCamera();\r\n\r\n\t\t}\r\n\r\n\t\tif ( !_this.noPan ) {\r\n\r\n\t\t\t_this.panCamera();\r\n\r\n\t\t}\r\n\r\n\t\t_this.object.position.add( _this.target, _eye );\r\n\r\n\t\t_this.checkDistances();\r\n\r\n\t\t_this.object.lookAt( _this.target );\r\n\r\n\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {\r\n\r\n\t\t\t_this.dispatchEvent( changeEvent );\r\n\r\n\t\t\tlastPosition.copy( _this.object.position );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// listeners\r\n\r\n\tfunction keydown( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\twindow.removeEventListener( 'keydown', keydown );\r\n\r\n\t\t_prevState = _state;\r\n\r\n\t\tif ( _state !== STATE.NONE ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {\r\n\r\n\t\t\t_state = STATE.ROTATE;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {\r\n\r\n\t\t\t_state = STATE.ZOOM;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {\r\n\r\n\t\t\t_state = STATE.PAN;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction keyup( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\t_state = _prevState;\r\n\r\n\t\twindow.addEventListener( 'keydown', keydown, false );\r\n\r\n\t}\r\n\r\n\tfunction mousedown( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\t// event.preventDefault();\r\n\t\t// event.stopPropagation();\r\n\r\n\t\tif ( _state === STATE.NONE ) {\r\n\r\n\t\t\t_state = event.button;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\r\n\r\n\t\t\t_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\r\n\r\n\t\t\t_zoomStart = _zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\r\n\r\n\t\t\t_panStart = _panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\r\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\r\n\r\n\t}\r\n\r\n\tfunction mousemove( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\r\n\r\n\t\t\t_rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\r\n\r\n\t\t\t_zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\r\n\r\n\t\t\t_panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction mouseup( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\t// event.preventDefault();\r\n\t\t// event.stopPropagation();\r\n\r\n\t\t_state = STATE.NONE;\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\r\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\r\n\r\n\t}\r\n\r\n\tfunction mousewheel( event ) {\r\n\r\n\t\tif ( ! _this.enabled ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta / 120;\r\n\r\n\t\t} else if ( event.detail ) { // Firefox\r\n\r\n\t\t\tdelta = - event.detail / 3;\r\n\r\n\t\t}\r\n\r\n\t\t// _zoomStart.y += ( 1 / delta ) * 0.05;\r\n\t\t_zoomStart.y = delta * 0.05;\r\n\t\t_zoomEnd.y = 0;\r\n\r\n\t}\r\n\r\n\r\n\t// NOTE: uncomment this to enable rotating, etc. with the mouse\r\n\t// this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n\r\n\t// this.domElement.addEventListener( 'mousedown', mousedown, false );\r\n\t// this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false );\r\n\t// this.domElement.addEventListener( 'mousewheel', mousewheel, false );\r\n\r\n\t// window.addEventListener( 'keydown', keydown, false );\r\n\t// window.addEventListener( 'keyup', keyup, false );\r\n\r\n\tthis.handleResize(Constants.width, Constants.height);\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/TrackballControls.js\n// module id = ./src/app/shared/lib/gcode/TrackballControls.js\n// module chunks = main","function Constants() {\r\n}\r\n\r\n// the dimension and coefficient of render area\r\nConstants.width = 360;\r\nConstants.height = 360;\r\nConstants.dimensionCoef = 1.5;\r\n\r\n// the color(s) of hollowed\r\nConstants.motionColors = [\r\n  new THREE.Color(0xdddddd)\r\n];\r\n\r\n// the color(s) of the lines themselves\r\nConstants.feedColors = [\r\n  // new THREE.Color(0xffcc66), // canteloupe // yellow\r\n  new THREE.Color(0x66ccff), // sky        // blue\r\n  // new THREE.Color(0x22bb22), // honeydew   // green\r\n  // new THREE.Color(0x00ff00),\r\n  // new THREE.Color(0xff70cf), // carnation  // pink\r\n  // new THREE.Color(0xcc66ff), // lavender   // purple\r\n  // new THREE.Color(0xfffe66), // banana     // yellow - light\r\n  // new THREE.Color(0xff6666), // salmon      // red\r\n  // new THREE.Color(0x66ffcc), // spindrift  // blue - light\r\n  // new THREE.Color(0x66ff66), // flora      // green - light\r\n  // new THREE.Color(0x000000),\r\n  // new THREE.Color(0x0000FF),\r\n  new THREE.Color(0xFFFFFF),\r\n];\r\n\r\n\r\nmodule.exports = Constants;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/constants.js\n// module id = ./src/app/shared/lib/gcode/constants.js\n// module chunks = main","function FileIO() {}\r\n\r\n// NOTE: read form a link (or AJAX call :-?), e.g. 'https://....gcode'\r\nFileIO.loadPath = function (path, callback) {\r\n  let self = this;\r\n  $.get(path, null, callback, 'text');\r\n}\r\n\r\n// NOTE: read from file, e.g. by drag and drop\r\nFileIO.load = function (files, callback) {\r\n  if (files.length) {\r\n    for (i = 0; i < files.length; i++)\r\n      FileIO.load(files[i], callback);\r\n  }\r\n  else {\r\n    let reader = new FileReader(); // NOTE: built-in method!\r\n    reader.onload = function () {\r\n      callback(reader.result);\r\n    };\r\n    reader.readAsText(files);\r\n  }\r\n}\r\n\r\n// NOTE: receives the result of FileIO and\r\n// in its callback, the model creation, etc. comes\r\nfunction GCodeImporter() {}\r\n\r\nGCodeImporter.importPath = function (path, callback) {\r\n  FileIO.loadPath(path, function (gcode) {\r\n    GCodeImporter.importText(gcode, callback);\r\n  });\r\n}\r\n\r\nGCodeImporter.importText = function (gcode, callback) {\r\n  let gcodeModel = gcode;\r\n  callback(gcodeModel);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  FileIO,\r\n  GCodeImporter,\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/gimporter.js\n// module id = ./src/app/shared/lib/gcode/gimporter.js\n// module chunks = main","\r\n// Base semi-classes\r\nfunction GCodeModel() {\r\n  this.codes = [];\r\n};\r\n\r\nfunction GCode() {\r\n  this.words = [];\r\n  this.comments = [];\r\n  this.index = 0;\r\n};\r\n\r\nfunction GWord(letter, value, raw) {\r\n  this.letter = letter;\r\n  this.value = value;\r\n  this.raw = raw;\r\n};\r\n\r\n// main parser\r\nfunction GCodeParser() {\r\n  this.model = new GCodeModel();\r\n}\r\n\r\nGCodeParser.prototype.parseComments = function (line) {\r\n  var self = this;\r\n  let comments = [];\r\n\r\n  // comments: full-line/in-line parenthesis or semicolon\r\n  addComments(line.match(/\\((.*)\\)$/g, ''));\r\n  addComments(line.match(/\\((.*?)\\)/g, ''));\r\n  addComments(line.match(/;(.*$)/g, ''));\r\n\r\n  function addComments(matches) {\r\n    if (matches) matches.forEach(comment => comments.push(comment));\r\n  }\r\n  return comments;\r\n}\r\n\r\nGCodeParser.prototype.parseWord = function (word) {\r\n  if (!word.length) return;\r\n\r\n  let letter = word[0].toUpperCase();\r\n  let value = word.slice(1);\r\n\r\n  if (letter < 'A' || letter > 'Z') return;\r\n  return new GWord(letter, value);\r\n};\r\n\r\nGCodeParser.prototype.parseLine = function (line) {\r\n  let self = this;\r\n  let pLine = new GCode();\r\n  pLine.comments = self.parseComments(line);\r\n  pLine.comments.forEach(comment => line = line.replace(comment, ''));\r\n\r\n  let words = line.trim().split(' ');\r\n  for (let i = 0; i < words.length; i++) {\r\n    if (!words[i] || words[i].length <= 0) continue;\r\n\r\n    let pWord = this.parseWord(words[i]);\r\n    if (!pWord) continue;\r\n\r\n    pLine.words.push(pWord);\r\n  }\r\n  return pLine;\r\n};\r\n\r\nGCodeParser.prototype.parse = function (gcode) {\r\n  let self = this;\r\n  let current = new GCode();\r\n  let currentIndex = 0;\r\n\r\n  let lines = gcode.split('\\n');\r\n  for (let i = 0; i < lines.length; i++) {\r\n    if (lines[i].trim().startsWith(';')) continue;\r\n\r\n    let lineCode = self.parseLine(lines[i]);\r\n    // Trying to auto-group words across multiple lines and split single lines\r\n    // Detect new code group, add current group to model & start a new group\r\n    lineCode.words.forEach(word => {\r\n      if (['G', 'M'].some(l => word.letter === l)) {\r\n        if (current.words.length) {\r\n          self.model.codes.push(current);\r\n          current = new GCode();\r\n          current.index = ++currentIndex;\r\n        }\r\n      }\r\n      current.words.push(word);\r\n    });\r\n  }\r\n  self.model.codes.push(current);\r\n  return self.model;\r\n};\r\n\r\nGCodeParser.prototype.centerizeGCodes = function (gcode) {\r\n  let newg = [];\r\n  let sum = [0, 0, 0],\r\n    num = [0, 0, 0],\r\n    mean = [0, 0, 0];\r\n\r\n  // remove useless data\r\n  gcode.codes.forEach(g => {\r\n    // it is G and has some X and Y values\r\n    // and X and Y values are not both 0\r\n    let cond1 = ['G', 'X', 'Y'].every(l => g.words.map(el => el.letter).includes(l))\r\n      && !['X', 'Y'].every(l => g.words.find(el => el.letter === l).value == 0)\r\n    // also accept if only includes Z\r\n    let cond2 = ['G', 'Z'].every(l => g.words.map(el => el.letter).includes(l));\r\n    if (cond1 || cond2)\r\n      newg.push(g);\r\n  });\r\n\r\n  gcode.codes = newg;\r\n  newg = [];\r\n\r\n  // center around (0, 0, 0)\r\n  gcode.codes.forEach(g => {\r\n    ['X', 'Y', 'Z'].forEach((letter, index) => {\r\n      if (g.words.map(el => el.letter).includes(letter)) {\r\n        sum[index] += parseFloat(g.words.find(el => el.letter === letter).value);\r\n        num[index]++;\r\n      }\r\n    });\r\n  });\r\n\r\n  mean = [\r\n    sum[0] / num[0],\r\n    sum[1] / num[1],\r\n    sum[2] / num[2]\r\n  ];\r\n\r\n  gcode.codes.forEach(g => {\r\n    // ['X', 'Y', 'Z'] // -> no need to center around Z, I suppose :-?\r\n    // TODO2: think about Z to see whether it's good to centerize that too\r\n    ['X', 'Y']\r\n      .forEach((letter, index) => {\r\n        if (g.words.map(el => el.letter).includes(letter)) {\r\n          let obj = g.words.find(el => el.letter === letter);\r\n          obj.value = '' + (parseFloat(obj.value) - mean[index]);\r\n        }\r\n      });\r\n  });\r\n\r\n  return gcode;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  GCodeModel,\r\n  GCode,\r\n  GWord,\r\n  GCodeParser,\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/gparser.js\n// module id = ./src/app/shared/lib/gcode/gparser.js\n// module chunks = main","\r\nfunction GCodeViewModel(code) {\r\n  this.code = code;\r\n  this.vertexIndex = 0;\r\n  this.vertexLength = 0;\r\n}\r\n\r\nfunction GCodeRenderer() {\r\n  let self = this;\r\n\r\n  this.viewModels = [];\r\n  this.index = 0;\r\n  this.baseObject = new THREE.Object3D();\r\n\r\n  this.motionGeo = new THREE.Geometry();\r\n  this.motionMat = new THREE.LineBasicMaterial({\r\n    opacity: 0.2,\r\n    transparent: true,\r\n    linewidth: 1,\r\n    vertexColors: THREE.VertexColors\r\n  });\r\n\r\n  this.motionIncGeo = new THREE.Geometry();\r\n  this.motionIncMat = new THREE.LineBasicMaterial({\r\n    opacity: 0.2,\r\n    transparent: true,\r\n    linewidth: 1,\r\n    vertexColors: THREE.VertexColors\r\n  });\r\n\r\n  this.feedAllGeo = new THREE.Geometry();\r\n\r\n  this.feedGeo = new THREE.Geometry();\r\n  this.feedMat = new THREE.LineBasicMaterial({\r\n    opacity: 0.8,\r\n    transparent: true,\r\n    linewidth: 2,\r\n    vertexColors: THREE.VertexColors\r\n  });\r\n\r\n  this.feedIncGeo = new THREE.Geometry();\r\n  this.feedIncMat = new THREE.LineBasicMaterial({\r\n    opacity: 0.2,\r\n    transparent: true,\r\n    linewidth: 2,\r\n    vertexColors: THREE.VertexColors\r\n  });\r\n\r\n  this.lastLine = {x: 0, y: 0, z: 0, e: 0, f: 0};\r\n  this.relative = false;\r\n  this.bounds = {\r\n    min: {x: 100000, y: 100000, z: 100000},\r\n    max: {x: -100000, y: -100000, z: -100000}\r\n  };\r\n\r\n  this.geometryHandlers = {\r\n    G0: function (viewModel) {\r\n      let newLine = {};\r\n      viewModel.code.words.forEach(function (word) {\r\n        switch (word.letter) {\r\n          case 'X': case 'Y': case 'Z': case 'E': case 'F':\r\n            let p = word.letter.toLowerCase();\r\n            newLine[p] = self.absolute(self.lastLine[p], parseFloat(word.value));\r\n            break;\r\n        }\r\n      });\r\n      ['x', 'y', 'z', 'e', 'f'].forEach(function (prop) {\r\n        if (newLine[prop] === undefined) {\r\n          newLine[prop] = self.lastLine[prop];\r\n        }\r\n      });\r\n\r\n      viewModel.vertexIndex = self.motionGeo.vertices.length;\r\n\r\n      let color = GCodeRenderer.motionColors[viewModel.code.index % GCodeRenderer.motionColors.length];\r\n      self.motionGeo.vertices.push(new THREE.Vector3(self.lastLine.x, self.lastLine.y, self.lastLine.z));\r\n      self.motionGeo.vertices.push(new THREE.Vector3(newLine.x, newLine.y, newLine.z));\r\n\r\n      self.motionGeo.colors.push(color);\r\n      self.motionGeo.colors.push(color);\r\n\r\n      viewModel.vertexLength = self.motionGeo.vertices.length - viewModel.vertexIndex;\r\n      self.lastLine = newLine;\r\n      return self.motionGeo;\r\n    },\r\n    G1: function (viewModel) {\r\n      let newLine = {};\r\n      viewModel.code.words.forEach(function (word) {\r\n        switch (word.letter) {\r\n          case 'X': case 'Y': case 'Z': case 'E': case 'F':\r\n            let p = word.letter.toLowerCase();\r\n            newLine[p] = self.absolute(self.lastLine[p], parseFloat(word.value));\r\n            break;\r\n        }\r\n      });\r\n      ['x', 'y', 'z', 'e', 'f'].forEach(function (prop) {\r\n        if (newLine[prop] === undefined) {\r\n          newLine[prop] = self.lastLine[prop];\r\n        }\r\n      });\r\n\r\n      let color = GCodeRenderer.feedColors[viewModel.code.index % GCodeRenderer.feedColors.length];\r\n      let p1 = new THREE.Vector3(self.lastLine.x, self.lastLine.y, self.lastLine.z);\r\n      let p2 = new THREE.Vector3(newLine.x, newLine.y, newLine.z);\r\n      viewModel.vertexIndex = self.feedAllGeo.vertices.length;\r\n\r\n      if (viewModel.code.index <= self.index) {\r\n        self.feedGeo.vertices.push(p1);\r\n        self.feedGeo.vertices.push(p2);\r\n        self.feedGeo.colors.push(color);\r\n        self.feedGeo.colors.push(color);\r\n      } else {\r\n        self.feedIncGeo.vertices.push(p1);\r\n        self.feedIncGeo.vertices.push(p2);\r\n        self.feedIncGeo.colors.push(color);\r\n        self.feedIncGeo.colors.push(color);\r\n      }\r\n      self.feedAllGeo.vertices.push(p1);\r\n      self.feedAllGeo.vertices.push(p2);\r\n      self.feedAllGeo.colors.push(color);\r\n      self.feedAllGeo.colors.push(color);\r\n\r\n      viewModel.vertexLength = self.feedAllGeo.vertices.length - viewModel.vertexIndex;\r\n      self.lastLine = newLine;\r\n      return self.feedGeo;\r\n    },\r\n    G2: function (viewModel) {\r\n    }\r\n  };\r\n\r\n  this.materialHandlers = {\r\n    G0: function (viewModel) {\r\n      return this.motionMat;\r\n    },\r\n    G1: function (viewModel) {\r\n      return this.feedMat;\r\n    },\r\n    G2: function (viewModel) {\r\n      return this.feedMat;\r\n    }\r\n  };\r\n};\r\n\r\nGCodeRenderer.motionColors = Constants.motionColors;\r\nGCodeRenderer.feedColors = Constants.feedColors;\r\n\r\nGCodeRenderer.prototype.absolute = function (v1, v2) {\r\n  return this.relative ? v1 + v2 : v2;\r\n}\r\n\r\nGCodeRenderer.prototype.render = function (model) {\r\n  this.model = model;\r\n\r\n  // 'this.model.codes' are the parsed-gcodes!\r\n  this.model.codes.forEach(code => this.renderGCode(code));\r\n  this.updateLines();\r\n\r\n  // Center\r\n  this.feedAllGeo.computeBoundingBox();\r\n  this.bounds = this.feedAllGeo.boundingBox;\r\n\r\n  // the center of the object model itself\r\n  this.center = new THREE.Vector3(\r\n    ((this.bounds.max.x + this.bounds.min.x) / 2),\r\n    ((this.bounds.max.y + this.bounds.min.y) / 2),\r\n    ((this.bounds.max.z + this.bounds.min.z) / 2)\r\n  );\r\n\r\n  let width = Constants.width, height = Constants.height;\r\n  let zScale = height / (this.bounds.max.z - this.bounds.min.z),\r\n    yScale = width / (this.bounds.max.y - this.bounds.min.y),\r\n    xScale = width / (this.bounds.max.x - this.bounds.min.x);\r\n  let scale = Math.min(zScale, Math.min(xScale, yScale));\r\n  this.baseObject.position = this.center.multiplyScalar(-scale);\r\n  this.baseObject.scale.multiplyScalar(scale * Constants.dimensionCoef);\r\n\r\n  return this.baseObject;\r\n};\r\n\r\nGCodeRenderer.prototype.updateLines = function (renderHover = true) {\r\n  while (this.baseObject.children.length)\r\n    this.baseObject.remove(this.baseObject.children[0]);\r\n\r\n  if (renderHover)\r\n    this.baseObject.add(new THREE.Line(this.motionGeo, this.motionMat, THREE.LinePieces)); // hover around\r\n  this.baseObject.add(new THREE.Line(this.feedGeo, this.feedMat, THREE.LinePieces)); // the shape itself (the colored lines, etc.)\r\n  this.baseObject.add(new THREE.Line(this.feedIncGeo, this.feedIncMat, THREE.LinePieces)); // the hollowed-hover around :-?\r\n};\r\n\r\nGCodeRenderer.prototype.renderGCode = function (code) {\r\n  let cmd = code.words[0].letter + code.words[0].value;\r\n  let viewModel = new GCodeViewModel(code);\r\n\r\n  try {\r\n    this.geometryHandlers[cmd](viewModel);\r\n    this.materialHandlers[cmd](viewModel);\r\n  }\r\n  catch (err) {\r\n    console.info(\"not G command: \", err);\r\n  }\r\n\r\n  if (viewModel.vertexLength)\r\n    this.viewModels.push(viewModel);\r\n};\r\n\r\n// this decides till which index should we render the model\r\nGCodeRenderer.prototype.setIndex = function (index, renderHover = true) {\r\n  index = Math.floor(index);\r\n  if (this.index == index) return;\r\n  if (index < 0 || index >= this.viewModels.length) return;\r\n\r\n  let vm = this.viewModels[index];\r\n  this.feedGeo = new THREE.Geometry();\r\n\r\n  let vertices = this.feedAllGeo.vertices.slice(0, vm.vertexIndex + vm.vertexLength);\r\n\r\n  // THIS CAUSED STACK OVERFLOW!\r\n  // Array.prototype.push.apply(this.feedGeo.vertices, vertices);\r\n  console.log(\"vertices to add: \", vertices.length);\r\n  for (item in vertices)\r\n    this.feedGeo.vertices.push(vertices[item]);\r\n\r\n  let colors = this.feedAllGeo.colors.slice(0, vm.vertexIndex + vm.vertexLength);\r\n  // Array.prototype.push.apply(this.feedGeo.colors, colors);\r\n  for (item in colors)\r\n    this.feedGeo.colors.push(colors[item]);\r\n\r\n  this.updateLines(renderHover);\r\n  this.index = index;\r\n};\r\n\r\n\r\nmodule.exports = {\r\n  GCodeViewModel,\r\n  GCodeRenderer,\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/grenderer.js\n// module id = ./src/app/shared/lib/gcode/grenderer.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author davidedc / http://www.sketchpatch.net/\r\n *\r\n * ShaderExtras currently contains:\r\n *\r\n *\tscreen\r\n *\tconvolution\r\n *\tfilm\r\n * \tbokeh\r\n *  sepia\r\n *\tdotscreen\r\n *\tvignette\r\n *  bleachbypass\r\n *\tbasic\r\n *  dofmipmap\r\n *  focus\r\n *  triangleBlur\r\n *  horizontalBlur + verticalBlur\r\n *  horizontalTiltShift + verticalTiltShift\r\n *  blend\r\n *  fxaa\r\n *  luminosity\r\n *  colorCorrection\r\n *  normalmap\r\n *  ssao\r\n *  colorify\r\n *  unpackDepthRGBA\r\n */\r\n\r\nTHREE.ShaderExtras = {\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tFull-screen textured quad shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'screen': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\topacity:  { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* ------------------------------------------------------------------------\r\n\t//\tConvolution shader\r\n\t//\t  - ported from o3d sample to WebGL / GLSL\r\n\t//\t\t\thttp://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n\t------------------------------------------------------------------------ */\r\n\r\n\t'convolution': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\" : \t\t{ type: \"t\", value: null },\r\n\t\t\t\"uImageIncrement\" : { type: \"v2\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\t\"cKernel\" : \t\t{ type: \"fv1\", value: [] }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t//\"#define KERNEL_SIZE 25.0\",\r\n\r\n\t\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv - ( ( KERNEL_SIZE - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t//\"#define KERNEL_SIZE 25\",\r\n\t\t\t\"uniform float cKernel[ KERNEL_SIZE ];\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\t\"for( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\r\n\r\n\t\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\r\n\t// Film grain & scanlines shader\r\n\r\n\t//\t- ported from HLSL to WebGL / GLSL\r\n\t//\t  http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\r\n\r\n\t// Screen Space Static Postprocessor\r\n\t//\r\n\t// Produces an analogue noise overlay similar to a film grain / TV static\r\n\t//\r\n\t// Original implementation and noise algorithm\r\n\t// Pat 'Hawthorne' Shearon\r\n\t//\r\n\t// Optimized scanlines + noise version with intensity scaling\r\n\t// Georg 'Leviathan' Steinrohder\r\n\r\n\t// This version is provided under a Creative Commons Attribution 3.0 License\r\n\t// http://creativecommons.org/licenses/by/3.0/\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'film': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse:   { type: \"t\", value: null },\r\n\t\t\ttime: \t    { type: \"f\", value: 0.0 },\r\n\t\t\tnIntensity: { type: \"f\", value: 0.5 },\r\n\t\t\tsIntensity: { type: \"f\", value: 0.05 },\r\n\t\t\tsCount: \t{ type: \"f\", value: 4096 },\r\n\t\t\tgrayscale:  { type: \"i\", value: 1 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t// control parameter\r\n\t\t\t\"uniform float time;\",\r\n\r\n\t\t\t\"uniform bool grayscale;\",\r\n\r\n\t\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\t\"uniform float nIntensity;\",\r\n\r\n\t\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\t\"uniform float sIntensity;\",\r\n\r\n\t\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\r\n\t\t\t\"uniform float sCount;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// sample the source\r\n\t\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t// make some noise\r\n\t\t\t\t\"float x = vUv.x * vUv.y * time *  1000.0;\",\r\n\t\t\t\t\"x = mod( x, 13.0 ) * mod( x, 123.0 );\",\r\n\t\t\t\t\"float dx = mod( x, 0.01 );\",\r\n\r\n\t\t\t\t// add noise\r\n\t\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\",\r\n\r\n\t\t\t\t// get us a sine and cosine\r\n\t\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\r\n\r\n\t\t\t\t// add scanlines\r\n\t\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\r\n\r\n\t\t\t\t// interpolate between source and result by intensity\r\n\t\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\r\n\r\n\t\t\t\t// convert to grayscale if desired\r\n\t\t\t\t\"if( grayscale ) {\",\r\n\r\n\t\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tDepth-of-field shader with bokeh\r\n\t//\tported from GLSL shader by Martins Upitis\r\n\t//\thttp://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'bokeh'\t: {\r\n\r\n\tuniforms: { tColor:   { type: \"t\", value: null },\r\n\t\t\t\ttDepth:   { type: \"t\", value: null },\r\n\t\t\t\tfocus:    { type: \"f\", value: 1.0 },\r\n\t\t\t\taspect:   { type: \"f\", value: 1.0 },\r\n\t\t\t\taperture: { type: \"f\", value: 0.025 },\r\n\t\t\t\tmaxblur:  { type: \"f\", value: 1.0 }\r\n\t\t\t  },\r\n\r\n\tvertexShader: [\r\n\r\n\t\"varying vec2 vUv;\",\r\n\r\n\t\"void main() {\",\r\n\r\n\t\t\"vUv = uv;\",\r\n\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\"varying vec2 vUv;\",\r\n\r\n\t\"uniform sampler2D tColor;\",\r\n\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\"uniform float maxblur;\",  \t// max blur amount\r\n\t\"uniform float aperture;\",\t// aperture - bigger values for shallower depth of field\r\n\r\n\t\"uniform float focus;\",\r\n\t\"uniform float aspect;\",\r\n\r\n\t\"void main() {\",\r\n\r\n\t\t\"vec2 aspectcorrect = vec2( 1.0, aspect );\",\r\n\r\n\t\t\"vec4 depth1 = texture2D( tDepth, vUv );\",\r\n\r\n\t\t\"float factor = depth1.x - focus;\",\r\n\r\n\t\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\r\n\r\n\t\t\"vec2 dofblur9 = dofblur * 0.9;\",\r\n\t\t\"vec2 dofblur7 = dofblur * 0.7;\",\r\n\t\t\"vec2 dofblur4 = dofblur * 0.4;\",\r\n\r\n\t\t\"vec4 col = vec4( 0.0 );\",\r\n\r\n\t\t\"col += texture2D( tColor, vUv.xy );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\r\n\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\r\n\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\r\n\r\n\t\t\"gl_FragColor = col / 41.0;\",\r\n\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tDepth-of-field shader using mipmaps\r\n\t//\t- from Matt Handley @applmak\r\n\t//\t- requires power-of-2 sized render target with enabled mipmaps\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'dofmipmap': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttColor:   { type: \"t\", value: null },\r\n\t\t\ttDepth:   { type: \"t\", value: null },\r\n\t\t\tfocus:    { type: \"f\", value: 1.0 },\r\n\t\t\tmaxblur:  { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float focus;\",\r\n\t\t\t\"uniform float maxblur;\",\r\n\r\n\t\t\t\"uniform sampler2D tColor;\",\r\n\t\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 depth = texture2D( tDepth, vUv );\",\r\n\r\n\t\t\t\t\"float factor = depth.x - focus;\",\r\n\r\n\t\t\t\t\"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\",\r\n\r\n\t\t\t\t\"gl_FragColor = col;\",\r\n\t\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tSepia tone shader\r\n\t//  - based on glfx.js sepia shader\r\n\t//\t\thttps://github.com/evanw/glfx.js\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'sepia': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\tamount:   { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float amount;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"vec3 c = color.rgb;\",\r\n\r\n\t\t\t\t\"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\",\r\n\t\t\t\t\"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\",\r\n\t\t\t\t\"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tDot screen shader\r\n\t//  - based on glfx.js sepia shader\r\n\t//\t\thttps://github.com/evanw/glfx.js\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'dotscreen': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\ttSize:    { type: \"v2\", value: new THREE.Vector2( 256, 256 ) },\r\n\t\t\tcenter:   { type: \"v2\", value: new THREE.Vector2( 0.5, 0.5 ) },\r\n\t\t\tangle:\t  { type: \"f\", value: 1.57 },\r\n\t\t\tscale:\t  { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec2 center;\",\r\n\t\t\t\"uniform float angle;\",\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"uniform vec2 tSize;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"float pattern() {\",\r\n\r\n\t\t\t\t\"float s = sin( angle ), c = cos( angle );\",\r\n\r\n\t\t\t\t\"vec2 tex = vUv * tSize - center;\",\r\n\t\t\t\t\"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\r\n\r\n\t\t\t\t\"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\"float average = ( color.r + color.g + color.b ) / 3.0;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* ------------------------------------------------------------------------------------------------\r\n\t//\tVignette shader\r\n\t//\t- based on PaintEffect postprocess from ro.me\r\n\t//\t\thttp://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\r\n\t ------------------------------------------------------------------------------------------------ */\r\n\r\n\t'vignette': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\toffset:   { type: \"f\", value: 1.0 },\r\n\t\t\tdarkness: { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float offset;\",\r\n\t\t\t\"uniform float darkness;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// Eskil's vignette\r\n\r\n\t\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\",\r\n\t\t\t\t\"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t// alternative version from glfx.js\r\n\t\t\t\t// this one makes more \"dusty\" look (as opposed to \"burned\")\r\n\r\n\t\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"float dist = distance( vUv, vec2( 0.5 ) );\",\r\n\t\t\t\t\"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\r\n\t\t\t\t\"gl_FragColor = color;\",\r\n\t\t\t\t*/\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tBleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\r\n\t//\t- based on Nvidia example\r\n\t//\t\thttp://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'bleachbypass': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\topacity:  { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 base = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\",\r\n\t\t\t\t\"float lum = dot( lumCoeff, base.rgb );\",\r\n\t\t\t\t\"vec3 blend = vec3( lum );\",\r\n\r\n\t\t\t\t\"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\",\r\n\r\n\t\t\t\t\"vec3 result1 = 2.0 * base.rgb * blend;\",\r\n\t\t\t\t\"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\",\r\n\r\n\t\t\t\t\"vec3 newColor = mix( result1, result2, L );\",\r\n\r\n\t\t\t\t\"float A2 = opacity * base.a;\",\r\n\t\t\t\t\"vec3 mixRGB = A2 * newColor.rgb;\",\r\n\t\t\t\t\"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( mixRGB, base.a );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* --------------------------------------------------------------------------------------------------\r\n\t//\tFocus shader\r\n\t//\t- based on PaintEffect postprocess from ro.me\r\n\t//\t\thttp://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\r\n\t -------------------------------------------------------------------------------------------------- */\r\n\r\n\t'focus': {\r\n\r\n\t\tuniforms : {\r\n\r\n\t\t\t\"tDiffuse\": \t\t{ type: \"t\", value: null },\r\n\t\t\t\"screenWidth\": \t\t{ type: \"f\", value: 1024 },\r\n\t\t\t\"screenHeight\": \t{ type: \"f\", value: 1024 },\r\n\t\t\t\"sampleDistance\": \t{ type: \"f\", value: 0.94 },\r\n\t\t\t\"waveFactor\": \t\t{ type: \"f\", value: 0.00125 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float screenWidth;\",\r\n\t\t\t\"uniform float screenHeight;\",\r\n\t\t\t\"uniform float sampleDistance;\",\r\n\t\t\t\"uniform float waveFactor;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 color, org, tmp, add;\",\r\n\t\t\t\t\"float sample_dist, f;\",\r\n\t\t\t\t\"vec2 vin;\",\r\n\t\t\t\t\"vec2 uv = vUv;\",\r\n\r\n\t\t\t\t\"add = color = org = texture2D( tDiffuse, uv );\",\r\n\r\n\t\t\t\t\"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\",\r\n\t\t\t\t\"sample_dist = dot( vin, vin ) * 2.0;\",\r\n\r\n\t\t\t\t\"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\",\r\n\r\n\t\t\t\t\"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\",\r\n\t\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\t\"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\",\r\n\t\t\t\t\"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tTriangle blur shader\r\n\t//  - based on glfx.js triangle blur shader\r\n\t//\t\thttps://github.com/evanw/glfx.js\r\n\r\n\t// \tA basic blur filter, which convolves the image with a\r\n\t// \tpyramid filter. The pyramid filter is separable and is applied as two\r\n\t//  perpendicular triangle filters.\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'triangleBlur': {\r\n\r\n\r\n\t\tuniforms : {\r\n\r\n\t\t\t\"texture\": \t{ type: \"t\", value: null },\r\n\t\t\t\"delta\": \t{ type: \"v2\", value:new THREE.Vector2( 1, 1 )  }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\"#define ITERATIONS 10.0\",\r\n\r\n\t\t\"uniform sampler2D texture;\",\r\n\t\t\"uniform vec2 delta;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"float random( vec3 scale, float seed ) {\",\r\n\r\n\t\t\t// use the fragment position for a different seed per-pixel\r\n\r\n\t\t\t\"return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color = vec4( 0.0 );\",\r\n\r\n\t\t\t\"float total = 0.0;\",\r\n\r\n\t\t\t// randomize the lookup values to hide the fixed number of samples\r\n\r\n\t\t\t\"float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\",\r\n\r\n\t\t\t\"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\",\r\n\r\n\t\t\t\t\"float percent = ( t + offset - 0.5 ) / ITERATIONS;\",\r\n\t\t\t\t\"float weight = 1.0 - abs( percent );\",\r\n\r\n\t\t\t\t\"color += texture2D( texture, vUv + delta * percent ) * weight;\",\r\n\t\t\t\t\"total += weight;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = color / total;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tSimple test shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* --------------------------------------------------------------------------------------------------\r\n\t//\tTwo pass Gaussian blur filter (horizontal and vertical blur shaders)\r\n\t//\t- described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\r\n\t//\t  and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\r\n\t//\r\n\t//\t- 9 samples per pass\r\n\t//\t- standard deviation 2.7\r\n\t//\t- \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n\t -------------------------------------------------------------------------------------------------- */\r\n\r\n\t'horizontalBlur': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\r\n\t\t\t\"h\": \t\t{ type: \"f\", value: 1.0 / 512.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform float h;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, \t\t  \tvUv.y ) ) * 0.1633;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\",\r\n\r\n\t\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'verticalBlur': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\r\n\t\t\t\"v\": \t\t{ type: \"f\", value: 1.0 / 512.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform float v;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y\t\t\t  ) ) * 0.1633;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\",\r\n\r\n\t\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* --------------------------------------------------------------------------------------------------\r\n\t//\tSimple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\r\n\t//\r\n\t//\t- 9 samples per pass\r\n\t//\t- standard deviation 2.7\r\n\t//\t- \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n\t//\t- \"r\" parameter control where \"focused\" horizontal line lies\r\n\t -------------------------------------------------------------------------------------------------- */\r\n\r\n\t'horizontalTiltShift': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\r\n\t\t\t\"h\": \t\t{ type: \"f\", value: 1.0 / 512.0 },\r\n\t\t\t\"r\": \t\t{ type: \"f\", value: 0.35 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform float h;\",\r\n\t\t\t\"uniform float r;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\t\"float hh = h * abs( r - vUv.y );\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, \t\t  \t vUv.y ) ) * 0.1633;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\",\r\n\r\n\t\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'verticalTiltShift': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": { type: \"t\", value: null },\r\n\t\t\t\"v\": \t\t{ type: \"f\", value: 1.0 / 512.0 },\r\n\t\t\t\"r\": \t\t{ type: \"f\", value: 0.35 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform float v;\",\r\n\t\t\t\"uniform float r;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\t\"float vv = v * abs( r - vUv.y );\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y\t\t\t   ) ) * 0.1633;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\",\r\n\t\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\",\r\n\r\n\t\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tBlend two textures\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'blend': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse1: { type: \"t\", value: null },\r\n\t\t\ttDiffuse2: { type: \"t\", value: null },\r\n\t\t\tmixRatio:  { type: \"f\", value: 0.5 },\r\n\t\t\topacity:   { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform float mixRatio;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse1;\",\r\n\t\t\t\"uniform sampler2D tDiffuse2;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texel1 = texture2D( tDiffuse1, vUv );\",\r\n\t\t\t\t\"vec4 texel2 = texture2D( tDiffuse2, vUv );\",\r\n\t\t\t\t\"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tNVIDIA FXAA by Timothy Lottes\r\n\t//\t\thttp://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\r\n\t//\t- WebGL port by @supereggbert\r\n\t//\t\thttp://www.glge.org/demos/fxaa/\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'fxaa': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": \t{ type: \"t\", value: null },\r\n\t\t\t\"resolution\": \t{ type: \"v2\", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"#define FXAA_REDUCE_MIN   (1.0/128.0)\",\r\n\t\t\t\"#define FXAA_REDUCE_MUL   (1.0/8.0)\",\r\n\t\t\t\"#define FXAA_SPAN_MAX     8.0\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\",\r\n\t\t\t\t\"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\",\r\n\t\t\t\t\"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\",\r\n\t\t\t\t\"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\",\r\n\t\t\t\t\"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\",\r\n\t\t\t\t\"vec3 rgbM  = rgbaM.xyz;\",\r\n\t\t\t\t\"float opacity  = rgbaM.w;\",\r\n\r\n\t\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\r\n\r\n\t\t\t\t\"float lumaNW = dot( rgbNW, luma );\",\r\n\t\t\t\t\"float lumaNE = dot( rgbNE, luma );\",\r\n\t\t\t\t\"float lumaSW = dot( rgbSW, luma );\",\r\n\t\t\t\t\"float lumaSE = dot( rgbSE, luma );\",\r\n\t\t\t\t\"float lumaM  = dot( rgbM,  luma );\",\r\n\t\t\t\t\"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\",\r\n\t\t\t\t\"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\",\r\n\r\n\t\t\t\t\"vec2 dir;\",\r\n\t\t\t\t\"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\",\r\n\t\t\t\t\"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\",\r\n\r\n\t\t\t\t\"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\",\r\n\r\n\t\t\t\t\"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\",\r\n\t\t\t\t\"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\",\r\n\t\t\t\t\t  \"max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\",\r\n\t\t\t\t\t\t\t\"dir * rcpDirMin)) * resolution;\",\r\n\r\n\t\t\t\t\"vec3 rgbA = 0.5 * (\",\r\n\t\t\t\t\t\"texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\",\r\n\t\t\t\t\t\"texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );\",\r\n\r\n\t\t\t\t\"vec3 rgbB = rgbA * 0.5 + 0.25 * (\",\r\n\t\t\t\t\t\"texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz +\",\r\n\t\t\t\t\t\"texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz );\",\r\n\r\n\t\t\t\t\"float lumaB = dot( rgbB, luma );\",\r\n\r\n\t\t\t\t\"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( rgbA, opacity );\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( rgbB, opacity );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tLuminosity\r\n\t//\thttp://en.wikipedia.org/wiki/Luminosity\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'luminosity': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": \t{ type: \"t\", value: null }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\r\n\r\n\t\t\t\t\"float v = dot( texel.xyz, luma );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( v, v, v, texel.w );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tColor correction\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'colorCorrection': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\" : \t{ type: \"t\", value: null },\r\n\t\t\t\"powRGB\" :\t\t{ type: \"v3\", value: new THREE.Vector3( 2, 2, 2 ) },\r\n\t\t\t\"mulRGB\" :\t\t{ type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform vec3 powRGB;\",\r\n\t\t\t\"uniform vec3 mulRGB;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tNormal map shader\r\n\t//\t- compute normals from heightmap\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'normalmap': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"heightMap\"\t: { type: \"t\", value: null },\r\n\t\t\t\"resolution\": { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\r\n\t\t\t\"scale\"\t\t: { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\t\t\t\"height\"\t: { type: \"f\", value: 0.05 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float height;\",\r\n\t\t\t\"uniform vec2 resolution;\",\r\n\t\t\t\"uniform sampler2D heightMap;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float val = texture2D( heightMap, vUv ).x;\",\r\n\r\n\t\t\t\t\"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\",\r\n\t\t\t\t\"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tScreen-space ambient occlusion shader\r\n\t//\t- ported from\r\n\t//\t\tSSAO GLSL shader v1.2\r\n\t//\t\tassembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\r\n\t//\t\toriginal technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\r\n\t//\t- modifications\r\n\t//\t\t- modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\r\n\t//\t\t- made fog more compatible with three.js linear fog\r\n\t//\t\t- refactoring and optimizations\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'ssao': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"tDiffuse\": \t{ type: \"t\", value: null },\r\n\t\t\t\"tDepth\":   \t{ type: \"t\", value: null },\r\n\t\t\t\"size\": \t\t{ type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\r\n\t\t\t\"cameraNear\":\t{ type: \"f\", value: 1 },\r\n\t\t\t\"cameraFar\":\t{ type: \"f\", value: 100 },\r\n\t\t\t\"fogNear\":\t\t{ type: \"f\", value: 5 },\r\n\t\t\t\"fogFar\":\t\t{ type: \"f\", value: 100 },\r\n\t\t\t\"fogEnabled\":\t{ type: \"i\", value: 0 },\r\n\t\t\t\"onlyAO\":\t\t{ type: \"i\", value: 0 },\r\n\t\t\t\"aoClamp\":\t\t{ type: \"f\", value: 0.3 },\r\n\t\t\t\"lumInfluence\":\t{ type: \"f\", value: 0.9 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float cameraNear;\",\r\n\t\t\t\"uniform float cameraFar;\",\r\n\r\n\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\"uniform float fogFar;\",\r\n\r\n\t\t\t\"uniform bool fogEnabled;\",\t\t// attenuate AO with linear fog\r\n\t\t\t\"uniform bool onlyAO;\", \t\t// use only ambient occlusion pass?\r\n\r\n\t\t\t\"uniform vec2 size;\",\t\t\t// texture width, height\r\n\t\t\t\"uniform float aoClamp;\", \t\t// depth clamp - reduces haloing at screen edges\r\n\r\n\t\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t//\"#define PI 3.14159265\",\r\n\t\t\t\"#define DL 2.399963229728653\", // PI * ( 3.0 - sqrt( 5.0 ) )\r\n\t\t\t\"#define EULER 2.718281828459045\",\r\n\r\n\t\t\t// helpers\r\n\r\n\t\t\t\"float width = size.x;\", \t// texture width\r\n\t\t\t\"float height = size.y;\", \t// texture height\r\n\r\n\t\t\t\"float cameraFarPlusNear = cameraFar + cameraNear;\",\r\n\t\t\t\"float cameraFarMinusNear = cameraFar - cameraNear;\",\r\n\t\t\t\"float cameraCoef = 2.0 * cameraNear;\",\r\n\r\n\t\t\t// user variables\r\n\r\n\t\t\t\"const int samples = 8;\", \t\t// ao sample count\r\n\t\t\t\"const float radius = 5.0;\", \t// ao radius\r\n\r\n\t\t\t\"const bool useNoise = false;\", \t\t // use noise instead of pattern for sample dithering\r\n\t\t\t\"const float noiseAmount = 0.0003;\", // dithering amount\r\n\r\n\t\t\t\"const float diffArea = 0.4;\", \t\t// self-shadowing reduction\r\n\t\t\t\"const float gDisplace = 0.4;\", \t// gauss bell center\r\n\r\n\t\t\t\"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );\",\r\n\t\t\t//\"const vec3 onlyAOColor = vec3( 1.0, 1.0, 1.0 );\",\r\n\r\n\r\n\t\t\t// RGBA depth\r\n\r\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\r\n\t\t\t\t\"return depth;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// generating noise / pattern texture for dithering\r\n\r\n\t\t\t\"vec2 rand( const vec2 coord ) {\",\r\n\r\n\t\t\t\t\"vec2 noise;\",\r\n\r\n\t\t\t\t\"if ( useNoise ) {\",\r\n\r\n\t\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\r\n\t\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\r\n\r\n\t\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\",\r\n\t\t\t\t\t\"float gg = fract( coord.t * ( height / 2.0 ) );\",\r\n\r\n\t\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float doFog() {\",\r\n\r\n\t\t\t\t\"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );\",\r\n\t\t\t\t\"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );\",\r\n\r\n\t\t\t\t\"return smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float readDepth( const in vec2 coord ) {\",\r\n\r\n\t\t\t\t//\"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\",\r\n\t\t\t\t\"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\",\r\n\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\r\n\r\n\t\t\t\t\"float garea = 2.0;\", \t\t\t\t\t\t // gauss bell width\r\n\t\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\", // depth difference (0-100)\r\n\r\n\t\t\t\t// reduce left bell width to avoid self-shadowing\r\n\r\n\t\t\t\t\"if ( diff < gDisplace ) {\",\r\n\r\n\t\t\t\t\t\"garea = diffArea;\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"far = 1;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"float dd = diff - gDisplace;\",\r\n\t\t\t\t\"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\",\r\n\t\t\t\t\"return gauss;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float calcAO( float depth, float dw, float dh ) {\",\r\n\r\n\t\t\t\t\"float dd = radius - depth * radius;\",\r\n\t\t\t\t\"vec2 vv = vec2( dw, dh );\",\r\n\r\n\t\t\t\t\"vec2 coord1 = vUv + dd * vv;\",\r\n\t\t\t\t\"vec2 coord2 = vUv - dd * vv;\",\r\n\r\n\t\t\t\t\"float temp1 = 0.0;\",\r\n\t\t\t\t\"float temp2 = 0.0;\",\r\n\r\n\t\t\t\t\"int far = 0;\",\r\n\t\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\r\n\r\n\t\t\t\t// DEPTH EXTRAPOLATION\r\n\r\n\t\t\t\t\"if ( far > 0 ) {\",\r\n\r\n\t\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\r\n\t\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"return temp1;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec2 noise = rand( vUv );\",\r\n\t\t\t\t\"float depth = readDepth( vUv );\",\r\n\r\n\t\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\r\n\r\n\t\t\t\t\"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\",\r\n\t\t\t\t\"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\r\n\r\n\t\t\t\t\"float pw;\",\r\n\t\t\t\t\"float ph;\",\r\n\r\n\t\t\t\t\"float ao;\",\r\n\r\n\t\t\t\t\"float dz = 1.0 / float( samples );\",\r\n\t\t\t\t\"float z = 1.0 - dz / 2.0;\",\r\n\t\t\t\t\"float l = 0.0;\",\r\n\r\n\t\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\r\n\r\n\t\t\t\t\t\"float r = sqrt( 1.0 - z );\",\r\n\r\n\t\t\t\t\t\"pw = cos( l ) * r;\",\r\n\t\t\t\t\t\"ph = sin( l ) * r;\",\r\n\t\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\r\n\t\t\t\t\t\"z = z - dz;\",\r\n\t\t\t\t\t\"l = l + DL;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"ao /= float( samples );\",\r\n\t\t\t\t\"ao = 1.0 - ao;\",\r\n\r\n\t\t\t\t\"if ( fogEnabled ) {\",\r\n\r\n\t\t\t\t\t\"ao = mix( ao, 1.0, doFog() );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\",\r\n\r\n\t\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\r\n\t\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\r\n\t\t\t\t\"vec3 luminance = vec3( lum );\",\r\n\r\n\t\t\t\t\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // mix( color * ao, white, luminance )\r\n\r\n\t\t\t\t\"if ( onlyAO ) {\",\r\n\r\n\t\t\t\t\t\"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // ambient occlusion only\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( final, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tColorify shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'colorify': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\tcolor:    { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 color;\",\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\r\n\t\t\t\t\"float v = dot( texel.xyz, luma );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( v * color, texel.w );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tUnpack RGBA depth shader\r\n\t//\t- show RGBA encoded depth as monochrome color\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'unpackDepthRGBA': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttDiffuse: { type: \"t\", value: null },\r\n\t\t\topacity:  { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t// RGBA depth\r\n\r\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\r\n\t\t\t\t\"return depth;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );\",\r\n\t\t\t\t\"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t// METHODS\r\n\r\n\tbuildKernel: function( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/ShaderExtras.js\n// module id = ./src/app/shared/lib/gcode/js/ShaderExtras.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function (strength, kernelSize, sigma, resolution) {\r\n\r\n  strength = (strength !== undefined) ? strength : 1;\r\n  kernelSize = (kernelSize !== undefined) ? kernelSize : 25;\r\n  sigma = (sigma !== undefined) ? sigma : 4.0;\r\n  resolution = (resolution !== undefined) ? resolution : 256;\r\n\r\n  // render targets\r\n\r\n  var pars = {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat};\r\n\r\n  this.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);\r\n  this.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);\r\n\r\n  // screen material\r\n\r\n  var screenShader = THREE.ShaderExtras[\"screen\"];\r\n\r\n  this.screenUniforms = THREE.UniformsUtils.clone(screenShader.uniforms);\r\n\r\n  this.screenUniforms[\"opacity\"].value = strength;\r\n\r\n  this.materialScreen = new THREE.ShaderMaterial({\r\n\r\n    uniforms: this.screenUniforms,\r\n    vertexShader: screenShader.vertexShader,\r\n    fragmentShader: screenShader.fragmentShader,\r\n    blending: THREE.AdditiveBlending,\r\n    transparent: true\r\n\r\n  });\r\n\r\n  // convolution material\r\n\r\n  var convolutionShader = THREE.ShaderExtras[\"convolution\"];\r\n\r\n  this.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);\r\n\r\n  this.convolutionUniforms[\"uImageIncrement\"].value = THREE.BloomPass.blurx;\r\n  this.convolutionUniforms[\"cKernel\"].value = THREE.ShaderExtras.buildKernel(sigma);\r\n\r\n  this.materialConvolution = new THREE.ShaderMaterial({\r\n\r\n    uniforms: this.convolutionUniforms,\r\n    vertexShader: \"#define KERNEL_SIZE \" + kernelSize + \".0\\n\" + convolutionShader.vertexShader,\r\n    fragmentShader: \"#define KERNEL_SIZE \" + kernelSize + \"\\n\" + convolutionShader.fragmentShader\r\n\r\n  });\r\n\r\n  this.enabled = true;\r\n  this.needsSwap = false;\r\n  this.clear = false;\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = {\r\n\r\n  render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\r\n\r\n    if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\r\n\r\n    // Render quad with blured scene into texture (convolution pass 1)\r\n\r\n    THREE.EffectComposer.quad.material = this.materialConvolution;\r\n\r\n    this.convolutionUniforms[\"tDiffuse\"].value = readBuffer;\r\n    this.convolutionUniforms[\"uImageIncrement\"].value = THREE.BloomPass.blurX;\r\n\r\n    renderer.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, true);\r\n\r\n\r\n    // Render quad with blured scene into texture (convolution pass 2)\r\n\r\n    this.convolutionUniforms[\"tDiffuse\"].value = this.renderTargetX;\r\n    this.convolutionUniforms[\"uImageIncrement\"].value = THREE.BloomPass.blurY;\r\n\r\n    renderer.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, true);\r\n\r\n    // Render original scene with superimposed blur to texture\r\n\r\n    THREE.EffectComposer.quad.material = this.materialScreen;\r\n\r\n    this.screenUniforms[\"tDiffuse\"].value = this.renderTargetY;\r\n\r\n    if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\r\n\r\n    renderer.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer, this.clear);\r\n\r\n  }\r\n\r\n};\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);\r\nTHREE.BloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/postprocessing/BloomPass.js\n// module id = ./src/app/shared/lib/gcode/js/postprocessing/BloomPass.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nlet myHeight = Constants.height,\r\n  myWidth = Constants.width;\r\n\r\nTHREE.EffectComposer = function (renderer, renderTarget) {\r\n\r\n  this.renderer = renderer;\r\n\r\n  this.renderTarget1 = renderTarget;\r\n\r\n  if (this.renderTarget1 === undefined) {\r\n\r\n    var width = myWidth || 1;\r\n    var height = myHeight || 1;\r\n\r\n    this.renderTargetParameters = {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false};\r\n    this.renderTarget1 = new THREE.WebGLRenderTarget(width, height, this.renderTargetParameters);\r\n\r\n  }\r\n\r\n  this.renderTarget2 = this.renderTarget1.clone();\r\n\r\n  this.writeBuffer = this.renderTarget1;\r\n  this.readBuffer = this.renderTarget2;\r\n\r\n  this.passes = [];\r\n\r\n  this.copyPass = new THREE.ShaderPass(THREE.ShaderExtras[\"screen\"]);\r\n\r\n};\r\n\r\nTHREE.EffectComposer.prototype = {\r\n\r\n  swapBuffers: function () {\r\n\r\n    var tmp = this.readBuffer;\r\n    this.readBuffer = this.writeBuffer;\r\n    this.writeBuffer = tmp;\r\n\r\n  },\r\n\r\n  addPass: function (pass) {\r\n\r\n    this.passes.push(pass);\r\n\r\n  },\r\n\r\n  render: function (delta) {\r\n\r\n    this.writeBuffer = this.renderTarget1;\r\n    this.readBuffer = this.renderTarget2;\r\n\r\n    var maskActive = false;\r\n\r\n    var pass, i, il = this.passes.length;\r\n\r\n    for (i = 0; i < il; i++) {\r\n\r\n      pass = this.passes[i];\r\n\r\n      if (!pass.enabled) continue;\r\n\r\n      pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);\r\n\r\n      if (pass.needsSwap) {\r\n\r\n        if (maskActive) {\r\n\r\n          var context = this.renderer.context;\r\n\r\n          context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\r\n\r\n          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);\r\n\r\n          context.stencilFunc(context.EQUAL, 1, 0xffffffff);\r\n\r\n        }\r\n\r\n        this.swapBuffers();\r\n\r\n      }\r\n\r\n      if (pass instanceof THREE.MaskPass) {\r\n\r\n        maskActive = true;\r\n\r\n      } else if (pass instanceof THREE.ClearMaskPass) {\r\n\r\n        maskActive = false;\r\n\r\n      }\r\n\r\n    }\r\n\r\n  },\r\n\r\n  reset: function (renderTarget) {\r\n\r\n    this.renderTarget1 = renderTarget;\r\n\r\n    if (this.renderTarget1 === undefined) {\r\n\r\n      this.renderTarget1 = new THREE.WebGLRenderTarget(myWidth, myHeight, this.renderTargetParameters);\r\n\r\n    }\r\n\r\n    this.renderTarget2 = this.renderTarget1.clone();\r\n\r\n    this.writeBuffer = this.renderTarget1;\r\n    this.readBuffer = this.renderTarget2;\r\n\r\n    THREE.EffectComposer.quad.scale.set(myWidth, myHeight, 1);\r\n\r\n    THREE.EffectComposer.camera.left = myWidth / - 2;\r\n    THREE.EffectComposer.camera.right = myWidth / 2;\r\n    THREE.EffectComposer.camera.top = myHeight / 2;\r\n    THREE.EffectComposer.camera.bottom = myHeight / - 2;\r\n\r\n    THREE.EffectComposer.camera.updateProjectionMatrix();\r\n\r\n  }\r\n\r\n};\r\n\r\n// shared ortho camera\r\n\r\nTHREE.EffectComposer.initWidth = myWidth || 1;\r\nTHREE.EffectComposer.initHeight = myHeight || 1;\r\n\r\nTHREE.EffectComposer.camera = new THREE.OrthographicCamera(THREE.EffectComposer.initWidth / - 2, THREE.EffectComposer.initWidth / 2, THREE.EffectComposer.initHeight / 2, THREE.EffectComposer.initHeight / - 2, -10000, 10000);\r\n\r\n// shared fullscreen quad scene\r\n\r\nTHREE.EffectComposer.geometry = new THREE.PlaneGeometry(1, 1);\r\n\r\nTHREE.EffectComposer.quad = new THREE.Mesh(THREE.EffectComposer.geometry, null);\r\nTHREE.EffectComposer.quad.position.z = -100;\r\nTHREE.EffectComposer.quad.scale.set(THREE.EffectComposer.initWidth, THREE.EffectComposer.initHeight, 1);\r\n\r\nTHREE.EffectComposer.scene = new THREE.Scene();\r\nTHREE.EffectComposer.scene.add(THREE.EffectComposer.quad);\r\nTHREE.EffectComposer.scene.add(THREE.EffectComposer.camera);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/postprocessing/EffectComposer.js\n// module id = ./src/app/shared/lib/gcode/js/postprocessing/EffectComposer.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MaskPass = function (scene, camera) {\r\n\r\n  this.scene = scene;\r\n  this.camera = camera;\r\n\r\n  this.enabled = true;\r\n  this.clear = true;\r\n  this.needsSwap = false;\r\n\r\n  this.inverse = false;\r\n\r\n};\r\n\r\nTHREE.MaskPass.prototype = {\r\n\r\n  render: function (renderer, writeBuffer, readBuffer, delta) {\r\n\r\n    var context = renderer.context;\r\n\r\n    // don't update color or depth\r\n\r\n    context.colorMask(false, false, false, false);\r\n    context.depthMask(false);\r\n\r\n    // set up stencil\r\n\r\n    var writeValue, clearValue;\r\n\r\n    if (this.inverse) {\r\n\r\n      writeValue = 0;\r\n      clearValue = 1;\r\n\r\n    } else {\r\n\r\n      writeValue = 1;\r\n      clearValue = 0;\r\n\r\n    }\r\n\r\n    context.enable(context.STENCIL_TEST);\r\n    context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);\r\n    context.stencilFunc(context.ALWAYS, writeValue, 0xffffffff);\r\n    context.clearStencil(clearValue);\r\n\r\n    // draw into the stencil buffer\r\n\r\n    renderer.render(this.scene, this.camera, readBuffer, this.clear);\r\n    renderer.render(this.scene, this.camera, writeBuffer, this.clear);\r\n\r\n    // re-enable update of color and depth\r\n\r\n    context.colorMask(true, true, true, true);\r\n    context.depthMask(true);\r\n\r\n    // only render where stencil is set to 1\r\n\r\n    context.stencilFunc(context.EQUAL, 1, 0xffffffff);  // draw if == 1\r\n    context.stencilOp(context.KEEP, context.KEEP, context.KEEP);\r\n\r\n  }\r\n\r\n};\r\n\r\n\r\nTHREE.ClearMaskPass = function () {\r\n\r\n  this.enabled = true;\r\n\r\n};\r\n\r\nTHREE.ClearMaskPass.prototype = {\r\n\r\n  render: function (renderer, writeBuffer, readBuffer, delta) {\r\n\r\n    var context = renderer.context;\r\n\r\n    context.disable(context.STENCIL_TEST);\r\n\r\n  }\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/postprocessing/MaskPass.js\n// module id = ./src/app/shared/lib/gcode/js/postprocessing/MaskPass.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {\r\n\r\n  this.scene = scene;\r\n  this.camera = camera;\r\n\r\n  this.overrideMaterial = overrideMaterial;\r\n\r\n  this.clearColor = clearColor;\r\n  this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 1;\r\n\r\n  this.oldClearColor = new THREE.Color();\r\n  this.oldClearAlpha = 1;\r\n\r\n  this.enabled = true;\r\n  this.clear = true;\r\n  this.needsSwap = false;\r\n\r\n};\r\n\r\nTHREE.RenderPass.prototype = {\r\n\r\n  render: function (renderer, writeBuffer, readBuffer, delta) {\r\n\r\n    this.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n    if (this.clearColor) {\r\n\r\n      this.oldClearColor.copy(renderer.getClearColor());\r\n      this.oldClearAlpha = renderer.getClearAlpha();\r\n\r\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\r\n\r\n    }\r\n\r\n    renderer.render(this.scene, this.camera, readBuffer, this.clear);\r\n\r\n    if (this.clearColor) {\r\n\r\n      renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\r\n\r\n    }\r\n\r\n    this.scene.overrideMaterial = null;\r\n\r\n  }\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/postprocessing/RenderPass.js\n// module id = ./src/app/shared/lib/gcode/js/postprocessing/RenderPass.js\n// module chunks = main","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShaderPass = function (shader, textureID) {\r\n\r\n  this.textureID = (textureID !== undefined) ? textureID : \"tDiffuse\";\r\n\r\n  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\r\n\r\n  this.material = new THREE.ShaderMaterial({\r\n\r\n    uniforms: this.uniforms,\r\n    vertexShader: shader.vertexShader,\r\n    fragmentShader: shader.fragmentShader\r\n\r\n  });\r\n\r\n  this.renderToScreen = false;\r\n\r\n  this.enabled = true;\r\n  this.needsSwap = true;\r\n  this.clear = false;\r\n\r\n};\r\n\r\nTHREE.ShaderPass.prototype = {\r\n\r\n  render: function (renderer, writeBuffer, readBuffer, delta) {\r\n\r\n    if (this.uniforms[this.textureID]) {\r\n\r\n      this.uniforms[this.textureID].value = readBuffer;\r\n\r\n    }\r\n\r\n    THREE.EffectComposer.quad.material = this.material;\r\n\r\n    if (this.renderToScreen) {\r\n\r\n      renderer.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera);\r\n\r\n    } else {\r\n\r\n      renderer.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear);\r\n\r\n    }\r\n\r\n  }\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/js/postprocessing/ShaderPass.js\n// module id = ./src/app/shared/lib/gcode/js/postprocessing/ShaderPass.js\n// module chunks = main","/**\n * @author mrdoob / http://mrdoob.com/\n * @author Larry Battle / http://bateru.com/news\n */\n\nvar THREE = THREE || { REVISION: '53dev' };\n\nself.console = self.console || {\n\n\tinfo: function () {},\n\tlog: function () {},\n\tdebug: function () {},\n\twarn: function () {},\n\terror: function () {}\n\n};\n\nself.Int32Array = self.Int32Array || Array;\nself.Float32Array = self.Float32Array || Array;\n\n// Shims for \"startsWith\", \"endsWith\", and \"trim\" for browsers where this is not yet implemented\n// not sure we should have this, or at least not have it here\n\n// http://stackoverflow.com/questions/646628/javascript-startswith\n// http://stackoverflow.com/questions/498970/how-do-i-trim-a-string-in-javascript\n// http://wiki.ecmascript.org/doku.php?id=harmony%3astring_extras\n\nString.prototype.startsWith = String.prototype.startsWith || function ( str ) {\n\n\treturn this.slice( 0, str.length ) === str;\n\n};\n\nString.prototype.endsWith = String.prototype.endsWith || function ( str ) {\n\n\tvar t = String( str );\n\tvar index = this.lastIndexOf( t );\n\treturn ( -1 < index && index ) === (this.length - t.length);\n\n};\n\nString.prototype.trim = String.prototype.trim || function () {\n\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\n\n};\n\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller\n// fixes from Paul Irish and Tino Zijdel\n\n( function () {\n\n\tvar lastTime = 0;\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n\n\tfor ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {\n\n\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\twindow.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\n\n\t}\n\n\tif ( window.requestAnimationFrame === undefined ) {\n\n\t\twindow.requestAnimationFrame = function ( callback, element ) {\n\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\tvar id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\n\t\t};\n\n\t}\n\n\twindow.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };\n\n}() );\n\n\n// MATERIAL CONSTANTS\n\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n\n// shading\n\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n\n// colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n\n// blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\n\n// custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n\n// custom blending source factors\n\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n\n\n// TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\n\n// Mapping modes\n\nTHREE.UVMapping = function () {};\n\nTHREE.CubeReflectionMapping = function () {};\nTHREE.CubeRefractionMapping = function () {};\n\nTHREE.SphericalReflectionMapping = function () {};\nTHREE.SphericalRefractionMapping = function () {};\n\n// Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n\n// Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n\n// Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\n\n// Pixel types\n\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n\n// Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n\n// Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n\n/*\n// Potential future PVRTC compressed texture formats\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n*/\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype.start = function () {\n\n\tthis.startTime = Date.now();\n\tthis.oldTime = this.startTime;\n\n\tthis.running = true;\n\n};\n\nTHREE.Clock.prototype.stop = function () {\n\n\tthis.getElapsedTime();\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype.getElapsedTime = function () {\n\n\tthis.elapsedTime += this.getDelta();\n\n\treturn this.elapsedTime;\n\n};\n\n\nTHREE.Clock.prototype.getDelta = function () {\n\n\tvar diff = 0;\n\n\tif ( this.autoStart && ! this.running ) {\n\n\t\tthis.start();\n\n\t}\n\n\tif ( this.running ) {\n\n\t\tvar newTime = Date.now();\n\t\tdiff = 0.001 * ( newTime - this.oldTime );\n\t\tthis.oldTime = newTime;\n\n\t\tthis.elapsedTime += diff;\n\n\t}\n\n\treturn diff;\n\n};/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( hex ) {\n\n\tif ( hex !== undefined ) this.setHex( hex );\n\n\treturn this;\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color ) {\n\n\t\tthis.r = color.r * color.r;\n\t\tthis.g = color.g * color.g;\n\t\tthis.b = color.b * color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color ) {\n\n\t\tthis.r = Math.sqrt( color.r );\n\t\tthis.g = Math.sqrt( color.g );\n\t\tthis.b = Math.sqrt( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSV: function ( h, s, v ) {\n\n\t\t// based on MochiKit implementation by Bob Ippolito\n\t\t// h,s,v ranges are < 0.0 - 1.0 >\n\n\t\tvar i, f, p, q, t;\n\n\t\tif ( v === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = 0;\n\n\t\t} else {\n\n\t\t\ti = Math.floor( h * 6 );\n\t\t\tf = ( h * 6 ) - i;\n\t\t\tp = v * ( 1 - s );\n\t\t\tq = v * ( 1 - ( s * f ) );\n\t\t\tt = v * ( 1 - ( s * ( 1 - f ) ) );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tthis.r = v;\n\t\t\t\tthis.g = t;\n\t\t\t\tthis.b = p;\n\n\t\t\t} else if ( i === 1 ) {\n\n\t\t\t\tthis.r = q;\n\t\t\t\tthis.g = v;\n\t\t\t\tthis.b = p;\n\n\t\t\t} else if ( i === 2 ) {\n\n\t\t\t\tthis.r = p;\n\t\t\t\tthis.g = v;\n\t\t\t\tthis.b = t;\n\n\t\t\t} else if ( i === 3 ) {\n\n\t\t\t\tthis.r = p;\n\t\t\t\tthis.g = q;\n\t\t\t\tthis.b = v;\n\n\t\t\t} else if ( i === 4 ) {\n\n\t\t\t\tthis.r = t;\n\t\t\t\tthis.g = p;\n\t\t\t\tthis.b = v;\n\n\t\t\t} else if ( i === 5 ) {\n\n\t\t\t\tthis.r = v;\n\t\t\t\tthis.g = p;\n\t\t\t\tthis.b = q;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tlerpSelf: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetContextStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 )  + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddSelf: function ( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubSelf: function ( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\n\t\t} else {\n\n\t\t\tthis.set( 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.lengthSq() );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\treturn this.normalize().multiplyScalar( l );\n\n\t},\n\n\tlerpSelf: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tisZero: function ( v ) {\n\n\t\treturn this.lengthSq() < ( v !== undefined ? v : 0.0001 );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector2( this.x, this.y );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddSelf: function ( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubSelf: function ( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplySelf: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\tthis.z *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideSelf: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\t\t\tthis.z /= s;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.lengthSq() );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\treturn this.normalize().multiplyScalar( l );\n\n\t},\n\n\tlerpSelf: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tcross: function ( a, b ) {\n\n\t\tthis.x = a.y * b.z - a.z * b.y;\n\t\tthis.y = a.z * b.x - a.x * b.z;\n\t\tthis.z = a.x * b.y - a.y * b.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossSelf: function ( v ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tangleTo: function ( v ) {\n\n\t\treturn Math.acos( this.dot( v ) / this.length() / v.length() );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\treturn new THREE.Vector3().sub( this, v ).lengthSq();\n\n\t},\n\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tthis.x = m.elements[12];\n\t\tthis.y = m.elements[13];\n\t\tthis.z = m.elements[14];\n\n\t\treturn this;\n\n\t},\n\n\tsetEulerFromRotationMatrix: function ( m, order ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.y = Math.asin( clamp( m13 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\n\t\t\t\tthis.z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis.x = Math.asin( - clamp( m23 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\n\t\t\t\tthis.z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = Math.asin( clamp( m32 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis.y = Math.atan2( - m31, m33 );\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.y = Math.asin( - clamp( m31 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( m32, m33 );\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.z = Math.asin( clamp( m21 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m22 );\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.z = Math.asin( - clamp( m12 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\n\t\t\t\tthis.y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetEulerFromQuaternion: function ( q, order ) {\n\n\t\t// q is assumed to be normalized\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\n\t\tvar sqx = q.x * q.x;\n\t\tvar sqy = q.y * q.y;\n\t\tvar sqz = q.z * q.z;\n\t\tvar sqw = q.w * q.w;\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order ===  'YXZ' ) {\n\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tvar sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();\n\t\tvar sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();\n\t\tvar sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tisZero: function ( v ) {\n\n\t\treturn this.lengthSq() < ( v !== undefined ? v : 0.0001 );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t}\n\n};\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddSelf: function ( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubSelf: function ( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\t\tthis.z *= s;\n\t\tthis.w *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( s ) {\n\n\t\tif ( s ) {\n\n\t\t\tthis.x /= s;\n\t\t\tthis.y /= s;\n\t\t\tthis.z /= s;\n\t\t\tthis.w /= s;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 1;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( -1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.dot( this );\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.lengthSq() );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\treturn this.normalize().multiplyScalar( l );\n\n\t},\n\n\tlerpSelf: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array(9);\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tgetInverse: function ( matrix ) {\n\n\t\t// input: THREE.Matrix4\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\n\n        var me = matrix.elements;\n\n\t\tvar a11 =   me[10] * me[5] - me[6] * me[9];\n\t\tvar a21 = - me[10] * me[1] + me[2] * me[9];\n\t\tvar a31 =   me[6] * me[1] - me[2] * me[5];\n\t\tvar a12 = - me[10] * me[4] + me[6] * me[8];\n\t\tvar a22 =   me[10] * me[0] - me[2] * me[8];\n\t\tvar a32 = - me[6] * me[0] + me[2] * me[4];\n\t\tvar a13 =   me[9] * me[4] - me[5] * me[8];\n\t\tvar a23 = - me[9] * me[0] + me[1] * me[8];\n\t\tvar a33 =   me[5] * me[0] - me[1] * me[4];\n\n\t\tvar det = me[0] * a11 + me[1] * a12 + me[2] * a13;\n\n\t\t// no inverse\n\n\t\tif ( det === 0 ) {\n\n\t\t\tconsole.warn( \"Matrix3.getInverse(): determinant == 0\" );\n\n\t\t}\n\n\t\tvar idet = 1.0 / det;\n\n\t\tvar m = this.elements;\n\n\t\tm[ 0 ] = idet * a11; m[ 1 ] = idet * a21; m[ 2 ] = idet * a31;\n\t\tm[ 3 ] = idet * a12; m[ 4 ] = idet * a22; m[ 5 ] = idet * a32;\n\t\tm[ 6 ] = idet * a13; m[ 7 ] = idet * a23; m[ 8 ] = idet * a33;\n\n\t\treturn this;\n\n\t},\n\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.m;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n */\n\n\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\tthis.elements = new Float32Array( 16 );\n\n\tthis.set(\n\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0, n14 || 0,\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0, n24 || 0,\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1, n34 || 0,\n\t\tn41 || 0, n42 || 0, n43 || 0, ( n44 !== undefined ) ? n44 : 1\n\n\t);\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[0], me[4], me[8], me[12],\n\t\t\tme[1], me[5], me[9], me[13],\n\t\t\tme[2], me[6], me[10], me[14],\n\t\t\tme[3], me[7], me[11], me[15]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( eye, target, up ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = THREE.Matrix4.__v1;\n\t\tvar y = THREE.Matrix4.__v2;\n\t\tvar z = THREE.Matrix4.__v3;\n\n\t\tz.sub( eye, target ).normalize();\n\n\t\tif ( z.length() === 0 ) {\n\n\t\t\tz.z = 1;\n\n\t\t}\n\n\t\tx.cross( up, z ).normalize();\n\n\t\tif ( x.length() === 0 ) {\n\n\t\t\tz.x += 0.0001;\n\t\t\tx.cross( up, z ).normalize();\n\n\t\t}\n\n\t\ty.cross( z, x );\n\n\n\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\n\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\n\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplySelf: function ( m ) {\n\n\t\treturn this.multiply( this, m );\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiply( a, b );\n\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar vx = v.x, vy = v.y, vz = v.z;\n\t\tvar d = 1 / ( te[3] * vx + te[7] * vy + te[11] * vz + te[15] );\n\n\t\tv.x = ( te[0] * vx + te[4] * vy + te[8] * vz + te[12] ) * d;\n\t\tv.y = ( te[1] * vx + te[5] * vy + te[9] * vz + te[13] ) * d;\n\t\tv.z = ( te[2] * vx + te[6] * vy + te[10] * vz + te[14] ) * d;\n\n\t\treturn v;\n\n\t},\n\n\tmultiplyVector4: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar vx = v.x, vy = v.y, vz = v.z, vw = v.w;\n\n\t\tv.x = te[0] * vx + te[4] * vy + te[8] * vz + te[12] * vw;\n\t\tv.y = te[1] * vx + te[5] * vy + te[9] * vz + te[13] * vw;\n\t\tv.z = te[2] * vx + te[6] * vy + te[10] * vz + te[14] * vw;\n\t\tv.w = te[3] * vx + te[7] * vy + te[11] * vz + te[15] * vw;\n\n\t\treturn v;\n\n\t},\n\n\tmultiplyVector3Array: function ( a ) {\n\n\t\tvar tmp = THREE.Matrix4.__v1;\n\n\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\ttmp.x = a[ i ];\n\t\t\ttmp.y = a[ i + 1 ];\n\t\t\ttmp.z = a[ i + 2 ];\n\n\t\t\tthis.multiplyVector3( tmp );\n\n\t\t\ta[ i ]     = tmp.x;\n\t\t\ta[ i + 1 ] = tmp.y;\n\t\t\ta[ i + 2 ] = tmp.z;\n\n\t\t}\n\n\t\treturn a;\n\n\t},\n\n\trotateAxis: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar vx = v.x, vy = v.y, vz = v.z;\n\n\t\tv.x = vx * te[0] + vy * te[4] + vz * te[8];\n\t\tv.y = vx * te[1] + vy * te[5] + vz * te[9];\n\t\tv.z = vx * te[2] + vy * te[6] + vz * te[10];\n\n\t\tv.normalize();\n\n\t\treturn v;\n\n\t},\n\n\tcrossVector: function ( a ) {\n\n\t\tvar te = this.elements;\n\t\tvar v = new THREE.Vector4();\n\n\t\tv.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;\n\t\tv.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;\n\t\tv.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;\n\n\t\tv.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;\n\n\t\treturn v;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn14 * n23 * n32 * n41-\n\t\t\tn13 * n24 * n32 * n41-\n\t\t\tn14 * n22 * n33 * n41+\n\t\t\tn12 * n24 * n33 * n41+\n\n\t\t\tn13 * n22 * n34 * n41-\n\t\t\tn12 * n23 * n34 * n41-\n\t\t\tn14 * n23 * n31 * n42+\n\t\t\tn13 * n24 * n31 * n42+\n\n\t\t\tn14 * n21 * n33 * n42-\n\t\t\tn11 * n24 * n33 * n42-\n\t\t\tn13 * n21 * n34 * n42+\n\t\t\tn11 * n23 * n34 * n42+\n\n\t\t\tn14 * n22 * n31 * n43-\n\t\t\tn12 * n24 * n31 * n43-\n\t\t\tn14 * n21 * n32 * n43+\n\t\t\tn11 * n24 * n32 * n43+\n\n\t\t\tn12 * n21 * n34 * n43-\n\t\t\tn11 * n22 * n34 * n43-\n\t\t\tn13 * n22 * n31 * n44+\n\t\t\tn12 * n23 * n31 * n44+\n\n\t\t\tn13 * n21 * n32 * n44-\n\t\t\tn11 * n23 * n32 * n44-\n\t\t\tn12 * n21 * n33 * n44+\n\t\t\tn11 * n22 * n33 * n44\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\n\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArray: function ( flat ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\n\t\tflat[ 8 ]  = te[8]; flat[ 9 ]  = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tflattenToArrayOffset: function( flat, offset ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ offset ] = te[0];\n\t\tflat[ offset + 1 ] = te[1];\n\t\tflat[ offset + 2 ] = te[2];\n\t\tflat[ offset + 3 ] = te[3];\n\n\t\tflat[ offset + 4 ] = te[4];\n\t\tflat[ offset + 5 ] = te[5];\n\t\tflat[ offset + 6 ] = te[6];\n\t\tflat[ offset + 7 ] = te[7];\n\n\t\tflat[ offset + 8 ]  = te[8];\n\t\tflat[ offset + 9 ]  = te[9];\n\t\tflat[ offset + 10 ] = te[10];\n\t\tflat[ offset + 11 ] = te[11];\n\n\t\tflat[ offset + 12 ] = te[12];\n\t\tflat[ offset + 13 ] = te[13];\n\t\tflat[ offset + 14 ] = te[14];\n\t\tflat[ offset + 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar te = this.elements;\n\t\treturn THREE.Matrix4.__v1.set( te[12], te[13], te[14] );\n\n\t},\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[12] = v.x;\n\t\tte[13] = v.y;\n\t\tte[14] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetColumnX: function () {\n\n\t\tvar te = this.elements;\n\t\treturn THREE.Matrix4.__v1.set( te[0], te[1], te[2] );\n\n\t},\n\n\tgetColumnY: function () {\n\n\t\tvar te = this.elements;\n\t\treturn THREE.Matrix4.__v1.set( te[4], te[5], te[6] );\n\n\t},\n\n\tgetColumnZ: function() {\n\n\t\tvar te = this.elements;\n\t\treturn THREE.Matrix4.__v1.set( te[8], te[9], te[10] );\n\n\t},\n\n\tgetInverse: function ( m ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\n\t\tthis.multiplyScalar( 1 / m.determinant() );\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromEuler: function ( v, order ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = v.x, y = v.y, z = v.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - c * f;\n\t\t\tte[8] = d;\n\n\t\t\tte[1] = af + be * d;\n\t\t\tte[5] = ae - bf * d;\n\t\t\tte[9] = - b * c;\n\n\t\t\tte[2] = bf - ae * d;\n\t\t\tte[6] = be + af * d;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce + df * b;\n\t\t\tte[4] = de * b - cf;\n\t\t\tte[8] = a * d;\n\n\t\t\tte[1] = a * f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b;\n\n\t\t\tte[2] = cf * b - de;\n\t\t\tte[6] = df + ce * b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce - df * b;\n\t\t\tte[4] = - a * f;\n\t\t\tte[8] = de + cf * b;\n\n\t\t\tte[1] = cf + de * b;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = df - ce * b;\n\n\t\t\tte[2] = - a * d;\n\t\t\tte[6] = b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = be * d - af;\n\t\t\tte[8] = ae * d + bf;\n\n\t\t\tte[1] = c * f;\n\t\t\tte[5] = bf * d + ae;\n\t\t\tte[9] = af * d - be;\n\n\t\t\tte[2] = - d;\n\t\t\tte[6] = b * c;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = bd - ac * f;\n\t\t\tte[8] = bc * f + ad;\n\n\t\t\tte[1] = f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b * e;\n\n\t\t\tte[2] = - d * e;\n\t\t\tte[6] = ad * f + bc;\n\t\t\tte[10] = ac - bd * f;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - f;\n\t\t\tte[8] = d * e;\n\n\t\t\tte[1] = ac * f + bd;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = ad * f - bc;\n\n\t\t\tte[2] = bc * f - ad;\n\t\t\tte[6] = b * e;\n\t\t\tte[10] = bd * f + ac;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[0] = 1 - ( yy + zz );\n\t\tte[4] = xy - wz;\n\t\tte[8] = xz + wy;\n\n\t\tte[1] = xy + wz;\n\t\tte[5] = 1 - ( xx + zz );\n\t\tte[9] = yz - wx;\n\n\t\tte[2] = xz - wy;\n\t\tte[6] = yz + wx;\n\t\tte[10] = 1 - ( xx + yy );\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( translation, rotation, scale ) {\n\n\t\tvar te = this.elements;\n\t\tvar mRotation = THREE.Matrix4.__m1;\n\t\tvar mScale = THREE.Matrix4.__m2;\n\n\t\tmRotation.identity();\n\t\tmRotation.setRotationFromQuaternion( rotation );\n\n\t\tmScale.makeScale( scale.x, scale.y, scale.z );\n\n\t\tthis.multiply( mRotation, mScale );\n\n\t\tte[12] = translation.x;\n\t\tte[13] = translation.y;\n\t\tte[14] = translation.z;\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function ( translation, rotation, scale ) {\n\n\t\tvar te = this.elements;\n\n\t\t// grab the axis vectors\n\t\tvar x = THREE.Matrix4.__v1;\n\t\tvar y = THREE.Matrix4.__v2;\n\t\tvar z = THREE.Matrix4.__v3;\n\n\t\tx.set( te[0], te[1], te[2] );\n\t\ty.set( te[4], te[5], te[6] );\n\t\tz.set( te[8], te[9], te[10] );\n\n\t\ttranslation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();\n\t\trotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();\n\t\tscale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();\n\n\t\tscale.x = x.length();\n\t\tscale.y = y.length();\n\t\tscale.z = z.length();\n\n\t\ttranslation.x = te[12];\n\t\ttranslation.y = te[13];\n\t\ttranslation.z = te[14];\n\n\t\t// scale the rotation part\n\n\t\tvar matrix = THREE.Matrix4.__m1;\n\n\t\tmatrix.copy( this );\n\n\t\tmatrix.elements[0] /= scale.x;\n\t\tmatrix.elements[1] /= scale.x;\n\t\tmatrix.elements[2] /= scale.x;\n\n\t\tmatrix.elements[4] /= scale.y;\n\t\tmatrix.elements[5] /= scale.y;\n\t\tmatrix.elements[6] /= scale.y;\n\n\t\tmatrix.elements[8] /= scale.z;\n\t\tmatrix.elements[9] /= scale.z;\n\t\tmatrix.elements[10] /= scale.z;\n\n\t\trotation.setFromRotationMatrix( matrix );\n\n\t\treturn [ translation, rotation, scale ];\n\n\t},\n\n\textractPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[12] = me[12];\n\t\tte[13] = me[13];\n\t\tte[14] = me[14];\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tvar vector = THREE.Matrix4.__v1;\n\n\t\tvar scaleX = 1 / vector.set( me[0], me[1], me[2] ).length();\n\t\tvar scaleY = 1 / vector.set( me[4], me[5], me[6] ).length();\n\t\tvar scaleZ = 1 / vector.set( me[8], me[9], me[10] ).length();\n\n\t\tte[0] = me[0] * scaleX;\n\t\tte[1] = me[1] * scaleX;\n\t\tte[2] = me[2] * scaleX;\n\n\t\tte[4] = me[4] * scaleY;\n\t\tte[5] = me[5] * scaleY;\n\t\tte[6] = me[6] * scaleY;\n\n\t\tte[8] = me[8] * scaleZ;\n\t\tte[9] = me[9] * scaleZ;\n\t\tte[10] = me[10] * scaleZ;\n\n\t\treturn this;\n\n\t},\n\n\t//\n\n\ttranslate: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[12] = te[0] * x + te[4] * y + te[8] * z + te[12];\n\t\tte[13] = te[1] * x + te[5] * y + te[9] * z + te[13];\n\t\tte[14] = te[2] * x + te[6] * y + te[10] * z + te[14];\n\t\tte[15] = te[3] * x + te[7] * y + te[11] * z + te[15];\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m12 = te[4];\n\t\tvar m22 = te[5];\n\t\tvar m32 = te[6];\n\t\tvar m42 = te[7];\n\t\tvar m13 = te[8];\n\t\tvar m23 = te[9];\n\t\tvar m33 = te[10];\n\t\tvar m43 = te[11];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[4] = c * m12 + s * m13;\n\t\tte[5] = c * m22 + s * m23;\n\t\tte[6] = c * m32 + s * m33;\n\t\tte[7] = c * m42 + s * m43;\n\n\t\tte[8] = c * m13 - s * m12;\n\t\tte[9] = c * m23 - s * m22;\n\t\tte[10] = c * m33 - s * m32;\n\t\tte[11] = c * m43 - s * m42;\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m11 = te[0];\n\t\tvar m21 = te[1];\n\t\tvar m31 = te[2];\n\t\tvar m41 = te[3];\n\t\tvar m13 = te[8];\n\t\tvar m23 = te[9];\n\t\tvar m33 = te[10];\n\t\tvar m43 = te[11];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[0] = c * m11 - s * m13;\n\t\tte[1] = c * m21 - s * m23;\n\t\tte[2] = c * m31 - s * m33;\n\t\tte[3] = c * m41 - s * m43;\n\n\t\tte[8] = c * m13 + s * m11;\n\t\tte[9] = c * m23 + s * m21;\n\t\tte[10] = c * m33 + s * m31;\n\t\tte[11] = c * m43 + s * m41;\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\tvar te = this.elements;\n\t\tvar m11 = te[0];\n\t\tvar m21 = te[1];\n\t\tvar m31 = te[2];\n\t\tvar m41 = te[3];\n\t\tvar m12 = te[4];\n\t\tvar m22 = te[5];\n\t\tvar m32 = te[6];\n\t\tvar m42 = te[7];\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\n\t\tte[0] = c * m11 + s * m12;\n\t\tte[1] = c * m21 + s * m22;\n\t\tte[2] = c * m31 + s * m32;\n\t\tte[3] = c * m41 + s * m42;\n\n\t\tte[4] = c * m12 - s * m11;\n\t\tte[5] = c * m22 - s * m21;\n\t\tte[6] = c * m32 - s * m31;\n\t\tte[7] = c * m42 - s * m41;\n\n\t\treturn this;\n\n\t},\n\n\trotateByAxis: function ( axis, angle ) {\n\n\t\tvar te = this.elements;\n\n\t\t// optimize by checking axis\n\n\t\tif ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {\n\n\t\t\treturn this.rotateX( angle );\n\n\t\t} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {\n\n\t\t\treturn this.rotateY( angle );\n\n\t\t} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {\n\n\t\t\treturn this.rotateZ( angle );\n\n\t\t}\n\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar n = Math.sqrt(x * x + y * y + z * z);\n\n\t\tx /= n;\n\t\ty /= n;\n\t\tz /= n;\n\n\t\tvar xx = x * x, yy = y * y, zz = z * z;\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar oneMinusCosine = 1 - c;\n\t\tvar xy = x * y * oneMinusCosine;\n\t\tvar xz = x * z * oneMinusCosine;\n\t\tvar yz = y * z * oneMinusCosine;\n\t\tvar xs = x * s;\n\t\tvar ys = y * s;\n\t\tvar zs = z * s;\n\n\t\tvar r11 = xx + (1 - xx) * c;\n\t\tvar r21 = xy + zs;\n\t\tvar r31 = xz - ys;\n\t\tvar r12 = xy - zs;\n\t\tvar r22 = yy + (1 - yy) * c;\n\t\tvar r32 = yz + xs;\n\t\tvar r13 = xz + ys;\n\t\tvar r23 = yz - xs;\n\t\tvar r33 = zz + (1 - zz) * c;\n\n\t\tvar m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];\n\t\tvar m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];\n\t\tvar m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];\n\t\tvar m14 = te[12], m24 = te[13], m34 = te[14], m44 = te[15];\n\n\t\tte[0] = r11 * m11 + r21 * m12 + r31 * m13;\n\t\tte[1] = r11 * m21 + r21 * m22 + r31 * m23;\n\t\tte[2] = r11 * m31 + r21 * m32 + r31 * m33;\n\t\tte[3] = r11 * m41 + r21 * m42 + r31 * m43;\n\n\t\tte[4] = r12 * m11 + r22 * m12 + r32 * m13;\n\t\tte[5] = r12 * m21 + r22 * m22 + r32 * m23;\n\t\tte[6] = r12 * m31 + r22 * m32 + r32 * m33;\n\t\tte[7] = r12 * m41 + r22 * m42 + r32 * m43;\n\n\t\tte[8] = r13 * m11 + r23 * m12 + r33 * m13;\n\t\tte[9] = r13 * m21 + r23 * m22 + r33 * m23;\n\t\tte[10] = r13 * m31 + r23 * m32 + r33 * m33;\n\t\tte[11] = r13 * m41 + r23 * m42 + r33 * m43;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq =  te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\tvar scaleYSq =  te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\tvar scaleZSq =  te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\n\n\t},\n\n\t//\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, -s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t-s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, -s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[0] = x;  te[4] = 0;  te[8] = a;   te[12] = 0;\n\t\tte[1] = 0;  te[5] = y;  te[9] = b;   te[13] = 0;\n\t\tte[2] = 0;  te[6] = 0;  te[10] = c;   te[14] = d;\n\t\tte[3] = 0;  te[7] = 0;  te[11] = - 1; te[15] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( fov * Math.PI / 360 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = right - left;\n\t\tvar h = top - bottom;\n\t\tvar p = far - near;\n\n\t\tvar x = ( right + left ) / w;\n\t\tvar y = ( top + bottom ) / h;\n\t\tvar z = ( far + near ) / p;\n\n\t\tte[0] = 2 / w; te[4] = 0;     te[8] = 0;      te[12] = -x;\n\t\tte[1] = 0;     te[5] = 2 / h; te[9] = 0;      te[13] = -y;\n\t\tte[2] = 0;     te[6] = 0;     te[10] = -2 / p; te[14] = -z;\n\t\tte[3] = 0;     te[7] = 0;     te[11] = 0;      te[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix4(\n\n\t\t\tte[0], te[4], te[8], te[12],\n\t\t\tte[1], te[5], te[9], te[13],\n\t\t\tte[2], te[6], te[10], te[14],\n\t\t\tte[3], te[7], te[11], te[15]\n\n\t\t);\n\n\t}\n\n};\n\nTHREE.Matrix4.__v1 = new THREE.Vector3();\nTHREE.Matrix4.__v2 = new THREE.Vector3();\nTHREE.Matrix4.__v3 = new THREE.Vector3();\n\nTHREE.Matrix4.__m1 = new THREE.Matrix4();\nTHREE.Matrix4.__m2 = new THREE.Matrix4();\n/**\n * https://github.com/mrdoob/eventtarget.js/\n */\n\nTHREE.EventTarget = function () {\n\n\tvar listeners = {};\n\n\tthis.addEventListener = function ( type, listener ) {\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t};\n\n\tthis.dispatchEvent = function ( event ) {\n\n\t\tfor ( var listener in listeners[ event.type ] ) {\n\n\t\t\tlisteners[ event.type ][ listener ]( event );\n\n\t\t}\n\n\t};\n\n\tthis.removeEventListener = function ( type, listener ) {\n\n\t\tvar index = listeners[ type ].indexOf( listener );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tlisteners[ type ].splice( index, 1 );\n\n\t\t}\n\n\t};\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Frustum = function ( ) {\n\n\tthis.planes = [\n\n\t\tnew THREE.Vector4(),\n\t\tnew THREE.Vector4(),\n\t\tnew THREE.Vector4(),\n\t\tnew THREE.Vector4(),\n\t\tnew THREE.Vector4(),\n\t\tnew THREE.Vector4()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype.setFromMatrix = function ( m ) {\n\n\tvar plane;\n\tvar planes = this.planes;\n\n\tvar me = m.elements;\n\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n\n\tplanes[ 0 ].set( me3 - me0, me7 - me4, me11 - me8, me15 - me12 );\n\tplanes[ 1 ].set( me3 + me0, me7 + me4, me11 + me8, me15 + me12 );\n\tplanes[ 2 ].set( me3 + me1, me7 + me5, me11 + me9, me15 + me13 );\n\tplanes[ 3 ].set( me3 - me1, me7 - me5, me11 - me9, me15 - me13 );\n\tplanes[ 4 ].set( me3 - me2, me7 - me6, me11 - me10, me15 - me14 );\n\tplanes[ 5 ].set( me3 + me2, me7 + me6, me11 + me10, me15 + me14 );\n\n\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\tplane = planes[ i ];\n\t\tplane.divideScalar( Math.sqrt( plane.x * plane.x + plane.y * plane.y + plane.z * plane.z ) );\n\n\t}\n\n};\n\nTHREE.Frustum.prototype.contains = function ( object ) {\n\n\tvar distance = 0.0;\n\tvar planes = this.planes;\n\tvar matrix = object.matrixWorld;\n\tvar me = matrix.elements;\n\tvar radius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();\n\n\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\tdistance = planes[ i ].x * me[12] + planes[ i ].y * me[13] + planes[ i ].z * me[14] + planes[ i ].w;\n\t\tif ( distance <= radius ) return false;\n\n\t}\n\n\treturn true;\n\n};\n\nTHREE.Frustum.__v1 = new THREE.Vector3();\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Ray = function ( origin, direction, near, far ) {\n\n\t\tthis.origin = origin || new THREE.Vector3();\n\t\tthis.direction = direction || new THREE.Vector3();\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t};\n\n\tvar originCopy = new THREE.Vector3();\n\n\tvar localOriginCopy = new THREE.Vector3();\n\tvar localDirectionCopy = new THREE.Vector3();\n\n\tvar vector = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar intersectPoint = new THREE.Vector3();\n\n\tvar inverseMatrix = new THREE.Matrix4();\n\n\tvar descSort = function ( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t};\n\n\tvar v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3();\n\n\tvar distanceFromIntersection = function ( origin, direction, position ) {\n\n\t\tv0.sub( position, origin );\n\n\t\tvar dot = v0.dot( direction );\n\n\t\tvar intersect = v1.add( origin, v2.copy( direction ).multiplyScalar( dot ) );\n\t\tvar distance = position.distanceTo( intersect );\n\n\t\treturn distance;\n\n\t};\n\n\t// http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\tvar pointInFace3 = function ( p, a, b, c ) {\n\n\t\tv0.sub( c, a );\n\t\tv1.sub( b, a );\n\t\tv2.sub( p, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar invDenom = 1 / ( dot00 * dot11 - dot01 * dot01 );\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\treturn ( u >= 0 ) && ( v >= 0 ) && ( u + v < 1 );\n\n\t};\n\n\tvar intersectObject = function ( object, ray, intersects ) {\n\n\t\tvar distance,intersect;\n\n\t\tif ( object instanceof THREE.Particle ) {\n\n\t\t\tdistance = distanceFromIntersection( ray.origin, ray.direction, object.matrixWorld.getPosition() );\n\n\t\t\tif ( distance > object.scale.x ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tintersect = {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: object.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\n\t\t\t};\n\n\t\t\tintersects.push( intersect );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t// Checking boundingSphere\n\n\t\t\tvar scaledRadius = object.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis();\n\n\t\t\t// Checking distance to ray\n\n\t\t\tdistance = distanceFromIntersection( ray.origin, ray.direction, object.matrixWorld.getPosition() );\n\n\t\t\tif ( distance > scaledRadius) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\t// Checking faces\n\n\t\t\tvar f, fl, face, dot, scalar,\n\t\t\tgeometry = object.geometry,\n\t\t\tvertices = geometry.vertices,\n\t\t\tobjMatrix, geometryMaterials,\n\t\t\tisFaceMaterial, material, side, point;\n\n\t\t\tgeometryMaterials = object.geometry.materials;\n\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\tside = object.material.side;\n\n\t\t\tvar a, b, c, d;\n\t\t\tvar precision = ray.precision;\n\n\t\t\tobject.matrixRotationWorld.extractRotation( object.matrixWorld );\n\n\t\t\toriginCopy.copy( ray.origin );\n\n\t\t\tobjMatrix = object.matrixWorld;\n\t\t\tinverseMatrix.getInverse( objMatrix );\n\n\t\t\tlocalOriginCopy.copy( originCopy );\n\t\t\tinverseMatrix.multiplyVector3( localOriginCopy );\n\n\t\t\tlocalDirectionCopy.copy( ray.direction );\n\t\t\tinverseMatrix.rotateAxis( localDirectionCopy ).normalize();\n\n\t\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = geometry.faces[ f ];\n\n\t\t\t\tmaterial = isFaceMaterial === true ? geometryMaterials[ face.materialIndex ] : object.material;\n\t\t\t\tif ( material === undefined ) continue;\n\t\t\t\tside = material.side;\n\n\t\t\t\tvector.sub( face.centroid, localOriginCopy );\n\t\t\t\tnormal = face.normal;\n\t\t\t\tdot = localDirectionCopy.dot( normal );\n\n\t\t\t\t// bail if ray and plane are parallel\n\n\t\t\t\tif ( Math.abs( dot ) < precision ) continue;\n\n\t\t\t\t// calc distance to plane\n\n\t\t\t\tscalar = normal.dot( vector ) / dot;\n\n\t\t\t\t// if negative distance, then plane is behind ray\n\n\t\t\t\tif ( scalar < 0 ) continue;\n\n\t\t\t\tif ( side === THREE.DoubleSide || ( side === THREE.FrontSide ? dot < 0 : dot > 0 ) ) {\n\n\t\t\t\t\tintersectPoint.add( localOriginCopy, localDirectionCopy.multiplyScalar( scalar ) );\n\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\t\tc = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( pointInFace3( intersectPoint, a, b, c ) ) {\n\n\t\t\t\t\t\t\tpoint = object.matrixWorld.multiplyVector3( intersectPoint.clone() );\n\t\t\t\t\t\t\tdistance = originCopy.distanceTo( point );\n\n\t\t\t\t\t\t\tif ( distance < ray.near || distance > ray.far ) continue;\n\n\t\t\t\t\t\t\tintersect = {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\t\t\tface: face,\n\t\t\t\t\t\t\t\tfaceIndex: f,\n\t\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\t\tc = vertices[ face.c ];\n\t\t\t\t\t\td = vertices[ face.d ];\n\n\t\t\t\t\t\tif ( pointInFace3( intersectPoint, a, b, d ) || pointInFace3( intersectPoint, b, c, d ) ) {\n\n\t\t\t\t\t\t\tpoint = object.matrixWorld.multiplyVector3( intersectPoint.clone() );\n\t\t\t\t\t\t\tdistance = originCopy.distanceTo( point );\n\n\t\t\t\t\t\t\tif ( distance < ray.near || distance > ray.far ) continue;\n\n\t\t\t\t\t\t\tintersect = {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\t\t\tface: face,\n\t\t\t\t\t\t\t\tfaceIndex: f,\n\t\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar intersectDescendants = function ( object, ray, intersects ) {\n\n\t\tvar descendants = object.getDescendants();\n\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( descendants[ i ], ray, intersects );\n\n\t\t}\n\t};\n\n\t//\n\n\tTHREE.Ray.prototype.precision = 0.0001;\n\n\tTHREE.Ray.prototype.set = function ( origin, direction ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t};\n\n\tTHREE.Ray.prototype.intersectObject = function ( object, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tif ( recursive === true ) {\n\n\t\t\tintersectDescendants( object, this, intersects );\n\n\t\t}\n\n\t\tintersectObject( object, this, intersects );\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n\tTHREE.Ray.prototype.intersectObjects = function ( objects, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\n\n\t\t\t}\n\t\t}\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n}( THREE ) );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Rectangle = function () {\n\n\tvar _left = 0;\n\tvar _top = 0;\n\tvar _right = 0;\n\tvar _bottom = 0;\n\tvar _width = 0;\n\tvar _height = 0;\n\tvar _isEmpty = true;\n\n\tfunction resize() {\n\n\t\t_width = _right - _left;\n\t\t_height = _bottom - _top;\n\n\t}\n\n\tthis.getX = function () {\n\n\t\treturn _left;\n\n\t};\n\n\tthis.getY = function () {\n\n\t\treturn _top;\n\n\t};\n\n\tthis.getWidth = function () {\n\n\t\treturn _width;\n\n\t};\n\n\tthis.getHeight = function () {\n\n\t\treturn _height;\n\n\t};\n\n\tthis.getLeft = function() {\n\n\t\treturn _left;\n\n\t};\n\n\tthis.getTop = function() {\n\n\t\treturn _top;\n\n\t};\n\n\tthis.getRight = function() {\n\n\t\treturn _right;\n\n\t};\n\n\tthis.getBottom = function() {\n\n\t\treturn _bottom;\n\n\t};\n\n\tthis.set = function ( left, top, right, bottom ) {\n\n\t\t_isEmpty = false;\n\n\t\t_left = left; _top = top;\n\t\t_right = right; _bottom = bottom;\n\n\t\tresize();\n\n\t};\n\n\tthis.addPoint = function ( x, y ) {\n\n\t\tif ( _isEmpty === true ) {\n\n\t\t\t_isEmpty = false;\n\t\t\t_left = x; _top = y;\n\t\t\t_right = x; _bottom = y;\n\n\t\t\tresize();\n\n\t\t} else {\n\n\t\t\t_left = _left < x ? _left : x; // Math.min( _left, x );\n\t\t\t_top = _top < y ? _top : y; // Math.min( _top, y );\n\t\t\t_right = _right > x ? _right : x; // Math.max( _right, x );\n\t\t\t_bottom = _bottom > y ? _bottom : y; // Math.max( _bottom, y );\n\n\t\t\tresize();\n\t\t}\n\n\t};\n\n\tthis.add3Points = function ( x1, y1, x2, y2, x3, y3 ) {\n\n\t\tif ( _isEmpty === true ) {\n\n\t\t\t_isEmpty = false;\n\t\t\t_left = x1 < x2 ? ( x1 < x3 ? x1 : x3 ) : ( x2 < x3 ? x2 : x3 );\n\t\t\t_top = y1 < y2 ? ( y1 < y3 ? y1 : y3 ) : ( y2 < y3 ? y2 : y3 );\n\t\t\t_right = x1 > x2 ? ( x1 > x3 ? x1 : x3 ) : ( x2 > x3 ? x2 : x3 );\n\t\t\t_bottom = y1 > y2 ? ( y1 > y3 ? y1 : y3 ) : ( y2 > y3 ? y2 : y3 );\n\n\t\t\tresize();\n\n\t\t} else {\n\n\t\t\t_left = x1 < x2 ? ( x1 < x3 ? ( x1 < _left ? x1 : _left ) : ( x3 < _left ? x3 : _left ) ) : ( x2 < x3 ? ( x2 < _left ? x2 : _left ) : ( x3 < _left ? x3 : _left ) );\n\t\t\t_top = y1 < y2 ? ( y1 < y3 ? ( y1 < _top ? y1 : _top ) : ( y3 < _top ? y3 : _top ) ) : ( y2 < y3 ? ( y2 < _top ? y2 : _top ) : ( y3 < _top ? y3 : _top ) );\n\t\t\t_right = x1 > x2 ? ( x1 > x3 ? ( x1 > _right ? x1 : _right ) : ( x3 > _right ? x3 : _right ) ) : ( x2 > x3 ? ( x2 > _right ? x2 : _right ) : ( x3 > _right ? x3 : _right ) );\n\t\t\t_bottom = y1 > y2 ? ( y1 > y3 ? ( y1 > _bottom ? y1 : _bottom ) : ( y3 > _bottom ? y3 : _bottom ) ) : ( y2 > y3 ? ( y2 > _bottom ? y2 : _bottom ) : ( y3 > _bottom ? y3 : _bottom ) );\n\n\t\t\tresize();\n\n\t\t};\n\n\t};\n\n\tthis.addRectangle = function ( r ) {\n\n\t\tif ( _isEmpty === true ) {\n\n\t\t\t_isEmpty = false;\n\t\t\t_left = r.getLeft(); _top = r.getTop();\n\t\t\t_right = r.getRight(); _bottom = r.getBottom();\n\n\t\t\tresize();\n\n\t\t} else {\n\n\t\t\t_left = _left < r.getLeft() ? _left : r.getLeft(); // Math.min(_left, r.getLeft() );\n\t\t\t_top = _top < r.getTop() ? _top : r.getTop(); // Math.min(_top, r.getTop() );\n\t\t\t_right = _right > r.getRight() ? _right : r.getRight(); // Math.max(_right, r.getRight() );\n\t\t\t_bottom = _bottom > r.getBottom() ? _bottom : r.getBottom(); // Math.max(_bottom, r.getBottom() );\n\n\t\t\tresize();\n\n\t\t}\n\n\t};\n\n\tthis.inflate = function ( v ) {\n\n\t\t_left -= v; _top -= v;\n\t\t_right += v; _bottom += v;\n\n\t\tresize();\n\n\t};\n\n\tthis.minSelf = function ( r ) {\n\n\t\t_left = _left > r.getLeft() ? _left : r.getLeft(); // Math.max( _left, r.getLeft() );\n\t\t_top = _top > r.getTop() ? _top : r.getTop(); // Math.max( _top, r.getTop() );\n\t\t_right = _right < r.getRight() ? _right : r.getRight(); // Math.min( _right, r.getRight() );\n\t\t_bottom = _bottom < r.getBottom() ? _bottom : r.getBottom(); // Math.min( _bottom, r.getBottom() );\n\n\t\tresize();\n\n\t};\n\n\tthis.intersects = function ( r ) {\n\n\t\t// http://gamemath.com/2011/09/detecting-whether-two-boxes-overlap/\n\n\t\tif ( _right < r.getLeft() ) return false;\n\t\tif ( _left > r.getRight() ) return false;\n\t\tif ( _bottom < r.getTop() ) return false;\n\t\tif ( _top > r.getBottom() ) return false;\n\n\t\treturn true;\n\n\t};\n\n\tthis.empty = function () {\n\n\t\t_isEmpty = true;\n\n\t\t_left = 0; _top = 0;\n\t\t_right = 0; _bottom = 0;\n\n\t\tresize();\n\n\t};\n\n\tthis.isEmpty = function () {\n\n\t\treturn _isEmpty;\n\n\t};\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Math = {\n\n\t// Clamp value to range <a, b>\n\n\tclamp: function ( x, a, b ) {\n\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\n\n\t},\n\n\t// Clamp value to range <a, inf)\n\n\tclampBottom: function ( x, a ) {\n\n\t\treturn x < a ? a : x;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// Random float from <0, 1> with 16 bits of randomness\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\n\n\trandom16: function () {\n\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tsign: function ( x ) {\n\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Object3D = function () {\n\n\tTHREE.Object3DLibrary.push( this );\n\n\tthis.id = THREE.Object3DIdCount ++;\n\n\tthis.name = '';\n\tthis.properties = {};\n\n\tthis.parent = undefined;\n\tthis.children = [];\n\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\n\n\tthis.position = new THREE.Vector3();\n\tthis.rotation = new THREE.Vector3();\n\tthis.eulerOrder = THREE.Object3D.defaultEulerOrder;\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.renderDepth = null;\n\n\tthis.rotationAutoUpdate = true;\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\tthis.matrixRotationWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrixWorldNeedsUpdate = true;\n\n\tthis.quaternion = new THREE.Quaternion();\n\tthis.useQuaternion = false;\n\n\tthis.boundRadius = 0.0;\n\tthis.boundRadiusScale = 1.0;\n\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\n\tthis._vector = new THREE.Vector3();\n\n};\n\n\nTHREE.Object3D.prototype = {\n\n\tconstructor: THREE.Object3D,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiply( matrix, this.matrix );\n\n\t\tthis.scale.getScaleFromMatrix( this.matrix );\n\n\t\tvar mat = new THREE.Matrix4().extractRotation( this.matrix );\n\t\tthis.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );\n\n\t\tthis.position.getPositionFromMatrix( this.matrix );\n\n\t},\n\n\ttranslate: function ( distance, axis ) {\n\n\t\tthis.matrix.rotateAxis( axis );\n\t\tthis.position.addSelf( axis.multiplyScalar( distance ) );\n\n\t},\n\n\ttranslateX: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 1, 0, 0 ) );\n\n\t},\n\n\ttranslateY: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 0, 1, 0 ) );\n\n\t},\n\n\ttranslateZ: function ( distance ) {\n\n\t\tthis.translate( distance, this._vector.set( 0, 0, 1 ) );\n\n\t},\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn this.matrixWorld.multiplyVector3( vector );\n\n\t},\n\n\tworldToLocal: function ( vector ) {\n\n\t\treturn THREE.Object3D.__m1.getInverse( this.matrixWorld ).multiplyVector3( vector );\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t// TODO: Add hierarchy support.\n\n\t\tthis.matrix.lookAt( vector, this.position, this.up );\n\n\t\tif ( this.rotationAutoUpdate ) {\n\n\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\n\n\t\t}\n\n\t},\n\n\tadd: function ( object ) {\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== undefined ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\t// add to scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\n\n\t\t\t\tscene.__addObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = undefined;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t// remove from scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\t\t\tscene.__removeObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\tgetChildByName: function ( name, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.name === name ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getChildByName( name, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetDescendants: function ( array ) {\n\n\t\tif ( array === undefined ) array = [];\n\n\t\tArray.prototype.push.apply( array, this.children );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].getDescendants( array );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setPosition( this.position );\n\n\t\tif ( this.useQuaternion === false )  {\n\n\t\t\tthis.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );\n\n\t\t} else {\n\n\t\t\tthis.matrix.setRotationFromQuaternion( this.quaternion );\n\n\t\t}\n\n\t\tif ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {\n\n\t\t\tthis.matrix.scale( this.scale );\n\t\t\tthis.boundRadiusScale = Math.max( this.scale.x, Math.max( this.scale.y, this.scale.z ) );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === undefined ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiply( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tclone: function ( object ) {\n\n\t\tif ( object === undefined ) object = new THREE.Object3D();\n\n\t\tobject.name = this.name;\n\n\t\tobject.up.copy( this.up );\n\n\t\tobject.position.copy( this.position );\n\t\tif ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness\n\t\tobject.eulerOrder = this.eulerOrder;\n\t\tobject.scale.copy( this.scale );\n\n\t\tobject.renderDepth = this.renderDepth;\n\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\n\n\t\tobject.matrix.copy( this.matrix );\n\t\tobject.matrixWorld.copy( this.matrixWorld );\n\t\tobject.matrixRotationWorld.copy( this.matrixRotationWorld );\n\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\n\t\tobject.quaternion.copy( this.quaternion );\n\t\tobject.useQuaternion = this.useQuaternion;\n\n\t\tobject.boundRadius = this.boundRadius;\n\t\tobject.boundRadiusScale = this.boundRadiusScale;\n\n\t\tobject.visible = this.visible;\n\n\t\tobject.castShadow = this.castShadow;\n\t\tobject.receiveShadow = this.receiveShadow;\n\n\t\tobject.frustumCulled = this.frustumCulled;\n\n\t\treturn object;\n\n\t},\n\n\tdeallocate: function () {\n\n\t\tvar index = THREE.Object3DLibrary.indexOf( this );\n\t\tif ( index !== -1 ) THREE.Object3DLibrary.splice( index, 1 );\n\n\t}\n\n};\n\nTHREE.Object3D.__m1 = new THREE.Matrix4();\nTHREE.Object3D.defaultEulerOrder = 'XYZ',\n\nTHREE.Object3DIdCount = 0;\nTHREE.Object3DLibrary = [];\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.Projector = function() {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\n\t_face4Count, _face4Pool = [], _face4PoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,\n\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4(),\n\n\t_face3VertexNormals;\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_viewProjectionMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_viewProjectionMatrix.multiplyVector3( vector );\n\n\t\treturn vector;\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tcamera.projectionMatrixInverse.getInverse( camera.projectionMatrix );\n\n\t\t_viewProjectionMatrix.multiply( camera.matrixWorld, camera.projectionMatrixInverse );\n\t\t_viewProjectionMatrix.multiplyVector3( vector );\n\n\t\treturn vector;\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tvar end, ray, t;\n\n\t\t// set two vectors with opposing z values\n\t\tvector.z = -1.0;\n\t\tend = new THREE.Vector3( vector.x, vector.y, 1.0 );\n\n\t\tthis.unprojectVector( vector, camera );\n\t\tthis.unprojectVector( end, camera );\n\n\t\t// find direction from vector to end\n\t\tend.subSelf( vector ).normalize();\n\n\t\treturn new THREE.Ray( vector, end );\n\n\t};\n\n\tvar projectGraph = function ( root, sortObjects ) {\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.sprites.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tvar projectObject = function ( parent ) {\n\n\t\t\tfor ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {\n\n\t\t\t\tvar object = parent.children[ c ];\n\n\t\t\t\tif ( object.visible === false ) continue;\n\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.contains( object ) === true ) {\n\n\t\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.copy( object.matrixWorld.getPosition() );\n\t\t\t\t\t\t\t_viewProjectionMatrix.multiplyVector3( _vector3 );\n\t\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t// TODO: Find an elegant and performant solution and remove this dupe code.\n\n\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector3.copy( object.matrixWorld.getPosition() );\n\t\t\t\t\t\t_viewProjectionMatrix.multiplyVector3( _vector3 );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_renderData.sprites.push( _object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t_object.z = object.renderDepth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector3.copy( object.matrixWorld.getPosition() );\n\t\t\t\t\t\t_viewProjectionMatrix.multiplyVector3( _vector3 );\n\t\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_renderData.objects.push( _object );\n\n\t\t\t\t}\n\n\t\t\t\tprojectObject( object );\n\n\t\t\t}\n\n\t\t};\n\n\t\tprojectObject( root );\n\n\t\tif ( sortObjects === true ) _renderData.objects.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\tvar near = camera.near, far = camera.far, visible = false,\n\t\to, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,\n\t\tmodelMatrix, rotationMatrix,\n\t\tgeometry, geometryMaterials, vertices, vertex, vertexPositionScreen,\n\t\tfaces, face, faceVertexNormals, normal, faceVertexUvs, uvs,\n\t\tv1, v2, v3, v4, isFaceMaterial, material, side;\n\n\t\t_face3Count = 0;\n\t\t_face4Count = 0;\n\t\t_lineCount = 0;\n\t\t_particleCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_viewProjectionMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t_renderData = projectGraph( scene, sortObjects );\n\n\t\tfor ( o = 0, ol = _renderData.objects.length; o < ol; o++ ) {\n\n\t\t\tobject = _renderData.objects[ o ].object;\n\n\t\t\tmodelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\tgeometryMaterials = object.geometry.materials;\n\t\t\t\tvertices = geometry.vertices;\n\t\t\t\tfaces = geometry.faces;\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\t\trotationMatrix = object.matrixRotationWorld.extractRotation( modelMatrix );\n\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tside = object.material.side;\n\n\t\t\t\tfor ( v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t\t_vertex.positionWorld.copy( vertices[ v ] );\n\n\t\t\t\t\tmodelMatrix.multiplyVector3( _vertex.positionWorld );\n\n\t\t\t\t\t_vertex.positionScreen.copy( _vertex.positionWorld );\n\t\t\t\t\t_viewProjectionMatrix.multiplyVector4( _vertex.positionScreen );\n\n\t\t\t\t\t_vertex.positionScreen.x /= _vertex.positionScreen.w;\n\t\t\t\t\t_vertex.positionScreen.y /= _vertex.positionScreen.w;\n\n\t\t\t\t\t_vertex.visible = _vertex.positionScreen.z > near && _vertex.positionScreen.z < far;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = faces[ f ];\n\n\t\t\t\t\tmaterial = isFaceMaterial === true ? geometryMaterials[ face.materialIndex ] : object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\tside = material.side;\n\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\tif ( v1.visible === true && v2.visible === true && v3.visible === true ) {\n\n\t\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t\t_face = getNextFace3InPool();\n\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\t\t\t\t\t\tv4 = _vertexPool[ face.d ];\n\n\t\t\t\t\t\tif ( v1.visible === true && v2.visible === true && v3.visible === true && v4.visible === true ) {\n\n\t\t\t\t\t\t\tvisible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||\n\t\t\t\t\t\t\t\t( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -\n\t\t\t\t\t\t\t\t( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;\n\n\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t\t_face = getNextFace4InPool();\n\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t\t\t\t\t_face.v4.copy( v4 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalWorld.copy( face.normal );\n\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) _face.normalWorld.negate();\n\t\t\t\t\trotationMatrix.multiplyVector3( _face.normalWorld );\n\n\t\t\t\t\t_face.centroidWorld.copy( face.centroid );\n\t\t\t\t\tmodelMatrix.multiplyVector3( _face.centroidWorld );\n\n\t\t\t\t\t_face.centroidScreen.copy( _face.centroidWorld );\n\t\t\t\t\t_viewProjectionMatrix.multiplyVector3( _face.centroidScreen );\n\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfor ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {\n\n\t\t\t\t\t\tnormal = _face.vertexNormalsWorld[ n ];\n\t\t\t\t\t\tnormal.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) normal.negate();\n\n\t\t\t\t\t\trotationMatrix.multiplyVector3( normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\tfor ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {\n\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\n\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\n\n\t\t\t\t\t\tfor ( u = 0, ul = uvs.length; u < ul; u ++ ) {\n\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t_face.z = _face.centroidScreen.z;\n\n\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\t_modelViewProjectionMatrix.multiply( _viewProjectionMatrix, modelMatrix );\n\n\t\t\t\tvertices = object.geometry.vertices;\n\n\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] );\n\t\t\t\t_modelViewProjectionMatrix.multiplyVector4( v1.positionScreen );\n\n\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] );\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyVector4( v1.positionScreen );\n\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t_line = getNextLineInPool();\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\n\n\t\t\tobject = _renderData.sprites[ o ].object;\n\n\t\t\tmodelMatrix = object.matrixWorld;\n\n\t\t\tif ( object instanceof THREE.Particle ) {\n\n\t\t\t\t_vector4.set( modelMatrix.elements[12], modelMatrix.elements[13], modelMatrix.elements[14], 1 );\n\t\t\t\t_viewProjectionMatrix.multiplyVector4( _vector4 );\n\n\t\t\t\t_vector4.z /= _vector4.w;\n\n\t\t\t\tif ( _vector4.z > 0 && _vector4.z < 1 ) {\n\n\t\t\t\t\t_particle = getNextParticleInPool();\n\t\t\t\t\t_particle.object = object;\n\t\t\t\t\t_particle.x = _vector4.x / _vector4.w;\n\t\t\t\t\t_particle.y = _vector4.y / _vector4.w;\n\t\t\t\t\t_particle.z = _vector4.z;\n\n\t\t\t\t\t_particle.rotation = object.rotation.z;\n\n\t\t\t\t\t_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\n\t\t\t\t\t_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\n\n\t\t\t\t\t_particle.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _particle );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFace3InPool() {\n\n\t\tif ( _face3Count === _face3PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace3();\n\t\t\t_face3Pool.push( face );\n\t\t\t_face3PoolLength ++;\n\t\t\t_face3Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face3Pool[ _face3Count ++ ];\n\n\n\t}\n\n\tfunction getNextFace4InPool() {\n\n\t\tif ( _face4Count === _face4PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace4();\n\t\t\t_face4Pool.push( face );\n\t\t\t_face4PoolLength ++;\n\t\t\t_face4Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face4Pool[ _face4Count ++ ];\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextParticleInPool() {\n\n\t\tif ( _particleCount === _particlePoolLength ) {\n\n\t\t\tvar particle = new THREE.RenderableParticle();\n\t\t\t_particlePool.push( particle );\n\t\t\t_particlePoolLength ++;\n\t\t\t_particleCount ++\n\t\t\treturn particle;\n\n\t\t}\n\n\t\treturn _particlePool[ _particleCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\treturn b.z - a.z;\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerpSelf( s2, alpha1 );\n\t\t\t\ts2.lerpSelf( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Quaternion = function( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( q ) {\n\n\t\tthis.x = q.x;\n\t\tthis.y = q.y;\n\t\tthis.z = q.z;\n\t\tthis.w = q.w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( v, order ) {\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( v.x / 2 );\n\t\tvar c2 = Math.cos( v.y / 2 );\n\t\tvar c3 = Math.cos( v.z / 2 );\n\t\tvar s1 = Math.sin( v.x / 2 );\n\t\tvar s2 = Math.sin( v.y / 2 );\n\t\tvar s3 = Math.sin( v.z / 2 );\n\n\t\tif ( order === undefined || order === 'XYZ' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t// axis have to be normalized\n\n\t\tvar halfAngle = angle / 2,\n\t\t\ts = Math.sin( halfAngle );\n\n\t\tthis.x = axis.x * s;\n\t\tthis.y = axis.y * s;\n\t\tthis.z = axis.z * s;\n\t\tthis.w = Math.cos( halfAngle );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis.w = 0.25 / s;\n\t\t\tthis.x = ( m32 - m23 ) * s;\n\t\t\tthis.y = ( m13 - m31 ) * s;\n\t\t\tthis.z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis.w = (m32 - m23 ) / s;\n\t\t\tthis.x = 0.25 * s;\n\t\t\tthis.y = (m12 + m21 ) / s;\n\t\t\tthis.z = (m13 + m31 ) / s;\n\n\t\t} else if (m22 > m33) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis.w = (m13 - m31 ) / s;\n\t\t\tthis.x = (m12 + m21 ) / s;\n\t\t\tthis.y = 0.25 * s;\n\t\t\tthis.z = (m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis.w = ( m21 - m12 ) / s;\n\t\t\tthis.x = ( m13 + m31 ) / s;\n\t\t\tthis.y = ( m23 + m32 ) / s;\n\t\t\tthis.z = 0.25 * s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcalculateW : function () {\n\n\t\tthis.w = - Math.sqrt( Math.abs( 1.0 - this.x * this.x - this.y * this.y - this.z * this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\tthis.x *= -1;\n\t\tthis.y *= -1;\n\t\tthis.z *= -1;\n\n\t\treturn this;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis.x = this.x * l;\n\t\t\tthis.y = this.y * l;\n\t\t\tthis.z = this.z * l;\n\t\t\tthis.w = this.w * l;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\tvar qax = a.x, qay = a.y, qaz = a.z, qaw = a.w,\n\t\tqbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\t\tthis.x =  qax * qbw + qay * qbz - qaz * qby + qaw * qbx;\n\t\tthis.y = -qax * qbz + qay * qbw + qaz * qbx + qaw * qby;\n\t\tthis.z =  qax * qby - qay * qbx + qaz * qbw + qaw * qbz;\n\t\tthis.w = -qax * qbx - qay * qby - qaz * qbz + qaw * qbw;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplySelf: function ( b ) {\n\n\t\tvar qax = this.x, qay = this.y, qaz = this.z, qaw = this.w,\n\t\tqbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector, dest ) {\n\n\t\tif ( !dest ) { dest = vector; }\n\n\t\tvar x    = vector.x,  y  = vector.y,  z  = vector.z,\n\t\t\tqx   = this.x, qy = this.y, qz = this.z, qw = this.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y,\n\t\t\tiy =  qw * y + qz * x - qx * z,\n\t\t\tiz =  qw * z + qx * y - qy * x,\n\t\t\tiw = -qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tdest.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tdest.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tdest.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n\t\treturn dest;\n\n\t},\n\n\tslerpSelf: function ( qb, t ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis.w = -qb.w;\n\t\t\tthis.x = -qb.x;\n\t\t\tthis.y = -qb.y;\n\t\t\tthis.z = -qb.z;\n\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis.w = w;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis.w = 0.5 * ( w + this.w );\n\t\t\tthis.x = 0.5 * ( x + this.x );\n\t\t\tthis.y = 0.5 * ( y + this.y );\n\t\t\tthis.z = 0.5 * ( z + this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis.w = ( w * ratioA + this.w * ratioB );\n\t\tthis.x = ( x * ratioA + this.x * ratioB );\n\t\tthis.y = ( y * ratioA + this.y * ratioB );\n\t\tthis.z = ( z * ratioA + this.z * ratioB );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\n\n\t}\n\n}\n\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\n\n\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\tvar cosHalfTheta = qa.w * qb.w + qa.x * qb.x + qa.y * qb.y + qa.z * qb.z;\n\n\tif ( cosHalfTheta < 0 ) {\n\n\t\tqm.w = -qb.w;\n\t\tqm.x = -qb.x;\n\t\tqm.y = -qb.y;\n\t\tqm.z = -qb.z;\n\n\t\tcosHalfTheta = -cosHalfTheta;\n\n\t} else {\n\n\t\tqm.copy( qb );\n\n\t}\n\n\tif ( Math.abs( cosHalfTheta ) >= 1.0 ) {\n\n\t\tqm.w = qa.w;\n\t\tqm.x = qa.x;\n\t\tqm.y = qa.y;\n\t\tqm.z = qa.z;\n\n\t\treturn qm;\n\n\t}\n\n\tvar halfTheta = Math.acos( cosHalfTheta );\n\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\tqm.w = 0.5 * ( qa.w + qm.w );\n\t\tqm.x = 0.5 * ( qa.x + qm.x );\n\t\tqm.y = 0.5 * ( qa.y + qm.y );\n\t\tqm.z = 0.5 * ( qa.z + qm.z );\n\n\t\treturn qm;\n\n\t}\n\n\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta;\n\tvar ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\tqm.w = ( qa.w * ratioA + qm.w * ratioB );\n\tqm.x = ( qa.x * ratioA + qm.x * ratioB );\n\tqm.y = ( qa.y * ratioA + qm.y * ratioB );\n\tqm.z = ( qa.z * ratioA + qm.z * ratioB );\n\n\treturn qm;\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Vertex = function ( v ) {\n\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\n\treturn v;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\tthis.d = d;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face4.prototype = {\n\n\tconstructor: THREE.Face4,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face4( this.a, this.b, this.c, this.d );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.UV = function ( u, v ) {\n\n\tthis.u = u || 0;\n\tthis.v = v || 0;\n\n};\n\nTHREE.UV.prototype = {\n\n\tconstructor: THREE.UV,\n\n\tset: function ( u, v ) {\n\n\t\tthis.u = u;\n\t\tthis.v = v;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( uv ) {\n\n\t\tthis.u = uv.u;\n\t\tthis.v = uv.v;\n\n\t\treturn this;\n\n\t},\n\n\tlerpSelf: function ( uv, alpha ) {\n\n\t\tthis.u += ( uv.u - this.u ) * alpha;\n\t\tthis.v += ( uv.v - this.v ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.UV( this.u, this.v );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Geometry = function () {\n\n\tTHREE.GeometryLibrary.push( this );\n\n\tthis.id = THREE.GeometryIdCount ++;\n\n\tthis.name = '';\n\n\tthis.vertices = [];\n\tthis.colors = []; // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\n\n\tthis.materials = [];\n\n\tthis.faces = [];\n\n\tthis.faceUvs = [[]];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphColors = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\tthis.dynamic = true; // the intermediate typearrays will be deleted when set to false\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.tangentsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\n};\n\nTHREE.Geometry.prototype = {\n\n\tconstructor : THREE.Geometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar matrixRotation = new THREE.Matrix4();\n\t\tmatrixRotation.extractRotation( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\n\t\t\tmatrix.multiplyVector3( vertex );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tmatrixRotation.multiplyVector3( face.normal );\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tmatrixRotation.multiplyVector3( face.vertexNormals[ j ] );\n\n\t\t\t}\n\n\t\t\tmatrix.multiplyVector3( face.centroid );\n\n\t\t}\n\n\t},\n\n\tcomputeCentroids: function () {\n\n\t\tvar f, fl, face;\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tface.centroid.set( 0, 0, 0 );\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.a ] );\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.b ] );\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.c ] );\n\t\t\t\tface.centroid.divideScalar( 3 );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.a ] );\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.b ] );\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.c ] );\n\t\t\t\tface.centroid.addSelf( this.vertices[ face.d ] );\n\t\t\t\tface.centroid.divideScalar( 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar n, nl, v, vl, vertex, f, fl, face, vA, vB, vC,\n\t\tcb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvA = this.vertices[ face.a ];\n\t\t\tvB = this.vertices[ face.b ];\n\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\tcb.sub( vC, vB );\n\t\t\tab.sub( vA, vB );\n\t\t\tcb.crossSelf( ab );\n\n\t\t\tif ( !cb.isZero() ) {\n\n\t\t\t\tcb.normalize();\n\n\t\t\t}\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t// create internal buffers for reuse when calling this method repeatedly\n\t\t// (otherwise memory allocation / deallocation every frame is big resource hog)\n\n\t\tif ( this.__tmpVertices === undefined ) {\n\n\t\t\tthis.__tmpVertices = new Array( this.vertices.length );\n\t\t\tvertices = this.__tmpVertices;\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvertices = this.__tmpVertices;\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tvertices[ face.a ].addSelf( face.normal );\n\t\t\t\tvertices[ face.b ].addSelf( face.normal );\n\t\t\t\tvertices[ face.c ].addSelf( face.normal );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvertices[ face.a ].addSelf( face.normal );\n\t\t\t\tvertices[ face.b ].addSelf( face.normal );\n\t\t\t\tvertices[ face.c ].addSelf( face.normal );\n\t\t\t\tvertices[ face.d ].addSelf( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\t\t\tface.vertexNormals[ 3 ].copy( vertices[ face.d ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\t\t\t\tvertexNormals.d.copy( face.vertexNormals[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// tangents go to vertices\n\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r, t, test,\n\t\t\ttan1 = [], tan2 = [],\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\n\t\t\tn = new THREE.Vector3(), w;\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\ttan1[ v ] = new THREE.Vector3();\n\t\t\ttan2[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\n\n\t\t\tvA = context.vertices[ a ];\n\t\t\tvB = context.vertices[ b ];\n\t\t\tvC = context.vertices[ c ];\n\n\t\t\tuvA = uv[ ua ];\n\t\t\tuvB = uv[ ub ];\n\t\t\tuvC = uv[ uc ];\n\n\t\t\tx1 = vB.x - vA.x;\n\t\t\tx2 = vC.x - vA.x;\n\t\t\ty1 = vB.y - vA.y;\n\t\t\ty2 = vC.y - vA.y;\n\t\t\tz1 = vB.z - vA.z;\n\t\t\tz2 = vC.z - vA.z;\n\n\t\t\ts1 = uvB.u - uvA.u;\n\t\t\ts2 = uvC.u - uvA.u;\n\t\t\tt1 = uvB.v - uvA.v;\n\t\t\tt2 = uvC.v - uvA.v;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\n\n\t\t\ttan1[ a ].addSelf( sdir );\n\t\t\ttan1[ b ].addSelf( sdir );\n\t\t\ttan1[ c ].addSelf( sdir );\n\n\t\t\ttan2[ a ].addSelf( tdir );\n\t\t\ttan2[ b ].addSelf( tdir );\n\t\t\ttan2[ c ].addSelf( tdir );\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\thandleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );\n\t\t\t\thandleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tfor ( i = 0; i < face.vertexNormals.length; i++ ) {\n\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\n\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\n\n\t\t\t\tt = tan1[ vertexIndex ];\n\n\t\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy( t );\n\t\t\t\ttmp.subSelf( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t\t// Calculate handedness\n\n\t\t\t\ttmp2.cross( face.vertexNormals[ i ], t );\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\n\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( ! this.boundingBox ) {\n\n\t\t\tthis.boundingBox = { min: new THREE.Vector3(), max: new THREE.Vector3() };\n\n\t\t}\n\n\t\tif ( this.vertices.length > 0 ) {\n\n\t\t\tvar position, firstPosition = this.vertices[ 0 ];\n\n\t\t\tthis.boundingBox.min.copy( firstPosition );\n\t\t\tthis.boundingBox.max.copy( firstPosition );\n\n\t\t\tvar min = this.boundingBox.min,\n\t\t\t\tmax = this.boundingBox.max;\n\n\t\t\tfor ( var v = 1, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tposition = this.vertices[ v ];\n\n\t\t\t\tif ( position.x < min.x ) {\n\n\t\t\t\t\tmin.x = position.x;\n\n\t\t\t\t} else if ( position.x > max.x ) {\n\n\t\t\t\t\tmax.x = position.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( position.y < min.y ) {\n\n\t\t\t\t\tmin.y = position.y;\n\n\t\t\t\t} else if ( position.y > max.y ) {\n\n\t\t\t\t\tmax.y = position.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( position.z < min.z ) {\n\n\t\t\t\t\tmin.z = position.z;\n\n\t\t\t\t} else if ( position.z > max.z ) {\n\n\t\t\t\t\tmax.z = position.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar maxRadiusSq = 0;\n\n\t\tif ( this.boundingSphere === null ) this.boundingSphere = { radius: 0 };\n\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tvar radiusSq = this.vertices[ i ].lengthSq();\n\t\t\tif ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;\n\n\t\t}\n\n\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i,il, face;\n\t\tvar abcd = 'abcd', o, k, j, jl, u;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t};\n\n\n\t\t// Start to patch face indices\n\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\t\t\t\tface.d = changes[ face.d ];\n\n\t\t\t\t// check dups in (a, b, c, d) and convert to -> face3\n\n\t\t\t\to = [ face.a, face.b, face.c, face.d ];\n\n\t\t\t\tfor ( k = 3; k > 0; k -- ) {\n\n\t\t\t\t\tif ( o.indexOf( face[ abcd[ k ] ] ) !== k ) {\n\n\t\t\t\t\t\t// console.log('faces', face.a, face.b, face.c, face.d, 'dup at', k);\n\n\t\t\t\t\t\to.splice( k, 1 );\n\n\t\t\t\t\t\tthis.faces[ i ] = new THREE.Face3( o[0], o[1], o[2], face.normal, face.color, face.materialIndex );\n\n\t\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tu = this.faceVertexUvs[ j ][ i ];\n\t\t\t\t\t\t\tif ( u ) u.splice( k, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.faces[ i ].vertexColors = face.vertexColors;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tclone: function () {\n\n\t\t// TODO\n\n\t},\n\n\tdeallocate: function () {\n\n\t\tvar index = THREE.GeometryLibrary.indexOf( this );\n\t\tif ( index !== -1 ) THREE.GeometryLibrary.splice( index, 1 );\n\n\t}\n\n};\n\nTHREE.GeometryIdCount = 0;\nTHREE.GeometryLibrary = [];\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tthis.id = THREE.GeometryCount ++;\n\n\t// attributes\n\n\tthis.attributes = {};\n\n\t// attributes typed arrays are kept only if dynamic flag is set\n\n\tthis.dynamic = false;\n\n\t// boundings\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\t// for compatibility\n\n\tthis.morphTargets = [];\n\n};\n\nTHREE.BufferGeometry.prototype = {\n\n\tconstructor : THREE.BufferGeometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar positionArray;\n\t\tvar normalArray;\n\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\n\n\t\tif ( positionArray !== undefined ) {\n\n\t\t\tmatrix.multiplyVector3Array( positionArray );\n\t\t\tthis.verticesNeedUpdate = true;\n\n\t\t}\n\n\t\tif ( normalArray !== undefined ) {\n\n\t\t\tvar matrixRotation = new THREE.Matrix4();\n\t\t\tmatrixRotation.extractRotation( matrix );\n\n\t\t\tmatrixRotation.multiplyVector3Array( normalArray );\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( ! this.boundingBox ) {\n\n\t\t\tthis.boundingBox = {\n\n\t\t\t\tmin: new THREE.Vector3( Infinity, Infinity, Infinity ),\n\t\t\t\tmax: new THREE.Vector3( -Infinity, -Infinity, -Infinity )\n\n\t\t\t};\n\n\t\t}\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar bb = this.boundingBox;\n\t\t\tvar x, y, z;\n\n\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\t// bounding box\n\n\t\t\t\tif ( x < bb.min.x ) {\n\n\t\t\t\t\tbb.min.x = x;\n\n\t\t\t\t} else if ( x > bb.max.x ) {\n\n\t\t\t\t\tbb.max.x = x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( y < bb.min.y ) {\n\n\t\t\t\t\tbb.min.y = y;\n\n\t\t\t\t} else if ( y > bb.max.y ) {\n\n\t\t\t\t\tbb.max.y = y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( z < bb.min.z ) {\n\n\t\t\t\t\tbb.min.z = z;\n\n\t\t\t\t} else if ( z > bb.max.z ) {\n\n\t\t\t\t\tbb.max.z = z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( positions === undefined || positions.length === 0 ) {\n\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( ! this.boundingSphere ) this.boundingSphere = { radius: 0 };\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar radiusSq, maxRadiusSq = 0;\n\t\t\tvar x, y, z;\n\n\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\tradiusSq =  x * x + y * y + z * z;\n\t\t\t\tif ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tif ( this.attributes[ \"position\" ] && this.attributes[ \"index\" ] ) {\n\n\t\t\tvar i, il;\n\t\t\tvar j, jl;\n\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\n\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\n\n\t\t\t\tthis.attributes[ \"normal\" ] = {\n\n\t\t\t\t\titemSize: 3,\n\t\t\t\t\tarray: new Float32Array( nVertexElements ),\n\t\t\t\t\tnumItems: nVertexElements\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar offsets = this.offsets;\n\n\t\t\tvar indices = this.attributes[ \"index\" ].array;\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\t\tvar vA, vB, vC, x, y, z,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\t\tvar start = offsets[ j ].start;\n\t\t\t\tvar count = offsets[ j ].count;\n\t\t\t\tvar index = offsets[ j ].index;\n\n\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tvA = index + indices[ i ];\n\t\t\t\t\tvB = index + indices[ i + 1 ];\n\t\t\t\t\tvC = index + indices[ i + 2 ];\n\n\t\t\t\t\tx = positions[ vA * 3 ];\n\t\t\t\t\ty = positions[ vA * 3 + 1 ];\n\t\t\t\t\tz = positions[ vA * 3 + 2 ];\n\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\tx = positions[ vB * 3 ];\n\t\t\t\t\ty = positions[ vB * 3 + 1 ];\n\t\t\t\t\tz = positions[ vB * 3 + 2 ];\n\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\tx = positions[ vC * 3 ];\n\t\t\t\t\ty = positions[ vC * 3 + 1 ];\n\t\t\t\t\tz = positions[ vC * 3 + 2 ];\n\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\tcb.sub( pC, pB );\n\t\t\t\t\tab.sub( pA, pB );\n\t\t\t\t\tcb.crossSelf( ab );\n\n\t\t\t\t\tnormals[ vA * 3 ] += cb.x;\n\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vB * 3 ] += cb.x;\n\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vC * 3 ] += cb.x;\n\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normalize normals\n\n\t\t\tfor ( i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tvar n = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\n\t\t\t this.attributes[ \"position\" ] === undefined ||\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\n\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = this.attributes[ \"index\" ].array;\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\n\n\t\t\tvar nTangentElements = 4 * nVertices;\n\n\t\t\tthis.attributes[ \"tangent\" ] = {\n\n\t\t\t\titemSize: 4,\n\t\t\t\tarray: new Float32Array( nTangentElements ),\n\t\t\t\tnumItems: nTangentElements\n\n\t\t\t};\n\n\t\t}\n\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\n\n\t\t\ttan1[ k ] = new THREE.Vector3();\n\t\t\ttan2[ k ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar xA, yA, zA,\n\t\t\txB, yB, zB,\n\t\t\txC, yC, zC,\n\n\t\t\tuA, vA,\n\t\t\tuB, vB,\n\t\t\tuC, vC,\n\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r;\n\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\txA = positions[ a * 3 ];\n\t\t\tyA = positions[ a * 3 + 1 ];\n\t\t\tzA = positions[ a * 3 + 2 ];\n\n\t\t\txB = positions[ b * 3 ];\n\t\t\tyB = positions[ b * 3 + 1 ];\n\t\t\tzB = positions[ b * 3 + 2 ];\n\n\t\t\txC = positions[ c * 3 ];\n\t\t\tyC = positions[ c * 3 + 1 ];\n\t\t\tzC = positions[ c * 3 + 2 ];\n\n\t\t\tuA = uvs[ a * 2 ];\n\t\t\tvA = uvs[ a * 2 + 1 ];\n\n\t\t\tuB = uvs[ b * 2 ];\n\t\t\tvB = uvs[ b * 2 + 1 ];\n\n\t\t\tuC = uvs[ c * 2 ];\n\t\t\tvC = uvs[ c * 2 + 1 ];\n\n\t\t\tx1 = xB - xA;\n\t\t\tx2 = xC - xA;\n\n\t\t\ty1 = yB - yA;\n\t\t\ty2 = yC - yA;\n\n\t\t\tz1 = zB - zA;\n\t\t\tz2 = zC - zA;\n\n\t\t\ts1 = uB - uA;\n\t\t\ts2 = uC - uA;\n\n\t\t\tt1 = vB - vA;\n\t\t\tt2 = vC - vA;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\n\t\t\tsdir.set(\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\n\t\t\t);\n\n\t\t\ttdir.set(\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\n\t\t\t);\n\n\t\t\ttan1[ a ].addSelf( sdir );\n\t\t\ttan1[ b ].addSelf( sdir );\n\t\t\ttan1[ c ].addSelf( sdir );\n\n\t\t\ttan2[ a ].addSelf( tdir );\n\t\t\ttan2[ b ].addSelf( tdir );\n\t\t\ttan2[ c ].addSelf( tdir );\n\n\t\t}\n\n\t\tvar i, il;\n\t\tvar j, jl;\n\t\tvar iA, iB, iC;\n\n\t\tvar offsets = this.offsets;\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleTriangle( iA, iB, iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\t\tvar w, t, test;\n\t\tvar nx, ny, nz;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.x = normals[ v * 3 ];\n\t\t\tn.y = normals[ v * 3 + 1 ];\n\t\t\tn.z = normals[ v * 3 + 2 ];\n\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.subSelf( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.cross( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] \t  = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleVertex( iA );\n\t\t\t\thandleVertex( iB );\n\t\t\t\thandleVertex( iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\t\tthis.tangentsNeedUpdate = true;\n\n\t}\n\n};\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint != oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\tlinearDistance, realDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t};\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\n\tthis.projectionMatrix = new THREE.Matrix4();\n\tthis.projectionMatrixInverse = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Camera.prototype.lookAt = function ( vector ) {\n\n\t// TODO: Add hierarchy support.\n\n\tthis.matrix.lookAt( this.position, vector, this.up );\n\n\tif ( this.rotationAutoUpdate === true ) {\n\n\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\n\n\n/**\n * Uses Focal Length (in mm) to estimate and set FOV\n * 35mm (fullframe) camera is used if frame size is not specified;\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n */\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tthis.fov = 2 * Math.atan( frameHeight / ( focalLength * 2 ) ) * ( 180 / Math.PI );\n\tthis.updateProjectionMatrix();\n\n}\n\n\n/**\n * Sets an offset in a larger frustum. This is useful for multi-window or\n * multi-monitor/multi-machine setups.\n *\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n * the monitors are in grid like this\n *\n *   +---+---+---+\n *   | A | B | C |\n *   +---+---+---+\n *   | D | E | F |\n *   +---+---+---+\n *\n * then for each monitor you would call it like this\n *\n *   var w = 1920;\n *   var h = 1080;\n *   var fullWidth = w * 3;\n *   var fullHeight = h * 2;\n *\n *   --A--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n *   --B--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n *   --C--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n *   --D--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n *   --E--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n *   --F--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n *\n *   Note there is no reason monitors have to be the same size or in a grid.\n */\n\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\tthis.fullWidth = fullWidth;\n\tthis.fullHeight = fullHeight;\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.updateProjectionMatrix();\n\n};\n\n\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n\n\tif ( this.fullWidth ) {\n\n\t\tvar aspect = this.fullWidth / this.fullHeight;\n\t\tvar top = Math.tan( this.fov * Math.PI / 360 ) * this.near;\n\t\tvar bottom = -top;\n\t\tvar left = aspect * bottom;\n\t\tvar right = aspect * top;\n\t\tvar width = Math.abs( right - left );\n\t\tvar height = Math.abs( top - bottom );\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\tleft + this.x * width / this.fullWidth,\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\n\t\t\ttop - this.y * height / this.fullHeight,\n\t\t\tthis.near,\n\t\t\tthis.far\n\t\t);\n\n\t} else {\n\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.color = new THREE.Color( hex );\n\n};\n\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( hex ) {\n\n\tTHREE.Light.call( this, hex );\n\n};\n\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( hex, intensity, distance ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\n\tthis.shadowCameraLeft = -500;\n\tthis.shadowCameraRight = 500;\n\tthis.shadowCameraTop = 500;\n\tthis.shadowCameraBottom = -500;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowCascade = false;\n\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\n\tthis.shadowCascadeCount = 2;\n\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\n\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\n\n\tthis.shadowCascadeArray = [];\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\n\n\tTHREE.Light.call( this, skyColorHex );\n\n\tthis.groundColor = new THREE.Color( groundColorHex );\n\n\tthis.position = new THREE.Vector3( 0, 100, 0 );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n};\n\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLight = function ( hex, intensity, distance ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 0, 0 );\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\n};\n\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 2;\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\tthis.shadowCameraFov = 50;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function ( showStatus ) {\n\n\tthis.showStatus = showStatus;\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: 'anonymous',\n\n\taddStatusElement: function () {\n\n\t\tvar e = document.createElement( \"div\" );\n\n\t\te.style.position = \"absolute\";\n\t\te.style.right = \"0px\";\n\t\te.style.top = \"0px\";\n\t\te.style.fontSize = \"0.8em\";\n\t\te.style.textAlign = \"left\";\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\n\t\te.style.color = \"#fff\";\n\t\te.style.width = \"120px\";\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\n\t\te.style.zIndex = 1000;\n\n\t\te.innerHTML = \"Loading ...\";\n\n\t\treturn e;\n\n\t},\n\n\tupdateProgress: function ( progress ) {\n\n\t\tvar message = \"Loaded \";\n\n\t\tif ( progress.total ) {\n\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\n\n\n\t\t} else {\n\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\n\n\t\t}\n\n\t\tthis.statusDomElement.innerHTML = message;\n\n\t},\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\t\tparts.pop();\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\n\n\t},\n\n\tinitMaterials: function ( scope, materials, texturePath ) {\n\n\t\tscope.materials = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tscope.materials[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\n\n\t\t}\n\n\t},\n\n\thasNormals: function ( scope ) {\n\n\t\tvar m, i, il = scope.materials.length;\n\n\t\tfor( i = 0; i < il; i ++ ) {\n\n\t\t\tm = scope.materials[ i ];\n\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tcreateMaterial: function ( m, texturePath ) {\n\n\t\tvar _this = this;\n\n\t\tfunction is_pow2( n ) {\n\n\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\treturn Math.floor( l ) == l;\n\n\t\t}\n\n\t\tfunction nearest_pow2( n ) {\n\n\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\n\n\t\t}\n\n\t\tfunction load_image( where, url ) {\n\n\t\t\tvar image = new Image();\n\n\t\t\timage.onload = function () {\n\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\n\n\t\t\t\t\tvar width = nearest_pow2( this.width );\n\t\t\t\t\tvar height = nearest_pow2( this.height );\n\n\t\t\t\t\twhere.image.width = width;\n\t\t\t\t\twhere.image.height = height;\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\twhere.image = this;\n\n\t\t\t\t}\n\n\t\t\t\twhere.needsUpdate = true;\n\n\t\t\t};\n\n\t\t\timage.crossOrigin = _this.crossOrigin;\n\t\t\timage.src = url;\n\n\t\t}\n\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\n\n\t\t\tvar isCompressed = sourceFile.toLowerCase().endsWith( \".dds\" );\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\n\n\t\t\t\twhere[ name ] = texture;\n\n\t\t\t} else {\n\n\t\t\t\tvar texture = document.createElement( 'canvas' );\n\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\n\n\t\t\t}\n\n\t\t\twhere[ name ].sourceFile = sourceFile;\n\n\t\t\tif( repeat ) {\n\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\n\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\n\n\t\t\t}\n\n\t\t\tif ( offset ) {\n\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( wrap ) {\n\n\t\t\t\tvar wrapMap = {\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\t\t\t\t}\n\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\n\n\t\t\t}\n\n\t\t\tif ( anisotropy ) {\n\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\n\n\t\t\t}\n\n\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\tload_image( where[ name ], fullPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction rgb2hex( rgb ) {\n\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\n\n\t\t}\n\n\t\t// defaults\n\n\t\tvar mtype = \"MeshLambertMaterial\";\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\n\n\t\t// parameters from model file\n\n\t\tif ( m.shading ) {\n\n\t\t\tvar shading = m.shading.toLowerCase();\n\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\n\n\t\t}\n\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\n\n\t\t\tmpars.blending = THREE[ m.blending ];\n\n\t\t}\n\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\n\n\t\t\tmpars.transparent = m.transparent;\n\n\t\t}\n\n\t\tif ( m.depthTest !== undefined ) {\n\n\t\t\tmpars.depthTest = m.depthTest;\n\n\t\t}\n\n\t\tif ( m.depthWrite !== undefined ) {\n\n\t\t\tmpars.depthWrite = m.depthWrite;\n\n\t\t}\n\n\t\tif ( m.visible !== undefined ) {\n\n\t\t\tmpars.visible = m.visible;\n\n\t\t}\n\n\t\tif ( m.flipSided !== undefined ) {\n\n\t\t\tmpars.side = THREE.BackSide;\n\n\t\t}\n\n\t\tif ( m.doubleSided !== undefined ) {\n\n\t\t\tmpars.side = THREE.DoubleSide;\n\n\t\t}\n\n\t\tif ( m.wireframe !== undefined ) {\n\n\t\t\tmpars.wireframe = m.wireframe;\n\n\t\t}\n\n\t\tif ( m.vertexColors !== undefined ) {\n\n\t\t\tif ( m.vertexColors === \"face\" ) {\n\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\n\n\t\t\t} else if ( m.vertexColors ) {\n\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// colors\n\n\t\tif ( m.colorDiffuse ) {\n\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\n\n\t\t} else if ( m.DbgColor ) {\n\n\t\t\tmpars.color = m.DbgColor;\n\n\t\t}\n\n\t\tif ( m.colorSpecular ) {\n\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\n\n\t\t}\n\n\t\tif ( m.colorAmbient ) {\n\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\n\n\t\t}\n\n\t\t// modifiers\n\n\t\tif ( m.transparency ) {\n\n\t\t\tmpars.opacity = m.transparency;\n\n\t\t}\n\n\t\tif ( m.specularCoef ) {\n\n\t\t\tmpars.shininess = m.specularCoef;\n\n\t\t}\n\n\t\t// textures\n\n\t\tif ( m.mapDiffuse && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapLight && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapBump && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapNormal && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\n\t\t}\n\n\t\tif ( m.mapSpecular && texturePath ) {\n\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( m.mapBumpScale ) {\n\n\t\t\tmpars.bumpScale = m.mapBumpScale;\n\n\t\t}\n\n\t\t// special case for normal mapped material\n\n\t\tif ( m.mapNormal ) {\n\n\t\t\tvar shader = THREE.ShaderUtils.lib[ \"normal\" ];\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\n\n\t\t\tif ( m.mapNormalFactor ) {\n\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\n\n\t\t\t}\n\n\t\t\tif ( mpars.map ) {\n\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( mpars.specularMap ) {\n\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( mpars.lightMap ) {\n\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t}\n\n\t\t\t// for the moment don't handle displacement texture\n\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\n\n\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\n\n\t\t\tif ( mpars.opacity !== undefined ) {\n\n\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\n\n\t\t\t}\n\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\n\n\t\t} else {\n\n\t\t\tvar material = new THREE[ mtype ]( mpars );\n\n\t\t}\n\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\n\n\t\treturn material;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BinaryLoader = function ( showStatus ) {\n\n\tTHREE.Loader.call( this, showStatus );\n\n};\n\nTHREE.BinaryLoader.prototype = Object.create( THREE.Loader.prototype );\n\n// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)\n//  - binary models consist of two files: JS and BIN\n//  - parameters\n//\t\t- url (required)\n//\t\t- callback (required)\n//\t\t- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)\n//\t\t- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)\n\nTHREE.BinaryLoader.prototype.load = function( url, callback, texturePath, binaryPath ) {\n\n\ttexturePath = texturePath ? texturePath : this.extractUrlBase( url );\n\tbinaryPath = binaryPath ? binaryPath : this.extractUrlBase( url );\n\n\tvar callbackProgress = this.showProgress ? THREE.Loader.prototype.updateProgress : null;\n\n\tthis.onLoadStart();\n\n\t// #1 load JS part via web worker\n\n\tthis.loadAjaxJSON( this, url, callback, texturePath, binaryPath, callbackProgress );\n\n};\n\nTHREE.BinaryLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, binaryPath, callbackProgress ) {\n\n\tvar xhr = new XMLHttpRequest();\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState == 4 ) {\n\n\t\t\tif ( xhr.status == 200 || xhr.status == 0 ) {\n\n\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\t\t\t\tcontext.loadAjaxBuffers( json, callback, binaryPath, texturePath, callbackProgress );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.BinaryLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.send( null );\n\n};\n\nTHREE.BinaryLoader.prototype.loadAjaxBuffers = function ( json, callback, binaryPath, texturePath, callbackProgress ) {\n\n\tvar xhr = new XMLHttpRequest(),\n\t\turl = binaryPath + \"/\" + json.buffers;\n\n\tvar length = 0;\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState == 4 ) {\n\n\t\t\tif ( xhr.status == 200 || xhr.status == 0 ) {\n\n\t\t\t\tvar buffer = xhr.response;\n\t\t\t\tif ( buffer === undefined ) buffer = ( new Uint8Array( xhr.responseBody ) ).buffer; // IEWEBGL needs this\n\t\t\t\tTHREE.BinaryLoader.prototype.createBinModel( buffer, callback, texturePath, json.materials );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.BinaryLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState == 3 ) {\n\n\t\t\tif ( callbackProgress ) {\n\n\t\t\t\tif ( length == 0 ) {\n\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t\t\t}\n\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState == 2 ) {\n\n\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.responseType = \"arraybuffer\";\n\txhr.send( null );\n\n};\n\n// Binary AJAX parser\n\nTHREE.BinaryLoader.prototype.createBinModel = function ( data, callback, texturePath, materials ) {\n\n\tvar Model = function ( texturePath ) {\n\n\t\tvar scope = this,\n\t\t\tcurrentOffset = 0,\n\t\t\tmd,\n\t\t\tnormals = [],\n\t\t\tuvs = [],\n\t\t\tstart_tri_flat, start_tri_smooth, start_tri_flat_uv, start_tri_smooth_uv,\n\t\t\tstart_quad_flat, start_quad_smooth, start_quad_flat_uv, start_quad_smooth_uv,\n\t\t\ttri_size, quad_size,\n\t\t\tlen_tri_flat, len_tri_smooth, len_tri_flat_uv, len_tri_smooth_uv,\n\t\t\tlen_quad_flat, len_quad_smooth, len_quad_flat_uv, len_quad_smooth_uv;\n\n\n\t\tTHREE.Geometry.call( this );\n\n\t\tTHREE.Loader.prototype.initMaterials( scope, materials, texturePath );\n\n\t\tmd = parseMetaData( data, currentOffset );\n\n\t\tcurrentOffset += md.header_bytes;\n/*\n\t\tmd.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n\t\tmd.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;\n\t\tmd.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n\t\tmd.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n*/\n\t\t// buffers sizes\n\n\t\ttri_size =  md.vertex_index_bytes * 3 + md.material_index_bytes;\n\t\tquad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;\n\n\t\tlen_tri_flat      = md.ntri_flat      * ( tri_size );\n\t\tlen_tri_smooth    = md.ntri_smooth    * ( tri_size + md.normal_index_bytes * 3 );\n\t\tlen_tri_flat_uv   = md.ntri_flat_uv   * ( tri_size + md.uv_index_bytes * 3 );\n\t\tlen_tri_smooth_uv = md.ntri_smooth_uv * ( tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3 );\n\n\t\tlen_quad_flat      = md.nquad_flat      * ( quad_size );\n\t\tlen_quad_smooth    = md.nquad_smooth    * ( quad_size + md.normal_index_bytes * 4 );\n\t\tlen_quad_flat_uv   = md.nquad_flat_uv   * ( quad_size + md.uv_index_bytes * 4 );\n\t\tlen_quad_smooth_uv = md.nquad_smooth_uv * ( quad_size + md.normal_index_bytes * 4 + md.uv_index_bytes * 4 );\n\n\t\t// read buffers\n\n\t\tcurrentOffset += init_vertices( currentOffset );\n\n\t\tcurrentOffset += init_normals( currentOffset );\n\t\tcurrentOffset += handlePadding( md.nnormals * 3 );\n\n\t\tcurrentOffset += init_uvs( currentOffset );\n\n\t\tstart_tri_flat \t\t= currentOffset;\n\t\tstart_tri_smooth    = start_tri_flat    + len_tri_flat    + handlePadding( md.ntri_flat * 2 );\n\t\tstart_tri_flat_uv   = start_tri_smooth  + len_tri_smooth  + handlePadding( md.ntri_smooth * 2 );\n\t\tstart_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding( md.ntri_flat_uv * 2 );\n\n\t\tstart_quad_flat     = start_tri_smooth_uv + len_tri_smooth_uv  + handlePadding( md.ntri_smooth_uv * 2 );\n\t\tstart_quad_smooth   = start_quad_flat     + len_quad_flat\t   + handlePadding( md.nquad_flat * 2 );\n\t\tstart_quad_flat_uv  = start_quad_smooth   + len_quad_smooth    + handlePadding( md.nquad_smooth * 2 );\n\t\tstart_quad_smooth_uv= start_quad_flat_uv  + len_quad_flat_uv   + handlePadding( md.nquad_flat_uv * 2 );\n\n\t\t// have to first process faces with uvs\n\t\t// so that face and uv indices match\n\n\t\tinit_triangles_flat_uv( start_tri_flat_uv );\n\t\tinit_triangles_smooth_uv( start_tri_smooth_uv );\n\n\t\tinit_quads_flat_uv( start_quad_flat_uv );\n\t\tinit_quads_smooth_uv( start_quad_smooth_uv );\n\n\t\t// now we can process untextured faces\n\n\t\tinit_triangles_flat( start_tri_flat );\n\t\tinit_triangles_smooth( start_tri_smooth );\n\n\t\tinit_quads_flat( start_quad_flat );\n\t\tinit_quads_smooth( start_quad_smooth );\n\n\t\tthis.computeCentroids();\n\t\tthis.computeFaceNormals();\n\n\t\tif ( THREE.Loader.prototype.hasNormals( this ) ) this.computeTangents();\n\n\t\tfunction handlePadding( n ) {\n\n\t\t\treturn ( n % 4 ) ? ( 4 - n % 4 ) : 0;\n\n\t\t};\n\n\t\tfunction parseMetaData( data, offset ) {\n\n\t\t\tvar metaData = {\n\n\t\t\t\t'signature'               :parseString( data, offset,  12 ),\n\t\t\t\t'header_bytes'            :parseUChar8( data, offset + 12 ),\n\n\t\t\t\t'vertex_coordinate_bytes' :parseUChar8( data, offset + 13 ),\n\t\t\t\t'normal_coordinate_bytes' :parseUChar8( data, offset + 14 ),\n\t\t\t\t'uv_coordinate_bytes'     :parseUChar8( data, offset + 15 ),\n\n\t\t\t\t'vertex_index_bytes'      :parseUChar8( data, offset + 16 ),\n\t\t\t\t'normal_index_bytes'      :parseUChar8( data, offset + 17 ),\n\t\t\t\t'uv_index_bytes'          :parseUChar8( data, offset + 18 ),\n\t\t\t\t'material_index_bytes'    :parseUChar8( data, offset + 19 ),\n\n\t\t\t\t'nvertices'    :parseUInt32( data, offset + 20 ),\n\t\t\t\t'nnormals'     :parseUInt32( data, offset + 20 + 4*1 ),\n\t\t\t\t'nuvs'         :parseUInt32( data, offset + 20 + 4*2 ),\n\n\t\t\t\t'ntri_flat'      :parseUInt32( data, offset + 20 + 4*3 ),\n\t\t\t\t'ntri_smooth'    :parseUInt32( data, offset + 20 + 4*4 ),\n\t\t\t\t'ntri_flat_uv'   :parseUInt32( data, offset + 20 + 4*5 ),\n\t\t\t\t'ntri_smooth_uv' :parseUInt32( data, offset + 20 + 4*6 ),\n\n\t\t\t\t'nquad_flat'      :parseUInt32( data, offset + 20 + 4*7 ),\n\t\t\t\t'nquad_smooth'    :parseUInt32( data, offset + 20 + 4*8 ),\n\t\t\t\t'nquad_flat_uv'   :parseUInt32( data, offset + 20 + 4*9 ),\n\t\t\t\t'nquad_smooth_uv' :parseUInt32( data, offset + 20 + 4*10 )\n\n\t\t\t};\n/*\n\t\t\tconsole.log( \"signature: \" + metaData.signature );\n\n\t\t\tconsole.log( \"header_bytes: \" + metaData.header_bytes );\n\t\t\tconsole.log( \"vertex_coordinate_bytes: \" + metaData.vertex_coordinate_bytes );\n\t\t\tconsole.log( \"normal_coordinate_bytes: \" + metaData.normal_coordinate_bytes );\n\t\t\tconsole.log( \"uv_coordinate_bytes: \" + metaData.uv_coordinate_bytes );\n\n\t\t\tconsole.log( \"vertex_index_bytes: \" + metaData.vertex_index_bytes );\n\t\t\tconsole.log( \"normal_index_bytes: \" + metaData.normal_index_bytes );\n\t\t\tconsole.log( \"uv_index_bytes: \" + metaData.uv_index_bytes );\n\t\t\tconsole.log( \"material_index_bytes: \" + metaData.material_index_bytes );\n\n\t\t\tconsole.log( \"nvertices: \" + metaData.nvertices );\n\t\t\tconsole.log( \"nnormals: \" + metaData.nnormals );\n\t\t\tconsole.log( \"nuvs: \" + metaData.nuvs );\n\n\t\t\tconsole.log( \"ntri_flat: \" + metaData.ntri_flat );\n\t\t\tconsole.log( \"ntri_smooth: \" + metaData.ntri_smooth );\n\t\t\tconsole.log( \"ntri_flat_uv: \" + metaData.ntri_flat_uv );\n\t\t\tconsole.log( \"ntri_smooth_uv: \" + metaData.ntri_smooth_uv );\n\n\t\t\tconsole.log( \"nquad_flat: \" + metaData.nquad_flat );\n\t\t\tconsole.log( \"nquad_smooth: \" + metaData.nquad_smooth );\n\t\t\tconsole.log( \"nquad_flat_uv: \" + metaData.nquad_flat_uv );\n\t\t\tconsole.log( \"nquad_smooth_uv: \" + metaData.nquad_smooth_uv );\n\n\t\t\tvar total = metaData.header_bytes\n\t\t\t\t\t  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3\n\t\t\t\t\t  + metaData.nnormals * metaData.normal_coordinate_bytes * 3\n\t\t\t\t\t  + metaData.nuvs * metaData.uv_coordinate_bytes * 2\n\t\t\t\t\t  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )\n\t\t\t\t\t  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )\n\t\t\t\t\t  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )\n\t\t\t\t\t  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )\n\t\t\t\t\t  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )\n\t\t\t\t\t  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )\n\t\t\t\t\t  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )\n\t\t\t\t\t  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );\n\t\t\tconsole.log( \"total bytes: \" + total );\n*/\n\n\t\t\treturn metaData;\n\n\t\t};\n\n\t\tfunction parseString( data, offset, length ) {\n\n\t\t\tvar charArray = new Uint8Array( data, offset, length );\n\n\t\t\tvar text = \"\";\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\ttext += String.fromCharCode( charArray[ offset + i ] );\n\n\t\t\t}\n\n\t\t\treturn text;\n\n\t\t};\n\n\t\tfunction parseUChar8( data, offset ) {\n\n\t\t\tvar charArray = new Uint8Array( data, offset, 1 );\n\n\t\t\treturn charArray[ 0 ];\n\n\t\t};\n\n\t\tfunction parseUInt32( data, offset ) {\n\n\t\t\tvar intArray = new Uint32Array( data, offset, 1 );\n\n\t\t\treturn intArray[ 0 ];\n\n\t\t};\n\n\t\tfunction init_vertices( start ) {\n\n\t\t\tvar nElements = md.nvertices;\n\n\t\t\tvar coordArray = new Float32Array( data, start, nElements * 3 );\n\n\t\t\tvar i, x, y, z;\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\tx = coordArray[ i * 3 ];\n\t\t\t\ty = coordArray[ i * 3 + 1 ];\n\t\t\t\tz = coordArray[ i * 3 + 2 ];\n\n\t\t\t\tvertex( scope, x, y, z );\n\n\t\t\t}\n\n\t\t\treturn nElements * 3 * Float32Array.BYTES_PER_ELEMENT;\n\n\t\t};\n\n\t\tfunction init_normals( start ) {\n\n\t\t\tvar nElements = md.nnormals;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar normalArray = new Int8Array( data, start, nElements * 3 );\n\n\t\t\t\tvar i, x, y, z;\n\n\t\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\t\tx = normalArray[ i * 3 ];\n\t\t\t\t\ty = normalArray[ i * 3 + 1 ];\n\t\t\t\t\tz = normalArray[ i * 3 + 2 ];\n\n\t\t\t\t\tnormals.push( x/127, y/127, z/127 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn nElements * 3 * Int8Array.BYTES_PER_ELEMENT;\n\n\t\t};\n\n\t\tfunction init_uvs( start ) {\n\n\t\t\tvar nElements = md.nuvs;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar uvArray = new Float32Array( data, start, nElements * 2 );\n\n\t\t\t\tvar i, u, v;\n\n\t\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\t\tu = uvArray[ i * 2 ];\n\t\t\t\t\tv = uvArray[ i * 2 + 1 ];\n\n\t\t\t\t\tuvs.push( u, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn nElements * 2 * Float32Array.BYTES_PER_ELEMENT;\n\n\t\t};\n\n\t\tfunction init_uvs3( nElements, offset ) {\n\n\t\t\tvar i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;\n\n\t\t\tvar uvIndexBuffer = new Uint32Array( data, offset, 3 * nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\tuva = uvIndexBuffer[ i * 3 ];\n\t\t\t\tuvb = uvIndexBuffer[ i * 3 + 1 ];\n\t\t\t\tuvc = uvIndexBuffer[ i * 3 + 2 ];\n\n\t\t\t\tu1 = uvs[ uva*2 ];\n\t\t\t\tv1 = uvs[ uva*2 + 1 ];\n\n\t\t\t\tu2 = uvs[ uvb*2 ];\n\t\t\t\tv2 = uvs[ uvb*2 + 1 ];\n\n\t\t\t\tu3 = uvs[ uvc*2 ];\n\t\t\t\tv3 = uvs[ uvc*2 + 1 ];\n\n\t\t\t\tuv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_uvs4( nElements, offset ) {\n\n\t\t\tvar i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;\n\n\t\t\tvar uvIndexBuffer = new Uint32Array( data, offset, 4 * nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\tuva = uvIndexBuffer[ i * 4 ];\n\t\t\t\tuvb = uvIndexBuffer[ i * 4 + 1 ];\n\t\t\t\tuvc = uvIndexBuffer[ i * 4 + 2 ];\n\t\t\t\tuvd = uvIndexBuffer[ i * 4 + 3 ];\n\n\t\t\t\tu1 = uvs[ uva*2 ];\n\t\t\t\tv1 = uvs[ uva*2 + 1 ];\n\n\t\t\t\tu2 = uvs[ uvb*2 ];\n\t\t\t\tv2 = uvs[ uvb*2 + 1 ];\n\n\t\t\t\tu3 = uvs[ uvc*2 ];\n\t\t\t\tv3 = uvs[ uvc*2 + 1 ];\n\n\t\t\t\tu4 = uvs[ uvd*2 ];\n\t\t\t\tv4 = uvs[ uvd*2 + 1 ];\n\n\t\t\t\tuv4( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3, u4, v4 );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_faces3_flat( nElements, offsetVertices, offsetMaterials ) {\n\n\t\t\tvar i, a, b, c, m;\n\n\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\n\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\ta = vertexIndexBuffer[ i * 3 ];\n\t\t\t\tb = vertexIndexBuffer[ i * 3 + 1 ];\n\t\t\t\tc = vertexIndexBuffer[ i * 3 + 2 ];\n\n\t\t\t\tm = materialIndexBuffer[ i ];\n\n\t\t\t\tf3( scope, a, b, c, m );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_faces4_flat( nElements, offsetVertices, offsetMaterials ) {\n\n\t\t\tvar i, a, b, c, d, m;\n\n\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\n\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\ta = vertexIndexBuffer[ i * 4 ];\n\t\t\t\tb = vertexIndexBuffer[ i * 4 + 1 ];\n\t\t\t\tc = vertexIndexBuffer[ i * 4 + 2 ];\n\t\t\t\td = vertexIndexBuffer[ i * 4 + 3 ];\n\n\t\t\t\tm = materialIndexBuffer[ i ];\n\n\t\t\t\tf4( scope, a, b, c, d, m );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_faces3_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\n\n\t\t\tvar i, a, b, c, m;\n\t\t\tvar na, nb, nc;\n\n\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\n\t\t\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 3 * nElements );\n\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\ta = vertexIndexBuffer[ i * 3 ];\n\t\t\t\tb = vertexIndexBuffer[ i * 3 + 1 ];\n\t\t\t\tc = vertexIndexBuffer[ i * 3 + 2 ];\n\n\t\t\t\tna = normalIndexBuffer[ i * 3 ];\n\t\t\t\tnb = normalIndexBuffer[ i * 3 + 1 ];\n\t\t\t\tnc = normalIndexBuffer[ i * 3 + 2 ];\n\n\t\t\t\tm = materialIndexBuffer[ i ];\n\n\t\t\t\tf3n( scope, normals, a, b, c, m, na, nb, nc );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_faces4_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\n\n\t\t\tvar i, a, b, c, d, m;\n\t\t\tvar na, nb, nc, nd;\n\n\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\n\t\t\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 4 * nElements );\n\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\n\n\t\t\tfor( i = 0; i < nElements; i ++ ) {\n\n\t\t\t\ta = vertexIndexBuffer[ i * 4 ];\n\t\t\t\tb = vertexIndexBuffer[ i * 4 + 1 ];\n\t\t\t\tc = vertexIndexBuffer[ i * 4 + 2 ];\n\t\t\t\td = vertexIndexBuffer[ i * 4 + 3 ];\n\n\t\t\t\tna = normalIndexBuffer[ i * 4 ];\n\t\t\t\tnb = normalIndexBuffer[ i * 4 + 1 ];\n\t\t\t\tnc = normalIndexBuffer[ i * 4 + 2 ];\n\t\t\t\tnd = normalIndexBuffer[ i * 4 + 3 ];\n\n\t\t\t\tm = materialIndexBuffer[ i ];\n\n\t\t\t\tf4n( scope, normals, a, b, c, d, m, na, nb, nc, nd );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_triangles_flat( start ) {\n\n\t\t\tvar nElements = md.ntri_flat;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\tinit_faces3_flat( nElements, start, offsetMaterials );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_triangles_flat_uv( start ) {\n\n\t\t\tvar nElements = md.ntri_flat_uv;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\tinit_faces3_flat( nElements, start, offsetMaterials );\n\t\t\t\tinit_uvs3( nElements, offsetUvs );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_triangles_smooth( start ) {\n\n\t\t\tvar nElements = md.ntri_smooth;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_triangles_smooth_uv( start ) {\n\n\t\t\tvar nElements = md.ntri_smooth_uv;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\n\t\t\t\tinit_uvs3( nElements, offsetUvs );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_quads_flat( start ) {\n\n\t\t\tvar nElements = md.nquad_flat;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\tinit_faces4_flat( nElements, start, offsetMaterials );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_quads_flat_uv( start ) {\n\n\t\t\tvar nElements = md.nquad_flat_uv;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\tinit_faces4_flat( nElements, start, offsetMaterials );\n\t\t\t\tinit_uvs4( nElements, offsetUvs );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_quads_smooth( start ) {\n\n\t\t\tvar nElements = md.nquad_smooth;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction init_quads_smooth_uv( start ) {\n\n\t\t\tvar nElements = md.nquad_smooth_uv;\n\n\t\t\tif ( nElements ) {\n\n\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\n\t\t\t\tinit_uvs4( nElements, offsetUvs );\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tfunction vertex ( scope, x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t};\n\n\tfunction f3 ( scope, a, b, c, mi ) {\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, mi ) );\n\n\t};\n\n\tfunction f4 ( scope, a, b, c, d, mi ) {\n\n\t\tscope.faces.push( new THREE.Face4( a, b, c, d, null, null, mi ) );\n\n\t};\n\n\tfunction f3n ( scope, normals, a, b, c, mi, na, nb, nc ) {\n\n\t\tvar nax = normals[ na*3     ],\n\t\t\tnay = normals[ na*3 + 1 ],\n\t\t\tnaz = normals[ na*3 + 2 ],\n\n\t\t\tnbx = normals[ nb*3     ],\n\t\t\tnby = normals[ nb*3 + 1 ],\n\t\t\tnbz = normals[ nb*3 + 2 ],\n\n\t\t\tncx = normals[ nc*3     ],\n\t\t\tncy = normals[ nc*3 + 1 ],\n\t\t\tncz = normals[ nc*3 + 2 ];\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c,\n\t\t\t\t\t\t  [new THREE.Vector3( nax, nay, naz ),\n\t\t\t\t\t\t   new THREE.Vector3( nbx, nby, nbz ),\n\t\t\t\t\t\t   new THREE.Vector3( ncx, ncy, ncz )],\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  mi ) );\n\n\t};\n\n\tfunction f4n ( scope, normals, a, b, c, d, mi, na, nb, nc, nd ) {\n\n\t\tvar nax = normals[ na*3     ],\n\t\t\tnay = normals[ na*3 + 1 ],\n\t\t\tnaz = normals[ na*3 + 2 ],\n\n\t\t\tnbx = normals[ nb*3     ],\n\t\t\tnby = normals[ nb*3 + 1 ],\n\t\t\tnbz = normals[ nb*3 + 2 ],\n\n\t\t\tncx = normals[ nc*3     ],\n\t\t\tncy = normals[ nc*3 + 1 ],\n\t\t\tncz = normals[ nc*3 + 2 ],\n\n\t\t\tndx = normals[ nd*3     ],\n\t\t\tndy = normals[ nd*3 + 1 ],\n\t\t\tndz = normals[ nd*3 + 2 ];\n\n\t\tscope.faces.push( new THREE.Face4( a, b, c, d,\n\t\t\t\t\t\t  [new THREE.Vector3( nax, nay, naz ),\n\t\t\t\t\t\t   new THREE.Vector3( nbx, nby, nbz ),\n\t\t\t\t\t\t   new THREE.Vector3( ncx, ncy, ncz ),\n\t\t\t\t\t\t   new THREE.Vector3( ndx, ndy, ndz )],\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  mi ) );\n\n\t};\n\n\tfunction uv3 ( where, u1, v1, u2, v2, u3, v3 ) {\n\n\t\tvar uv = [];\n\t\tuv.push( new THREE.UV( u1, v1 ) );\n\t\tuv.push( new THREE.UV( u2, v2 ) );\n\t\tuv.push( new THREE.UV( u3, v3 ) );\n\t\twhere.push( uv );\n\n\t};\n\n\tfunction uv4 ( where, u1, v1, u2, v2, u3, v3, u4, v4 ) {\n\n\t\tvar uv = [];\n\t\tuv.push( new THREE.UV( u1, v1 ) );\n\t\tuv.push( new THREE.UV( u2, v2 ) );\n\t\tuv.push( new THREE.UV( u3, v3 ) );\n\t\tuv.push( new THREE.UV( u4, v4 ) );\n\t\twhere.push( uv );\n\n\t};\n\n\tModel.prototype = Object.create( THREE.Geometry.prototype );\n\n\tcallback( new Model( texturePath ) );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function () {\n\n\tTHREE.EventTarget.call( this );\n\n\tthis.crossOrigin = null;\n\n};\n\nTHREE.ImageLoader.prototype = {\n\n\tconstructor: THREE.ImageLoader,\n\n\tload: function ( url, image ) {\n\n\t\tvar scope = this;\n\n\t\tif ( image === undefined ) image = new Image();\n\n\t\timage.addEventListener( 'load', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'load', content: image } );\n\n\t\t}, false );\n\n\t\timage.addEventListener( 'error', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\n\n\t\t}, false );\n\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\n\n\t\timage.src = url;\n\n\t}\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( showStatus ) {\n\n\tTHREE.Loader.call( this, showStatus );\n\n};\n\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\n\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\n\n\tvar scope = this;\n\n\ttexturePath = texturePath ? texturePath : this.extractUrlBase( url );\n\n\tthis.onLoadStart();\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\n\n};\n\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\n\n\tvar xhr = new XMLHttpRequest();\n\n\tvar length = 0;\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState === xhr.DONE ) {\n\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\n\n\t\t\t\tif ( xhr.responseText ) {\n\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\t\t\t\t\tcontext.createModel( json, callback, texturePath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\n\n\t\t\t\t}\n\n\t\t\t\t// in context of more complex asset initialization\n\t\t\t\t// do not block on single failed file\n\t\t\t\t// maybe should go even one more level up\n\n\t\t\t\tcontext.onLoadComplete();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\n\n\t\t\tif ( callbackProgress ) {\n\n\t\t\t\tif ( length === 0 ) {\n\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t\t\t}\n\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\n\n\t\t\t}\n\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\n\n\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.send( null );\n\n};\n\nTHREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {\n\n\tvar scope = this,\n\tgeometry = new THREE.Geometry(),\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\tthis.initMaterials( geometry, json.materials, texturePath );\n\n\tparseModel( scale );\n\n\tparseSkin();\n\tparseMorphing( scale );\n\n\tgeometry.computeCentroids();\n\tgeometry.computeFaceNormals();\n\n\tif ( this.hasNormals( geometry ) ) geometry.computeTangents();\n\n\n\tfunction parseModel( scale ) {\n\n\t\tfunction isBitSet( value, position ) {\n\n\t\t\treturn value & ( 1 << position );\n\n\t\t}\n\n\t\tvar i, j, fi,\n\n\t\toffset, zLength, nVertices,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\ttype,\n\t\tisQuad,\n\t\thasMaterial,\n\t\thasFaceUv, hasFaceVertexUv,\n\t\thasFaceNormal, hasFaceVertexNormal,\n\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, color, normal,\n\n\t\tuvLayer, uvs, u, v,\n\n\t\tfaces = json.faces,\n\t\tvertices = json.vertices,\n\t\tnormals = json.normals,\n\t\tcolors = json.colors,\n\n\t\tnUvLayers = 0;\n\n\t\t// disregard empty arrays\n\n\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\n\n\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t}\n\n\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\tgeometry.faceUvs[ i ] = [];\n\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\toffset = 0;\n\t\tzLength = vertices.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\tvertex = new THREE.Vector3();\n\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\tgeometry.vertices.push( vertex );\n\n\t\t}\n\n\t\toffset = 0;\n\t\tzLength = faces.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\tisQuad          \t= isBitSet( type, 0 );\n\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\thasFaceUv           = isBitSet( type, 2 );\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t//console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\tif ( isQuad ) {\n\n\t\t\t\tface = new THREE.Face4();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\t\t\t\tface.d = faces[ offset ++ ];\n\n\t\t\t\tnVertices = 4;\n\n\t\t\t} else {\n\n\t\t\t\tface = new THREE.Face3();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\tnVertices = 3;\n\n\t\t\t}\n\n\t\t\tif ( hasMaterial ) {\n\n\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t}\n\n\t\t\t// to get face <=> uv index correspondence\n\n\t\t\tfi = geometry.faces.length;\n\n\t\t\tif ( hasFaceUv ) {\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\tgeometry.faceUvs[ i ][ fi ] = new THREE.UV( u, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\n\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\tuvs = [];\n\n\t\t\t\t\tfor ( j = 0; j < nVertices; j ++ ) {\n\n\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\tuvs[ j ] = new THREE.UV( u, v );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = uvs;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\tnormal = new THREE.Vector3();\n\n\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\tface.normal = normal;\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\n\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\tnormal = new THREE.Vector3();\n\n\t\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tcolorIndex = faces[ offset ++ ];\n\n\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\n\t\t\t\tface.color = color;\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\n\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\n\t\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\n\t\t\t\t\tface.vertexColors.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.faces.push( face );\n\n\t\t}\n\n\t};\n\n\tfunction parseSkin() {\n\n\t\tvar i, l, x, y, z, w, a, b, c, d;\n\n\t\tif ( json.skinWeights ) {\n\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\n\n\t\t\t\tx = json.skinWeights[ i     ];\n\t\t\t\ty = json.skinWeights[ i + 1 ];\n\t\t\t\tz = 0;\n\t\t\t\tw = 0;\n\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.skinIndices ) {\n\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\n\n\t\t\t\ta = json.skinIndices[ i     ];\n\t\t\t\tb = json.skinIndices[ i + 1 ];\n\t\t\t\tc = 0;\n\t\t\t\td = 0;\n\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.bones = json.bones;\n\t\tgeometry.animation = json.animation;\n\n\t};\n\n\tfunction parseMorphing( scale ) {\n\n\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\n\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\n\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.morphColors !== undefined ) {\n\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\n\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\n\n\t\t\t\tgeometry.morphColors[ i ] = {};\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\n\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\n\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\n\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\n\t\t\t\t\tdstColors.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tcallback( geometry );\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingMonitor = function () {\n\n\tTHREE.EventTarget.call( this );\n\n\tvar scope = this;\n\n\tvar loaded = 0;\n\tvar total = 0;\n\n\tvar onLoad = function ( event ) {\n\n\t\tloaded ++;\n\n\t\tscope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );\n\n\t\tif ( loaded === total ) {\n\n\t\t\tscope.dispatchEvent( { type: 'load' } );\n\n\t\t}\n\n\t};\n\n\tthis.add = function ( loader ) {\n\n\t\ttotal ++;\n\n\t\tloader.addEventListener( 'load', onLoad, false );\n\n\t};\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.GeometryLoader = function () {\n\n\tTHREE.EventTarget.call( this );\n\n\tthis.crossOrigin = null;\n\tthis.path = null;\n\n\n};\n\nTHREE.GeometryLoader.prototype = {\n\n\tconstructor: THREE.GeometryLoader,\n\n\tload: function ( url ) {\n\n\t\tvar scope = this;\n\t\tvar geometry = null;\n\n\t\tif ( scope.path === null ) {\n\n\t\t\tvar parts = url.split( '/' ); parts.pop();\n\t\t\tscope.path = ( parts.length < 1 ? '.' : parts.join( '/' ) );\n\n\t\t}\n\n\t\t//\n\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.addEventListener( 'load', function ( event ) {\n\n\t\t\tif ( event.target.responseText ) {\n\n\t\t\t\tgeometry = scope.parse( JSON.parse( event.target.responseText ), monitor );\n\n\t\t\t} else {\n\n\t\t\t\tscope.dispatchEvent( { type: 'error', message: 'Invalid file [' + url + ']' } );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\txhr.addEventListener( 'error', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\n\n\t\t}, false );\n\n\t\txhr.open( 'GET', url, true );\n\t\txhr.send( null );\n\n\t\t//\n\n\t\tvar monitor = new THREE.LoadingMonitor();\n\n\t\tmonitor.addEventListener( 'load', function ( event ) {\n\n\t\t\tscope.dispatchEvent( { type: 'load', content: geometry } );\n\n\t\t} );\n\n\t\tmonitor.add( xhr );\n\n\t},\n\n\tparse: function ( data, monitor ) {\n\n\t\tvar scope = this;\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tvar scale = ( data.scale !== undefined ) ? 1 / data.scale : 1;\n\n\t\t// materials\n\n\t\tif ( data.materials ) {\n\n\t\t\tgeometry.materials = [];\n\n\t\t\tfor ( var i = 0; i < data.materials.length; ++ i ) {\n\n\t\t\t\tvar m = data.materials[ i ];\n\n\t\t\t\tfunction isPow2( n ) {\n\n\t\t\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\t\t\treturn Math.floor( l ) == l;\n\n\t\t\t\t}\n\n\t\t\t\tfunction nearestPow2( n ) {\n\n\t\t\t\t\tvar l = Math.log( n ) / Math.LN2;\n\t\t\t\t\treturn Math.pow( 2, Math.round(  l ) );\n\n\t\t\t\t}\n\n\t\t\t\tfunction createTexture( where, name, sourceFile, repeat, offset, wrap ) {\n\n\t\t\t\t\twhere[ name ] = new THREE.Texture();\n\t\t\t\t\twhere[ name ].sourceFile = sourceFile;\n\n\t\t\t\t\tif ( repeat ) {\n\n\t\t\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset ) {\n\n\t\t\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap ) {\n\n\t\t\t\t\t\tvar wrapMap = {\n\n\t\t\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\t\t\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\n\t\t\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// load image\n\n\t\t\t\t\tvar texture = where[ name ];\n\n\t\t\t\t\tvar loader = new THREE.ImageLoader();\n\t\t\t\t\tloader.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\t\tvar image = event.content;\n\n\t\t\t\t\t\tif ( !isPow2( image.width ) || !isPow2( image.height ) ) {\n\n\t\t\t\t\t\t\tvar width = nearestPow2( image.width );\n\t\t\t\t\t\t\tvar height = nearestPow2( image.height );\n\n\t\t\t\t\t\t\ttexture.image = document.createElement( 'canvas' );\n\t\t\t\t\t\t\ttexture.image.width = width;\n\t\t\t\t\t\t\ttexture.image.height = height;\n\t\t\t\t\t\t\ttexture.image.getContext( '2d' ).drawImage( image, 0, 0, width, height );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.image = image;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t} );\n\t\t\t\t\tloader.crossOrigin = scope.crossOrigin;\n\t\t\t\t\tloader.load( scope.path + '/' + sourceFile );\n\n\t\t\t\t\tif ( monitor ) monitor.add( loader );\n\n\t\t\t\t}\n\n\t\t\t\tfunction rgb2hex( rgb ) {\n\n\t\t\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\n\n\t\t\t\t}\n\n\t\t\t\t// defaults\n\n\t\t\t\tvar mtype = \"MeshLambertMaterial\";\n\t\t\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\n\n\t\t\t\t// parameters from model file\n\n\t\t\t\tif ( m.shading ) {\n\n\t\t\t\t\tvar shading = m.shading.toLowerCase();\n\n\t\t\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\n\t\t\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\n\n\t\t\t\t\tmpars.blending = THREE[ m.blending ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\n\n\t\t\t\t\tmpars.transparent = m.transparent;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.depthTest !== undefined ) {\n\n\t\t\t\t\tmpars.depthTest = m.depthTest;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.depthWrite !== undefined ) {\n\n\t\t\t\t\tmpars.depthWrite = m.depthWrite;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.vertexColors !== undefined ) {\n\n\t\t\t\t\tif ( m.vertexColors == \"face\" ) {\n\n\t\t\t\t\t\tmpars.vertexColors = THREE.FaceColors;\n\n\t\t\t\t\t} else if ( m.vertexColors ) {\n\n\t\t\t\t\t\tmpars.vertexColors = THREE.VertexColors;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// colors\n\n\t\t\t\tif ( m.colorDiffuse ) {\n\n\t\t\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\n\n\t\t\t\t} else if ( m.DbgColor ) {\n\n\t\t\t\t\tmpars.color = m.DbgColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.colorSpecular ) {\n\n\t\t\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.colorAmbient ) {\n\n\t\t\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\n\n\t\t\t\t}\n\n\t\t\t\t// modifiers\n\n\t\t\t\tif ( m.transparency ) {\n\n\t\t\t\t\tmpars.opacity = m.transparency;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.specularCoef ) {\n\n\t\t\t\t\tmpars.shininess = m.specularCoef;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.visible !== undefined ) {\n\n\t\t\t\t\tmpars.visible = m.visible;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.flipSided !== undefined ) {\n\n\t\t\t\t\tmpars.side = THREE.BackSide;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.doubleSided !== undefined ) {\n\n\t\t\t\t\tmpars.side = THREE.DoubleSide;\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.wireframe !== undefined ) {\n\n\t\t\t\t\tmpars.wireframe = m.wireframe;\n\n\t\t\t\t}\n\n\t\t\t\t// textures\n\n\t\t\t\tif ( m.mapDiffuse ) {\n\n\t\t\t\t\tcreateTexture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.mapLight ) {\n\n\t\t\t\t\tcreateTexture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.mapBump ) {\n\n\t\t\t\t\tcreateTexture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.mapNormal ) {\n\n\t\t\t\t\tcreateTexture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.mapSpecular ) {\n\n\t\t\t\t\tcreateTexture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap );\n\n\t\t\t\t}\n\n\t\t\t\t// special case for normal mapped material\n\n\t\t\t\tif ( m.mapNormal ) {\n\n\t\t\t\t\tvar shader = THREE.ShaderUtils.lib[ \"normal\" ];\n\t\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\n\n\t\t\t\t\tif ( m.mapNormalFactor ) {\n\n\t\t\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( mpars.map ) {\n\n\t\t\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\n\t\t\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( mpars.specularMap ) {\n\n\t\t\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\n\t\t\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( mpars.lightMap ) {\n\n\t\t\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\n\t\t\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for the moment don't handle displacement texture\n\n\t\t\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\n\t\t\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\n\t\t\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\n\n\t\t\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\n\n\t\t\t\t\tif ( mpars.opacity !== undefined ) {\n\n\t\t\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\t\t\t\t\tvar material = new THREE.ShaderMaterial( parameters );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar material = new THREE[ mtype ]( mpars );\n\n\t\t\t\t}\n\n\t\t\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\n\n\t\t\t\tgeometry.materials[ i ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction isBitSet( value, position ) {\n\n\t\t\treturn value & ( 1 << position );\n\n\t\t}\n\n\t\tvar faces = data.faces;\n\t\tvar vertices = data.vertices;\n\t\tvar normals = data.normals;\n\t\tvar colors = data.colors;\n\t\tvar nUvLayers = 0;\n\n\t\t// disregard empty arrays\n\n\t\tif ( data.uvs ) {\n\n\t\t\tfor ( var i = 0; i < data.uvs.length; i ++ ) {\n\n\t\t\t\tif ( data.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\tgeometry.faceUvs[ i ] = [];\n\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tvar offset = 0;\n\t\tvar zLength = vertices.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\tvar vertex = new THREE.Vector3();\n\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\tgeometry.vertices.push( vertex );\n\n\t\t}\n\n\t\toffset = 0;\n\t\tzLength = faces.length;\n\n\t\twhile ( offset < zLength ) {\n\n\t\t\tvar type = faces[ offset ++ ];\n\n\t\t\tvar isQuad = isBitSet( type, 0 );\n\n\t\t\tvar hasMaterial = isBitSet( type, 1 );\n\t\t\tvar hasFaceUv = isBitSet( type, 2 );\n\t\t\tvar hasFaceVertexUv = isBitSet( type, 3 );\n\t\t\tvar hasFaceNormal = isBitSet( type, 4 );\n\t\t\tvar hasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\tvar hasFaceColor = isBitSet( type, 6 );\n\t\t\tvar hasFaceVertexColor = isBitSet( type, 7 );\n\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\tif ( isQuad ) {\n\n\t\t\t\tvar face = new THREE.Face4();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\t\t\t\tface.d = faces[ offset ++ ];\n\n\t\t\t\tvar nVertices = 4;\n\n\t\t\t} else {\n\n\t\t\t\tvar face = new THREE.Face3();\n\n\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\tvar nVertices = 3;\n\n\t\t\t}\n\n\t\t\tif ( hasMaterial ) {\n\n\t\t\t\tvar materialIndex = faces[ offset ++ ];\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t}\n\n\t\t\t// to get face <=> uv index correspondence\n\n\t\t\tvar fi = geometry.faces.length;\n\n\t\t\tif ( hasFaceUv ) {\n\n\t\t\t\tfor ( var i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tvar uvLayer = data.uvs[ i ];\n\n\t\t\t\t\tvar uvIndex = faces[ offset ++ ];\n\n\t\t\t\t\tvar u = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\tvar v = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\tgeometry.faceUvs[ i ][ fi ] = new THREE.UV( u, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tfor ( var i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tvar uvLayer = data.uvs[ i ];\n\n\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\tfor ( var j = 0; j < nVertices; j ++ ) {\n\n\t\t\t\t\t\tvar uvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\tvar u = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\tvar v = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\tuvs[ j ] = new THREE.UV( u, v );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = uvs;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tvar normalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\tface.normal = normal;\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tfor ( i = 0; i < nVertices; i ++ ) {\n\n\t\t\t\t\tvar normalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\t\tnormal.x = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.y = normals[ normalIndex ++ ];\n\t\t\t\t\tnormal.z = normals[ normalIndex ];\n\n\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tvar colorIndex = faces[ offset ++ ];\n\n\t\t\t\tface.color = new THREE.Color( colors[ colorIndex ] );\n\n\t\t\t}\n\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\t\t\tvar colorIndex = faces[ offset ++ ];\n\n\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.faces.push( face );\n\n\t\t}\n\n\n\t\t// skin\n\n\t\tif ( data.skinWeights ) {\n\n\t\t\tfor ( var i = 0, l = data.skinWeights.length; i < l; i += 2 ) {\n\n\t\t\t\tvar x = data.skinWeights[ i ];\n\t\t\t\tvar y = data.skinWeights[ i + 1 ];\n\t\t\t\tvar z = 0;\n\t\t\t\tvar w = 0;\n\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.skinIndices ) {\n\n\t\t\tfor ( var i = 0, l = data.skinIndices.length; i < l; i += 2 ) {\n\n\t\t\t\tvar a = data.skinIndices[ i ];\n\t\t\t\tvar b = data.skinIndices[ i + 1 ];\n\t\t\t\tvar c = 0;\n\t\t\t\tvar d = 0;\n\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.bones = data.bones;\n\t\tgeometry.animation = data.animation;\n\n\n\t\t// morphing\n\n\t\tif ( data.morphTargets ) {\n\n\t\t\tfor ( var i = 0, l = data.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\tgeometry.morphTargets[ i ].name = data.morphTargets[ i ].name;\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\tvar srcVertices = data.morphTargets [ i ].vertices;\n\n\t\t\t\tfor( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.morphColors ) {\n\n\t\t\tfor ( var i = 0, l = data.morphColors.length; i < l; i++ ) {\n\n\t\t\t\tgeometry.morphColors[ i ] = {};\n\t\t\t\tgeometry.morphColors[ i ].name = data.morphColors[ i ].name;\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\n\n\t\t\t\tvar dstColors = geometry.morphColors[ i ].colors;\n\t\t\t\tvar srcColors = data.morphColors [ i ].colors;\n\n\t\t\t\tfor ( var c = 0, cl = srcColors.length; c < cl; c += 3 ) {\n\n\t\t\t\t\tvar color = new THREE.Color( 0xffaa00 );\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\n\n\t\t\t\t\tdstColors.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.computeCentroids();\n\t\tgeometry.computeFaceNormals();\n\n\t\treturn geometry;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneLoader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function() {};\n\tthis.onLoadComplete = function () {};\n\n\tthis.callbackSync = function () {};\n\tthis.callbackProgress = function () {};\n\n\tthis.geometryHandlerMap = {};\n\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\n\tthis.addGeometryHandler( \"binary\", THREE.BinaryLoader );\n\n};\n\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\n\nTHREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {\n\n\tvar scope = this;\n\n\tvar xhr = new XMLHttpRequest();\n\n\txhr.onreadystatechange = function () {\n\n\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\n\n\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\t\t\t\tscope.parse( json, callbackFinished, url );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.SceneLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\txhr.open( \"GET\", url, true );\n\txhr.send( null );\n\n};\n\nTHREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {\n\n\tthis.geometryHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\n\n};\n\nTHREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {\n\n\tvar scope = this;\n\n\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\n\n\tvar dg, dm, dl, dc, df, dt,\n\t\tg, m, l, d, p, r, q, s, c, t, f, tt, pp, u,\n\t\tgeometry, material, camera, fog,\n\t\ttexture, images,\n\t\tlight,\n\t\tcounter_models, counter_textures,\n\t\ttotal_models, total_textures,\n\t\tresult;\n\n\tvar data = json;\n\n\t// async geometry loaders\n\n\tfor ( var typeID in this.geometryHandlerMap ) {\n\n\t\tvar loaderClass = this.geometryHandlerMap[ typeID ][ \"loaderClass\" ];\n\t\tthis.geometryHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t}\n\n\tcounter_models = 0;\n\tcounter_textures = 0;\n\n\tresult = {\n\n\t\tscene: new THREE.Scene(),\n\t\tgeometries: {},\n\t\tmaterials: {},\n\t\ttextures: {},\n\t\tobjects: {},\n\t\tcameras: {},\n\t\tlights: {},\n\t\tfogs: {},\n\t\tempties: {}\n\n\t};\n\n\tif ( data.transform ) {\n\n\t\tvar position = data.transform.position,\n\t\t\trotation = data.transform.rotation,\n\t\t\tscale = data.transform.scale;\n\n\t\tif ( position )\n\t\t\tresult.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );\n\n\t\tif ( rotation )\n\t\t\tresult.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );\n\n\t\tif ( scale )\n\t\t\tresult.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );\n\n\t\tif ( position || rotation || scale ) {\n\n\t\t\tresult.scene.updateMatrix();\n\t\t\tresult.scene.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tfunction get_url( source_url, url_type ) {\n\n\t\tif ( url_type == \"relativeToHTML\" ) {\n\n\t\t\treturn source_url;\n\n\t\t} else {\n\n\t\t\treturn urlBase + \"/\" + source_url;\n\n\t\t}\n\n\t};\n\n\t// toplevel loader function, delegates to handle_children\n\n\tfunction handle_objects() {\n\n\t\thandle_children( result.scene, data.objects );\n\n\t}\n\n\t// handle all the children from the loaded json and attach them to given parent\n\n\tfunction handle_children( parent, children ) {\n\n\t\tfor ( var dd in children ) {\n\n\t\t\t// check by id if child has already been handled,\n\t\t\t// if not, create new object\n\n\t\t\tif ( result.objects[ dd ] === undefined ) {\n\n\t\t\t\tvar o = children[ dd ];\n\n\t\t\t\tvar object = null;\n\n\t\t\t\tif ( o.geometry !== undefined ) {\n\n\t\t\t\t\tgeometry = result.geometries[ o.geometry ];\n\n\t\t\t\t\t// geometry already loaded\n\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tvar hasNormals = false;\n\n\t\t\t\t\t\t// not anymore support for multiple materials\n\t\t\t\t\t\t// shouldn't really be array\n\n\t\t\t\t\t\tmaterial = result.materials[ o.materials[ 0 ] ];\n\t\t\t\t\t\thasNormals = material instanceof THREE.ShaderMaterial;\n\n\t\t\t\t\t\tif ( hasNormals ) {\n\n\t\t\t\t\t\t\tgeometry.computeTangents();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = o.position;\n\t\t\t\t\t\tr = o.rotation;\n\t\t\t\t\t\tq = o.quaternion;\n\t\t\t\t\t\ts = o.scale;\n\t\t\t\t\t\tm = o.matrix;\n\n\t\t\t\t\t\t// turn off quaternions, for the moment\n\n\t\t\t\t\t\tq = 0;\n\n\t\t\t\t\t\tif ( o.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// dirty hack to handle meshes with multiple materials\n\t\t\t\t\t\t// just use face materials defined in model\n\n\t\t\t\t\t\tif ( o.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( o.morph ) {\n\n\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\n\n\t\t\t\t\t\t\tif ( o.duration !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.duration = o.duration;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( o.time !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.time = o.time;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( o.mirroredLoop !== undefined ) {\n\n\t\t\t\t\t\t\t\tobject.mirroredLoop = o.mirroredLoop;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.name = dd;\n\n\t\t\t\t\t\tif ( m ) {\n\n\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tobject.matrix.set(\n\t\t\t\t\t\t\t\tm[0], m[1], m[2], m[3],\n\t\t\t\t\t\t\t\tm[4], m[5], m[6], m[7],\n\t\t\t\t\t\t\t\tm[8], m[9], m[10], m[11],\n\t\t\t\t\t\t\t\tm[12], m[13], m[14], m[15]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.position.set( p[0], p[1], p[2] );\n\n\t\t\t\t\t\t\tif ( q ) {\n\n\t\t\t\t\t\t\t\tobject.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\t\t\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.rotation.set( r[0], r[1], r[2] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.scale.set( s[0], s[1], s[2] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.visible = o.visible;\n\t\t\t\t\t\tobject.castShadow = o.castShadow;\n\t\t\t\t\t\tobject.receiveShadow = o.receiveShadow;\n\n\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\tresult.objects[ dd ] = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t// pure Object3D\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = o.position;\n\t\t\t\t\tr = o.rotation;\n\t\t\t\t\tq = o.quaternion;\n\t\t\t\t\ts = o.scale;\n\n\t\t\t\t\t// turn off quaternions, for the moment\n\n\t\t\t\t\tq = 0;\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\t\tobject.name = dd;\n\t\t\t\t\tobject.position.set( p[0], p[1], p[2] );\n\n\t\t\t\t\tif ( q ) {\n\n\t\t\t\t\t\tobject.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.rotation.set( r[0], r[1], r[2] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.scale.set( s[0], s[1], s[2] );\n\t\t\t\t\tobject.visible = ( o.visible !== undefined ) ? o.visible : false;\n\n\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\tresult.objects[ dd ] = object;\n\t\t\t\t\tresult.empties[ dd ] = object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object ) {\n\n\t\t\t\t\tif ( o.properties !== undefined )  {\n\n\t\t\t\t\t\tfor ( var key in o.properties ) {\n\n\t\t\t\t\t\t\tvar value = o.properties[ key ];\n\t\t\t\t\t\t\tobject.properties[ key ] = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( o.children !== undefined ) {\n\n\t\t\t\t\t\thandle_children( object, o.children );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction handle_mesh( geo, id ) {\n\n\t\tresult.geometries[ id ] = geo;\n\t\thandle_objects();\n\n\t};\n\n\tfunction create_callback( id ) {\n\n\t\treturn function( geo ) {\n\n\t\t\thandle_mesh( geo, id );\n\n\t\t\tcounter_models -= 1;\n\n\t\t\tscope.onLoadComplete();\n\n\t\t\tasync_callback_gate();\n\n\t\t}\n\n\t};\n\n\tfunction create_callback_embed( id ) {\n\n\t\treturn function( geo ) {\n\n\t\t\tresult.geometries[ id ] = geo;\n\n\t\t}\n\n\t};\n\n\tfunction async_callback_gate() {\n\n\t\tvar progress = {\n\n\t\t\ttotalModels : total_models,\n\t\t\ttotalTextures : total_textures,\n\t\t\tloadedModels : total_models - counter_models,\n\t\t\tloadedTextures : total_textures - counter_textures\n\n\t\t};\n\n\t\tscope.callbackProgress( progress, result );\n\n\t\tscope.onLoadProgress();\n\n\t\tif ( counter_models === 0 && counter_textures === 0 ) {\n\n\t\t\tcallbackFinished( result );\n\n\t\t}\n\n\t};\n\n\tvar callbackTexture = function ( count ) {\n\n\t\tcounter_textures -= count;\n\t\tasync_callback_gate();\n\n\t\tscope.onLoadComplete();\n\n\t};\n\n\t// must use this instead of just directly calling callbackTexture\n\t// because of closure in the calling context loop\n\n\tvar generateTextureCallback = function ( count ) {\n\n\t\treturn function() {\n\n\t\t\tcallbackTexture( count );\n\n\t\t};\n\n\t};\n\n\t// first go synchronous elements\n\n\t// cameras\n\n\tfor( dc in data.cameras ) {\n\n\t\tc = data.cameras[ dc ];\n\n\t\tif ( c.type === \"perspective\" ) {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( c.fov, c.aspect, c.near, c.far );\n\n\t\t} else if ( c.type === \"ortho\" ) {\n\n\t\t\tcamera = new THREE.OrthographicCamera( c.left, c.right, c.top, c.bottom, c.near, c.far );\n\n\t\t}\n\n\t\tp = c.position;\n\t\tt = c.target;\n\t\tu = c.up;\n\n\t\tcamera.position.set( p[0], p[1], p[2] );\n\t\tcamera.target = new THREE.Vector3( t[0], t[1], t[2] );\n\t\tif ( u ) camera.up.set( u[0], u[1], u[2] );\n\n\t\tresult.cameras[ dc ] = camera;\n\n\t}\n\n\t// lights\n\n\tvar hex, intensity;\n\n\tfor ( dl in data.lights ) {\n\n\t\tl = data.lights[ dl ];\n\n\t\thex = ( l.color !== undefined ) ? l.color : 0xffffff;\n\t\tintensity = ( l.intensity !== undefined ) ? l.intensity : 1;\n\n\t\tif ( l.type === \"directional\" ) {\n\n\t\t\tp = l.direction;\n\n\t\t\tlight = new THREE.DirectionalLight( hex, intensity );\n\t\t\tlight.position.set( p[0], p[1], p[2] );\n\t\t\tlight.position.normalize();\n\n\t\t} else if ( l.type === \"point\" ) {\n\n\t\t\tp = l.position;\n\t\t\td = l.distance;\n\n\t\t\tlight = new THREE.PointLight( hex, intensity, d );\n\t\t\tlight.position.set( p[0], p[1], p[2] );\n\n\t\t} else if ( l.type === \"ambient\" ) {\n\n\t\t\tlight = new THREE.AmbientLight( hex );\n\n\t\t}\n\n\t\tresult.scene.add( light );\n\n\t\tresult.lights[ dl ] = light;\n\n\t}\n\n\t// fogs\n\n\tfor( df in data.fogs ) {\n\n\t\tf = data.fogs[ df ];\n\n\t\tif ( f.type === \"linear\" ) {\n\n\t\t\tfog = new THREE.Fog( 0x000000, f.near, f.far );\n\n\t\t} else if ( f.type === \"exp2\" ) {\n\n\t\t\tfog = new THREE.FogExp2( 0x000000, f.density );\n\n\t\t}\n\n\t\tc = f.color;\n\t\tfog.color.setRGB( c[0], c[1], c[2] );\n\n\t\tresult.fogs[ df ] = fog;\n\n\t}\n\n\t// defaults\n\n\tif ( result.cameras && data.defaults.camera ) {\n\n\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\n\n\t}\n\n\tif ( result.fogs && data.defaults.fog ) {\n\n\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\n\n\t}\n\n\tc = data.defaults.bgcolor;\n\tresult.bgColor = new THREE.Color();\n\tresult.bgColor.setRGB( c[0], c[1], c[2] );\n\n\tresult.bgColorAlpha = data.defaults.bgalpha;\n\n\t// now come potentially asynchronous elements\n\n\t// geometries\n\n\t// count how many models will be loaded asynchronously\n\n\tfor( dg in data.geometries ) {\n\n\t\tg = data.geometries[ dg ];\n\n\t\tif ( g.type in this.geometryHandlerMap ) {\n\n\t\t\tcounter_models += 1;\n\n\t\t\tscope.onLoadStart();\n\n\t\t}\n\n\t}\n\n\ttotal_models = counter_models;\n\n\tfor ( dg in data.geometries ) {\n\n\t\tg = data.geometries[ dg ];\n\n\t\tif ( g.type === \"cube\" ) {\n\n\t\t\tgeometry = new THREE.CubeGeometry( g.width, g.height, g.depth, g.segmentsWidth, g.segmentsHeight, g.segmentsDepth, null, g.flipped, g.sides );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type === \"plane\" ) {\n\n\t\t\tgeometry = new THREE.PlaneGeometry( g.width, g.height, g.segmentsWidth, g.segmentsHeight );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type === \"sphere\" ) {\n\n\t\t\tgeometry = new THREE.SphereGeometry( g.radius, g.segmentsWidth, g.segmentsHeight );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type === \"cylinder\" ) {\n\n\t\t\tgeometry = new THREE.CylinderGeometry( g.topRad, g.botRad, g.height, g.radSegs, g.heightSegs );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type === \"torus\" ) {\n\n\t\t\tgeometry = new THREE.TorusGeometry( g.radius, g.tube, g.segmentsR, g.segmentsT );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type === \"icosahedron\" ) {\n\n\t\t\tgeometry = new THREE.IcosahedronGeometry( g.radius, g.subdivisions );\n\t\t\tresult.geometries[ dg ] = geometry;\n\n\t\t} else if ( g.type in this.geometryHandlerMap ) {\n\n\t\t\tvar loaderParameters = {};\n\t\t\tfor ( var parType in g ) {\n\n\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\n\n\t\t\t\t\tloaderParameters[ parType ] = g[ parType ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar loader = this.geometryHandlerMap[ g.type ][ \"loaderObject\" ];\n\t\t\tloader.load( get_url( g.url, data.urlBaseType ), create_callback( dg ), loaderParameters );\n\n\t\t} else if ( g.type === \"embedded\" ) {\n\n\t\t\tvar modelJson = data.embeds[ g.id ],\n\t\t\t\ttexture_path = \"\";\n\n\t\t\t// pass metadata along to jsonLoader so it knows the format version\n\n\t\t\tmodelJson.metadata = data.metadata;\n\n\t\t\tif ( modelJson ) {\n\n\t\t\t\tvar jsonLoader = this.geometryHandlerMap[ \"ascii\" ][ \"loaderObject\" ];\n\t\t\t\tjsonLoader.createModel( modelJson, create_callback_embed( dg ), texture_path );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// textures\n\n\t// count how many textures will be loaded asynchronously\n\n\tfor( dt in data.textures ) {\n\n\t\ttt = data.textures[ dt ];\n\n\t\tif( tt.url instanceof Array ) {\n\n\t\t\tcounter_textures += tt.url.length;\n\n\t\t\tfor( var n = 0; n < tt.url.length; n ++ ) {\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcounter_textures += 1;\n\n\t\t\tscope.onLoadStart();\n\n\t\t}\n\n\t}\n\n\ttotal_textures = counter_textures;\n\n\tfor ( dt in data.textures ) {\n\n\t\ttt = data.textures[ dt ];\n\n\t\tif ( tt.mapping !== undefined && THREE[ tt.mapping ] !== undefined  ) {\n\n\t\t\ttt.mapping = new THREE[ tt.mapping ]();\n\n\t\t}\n\n\t\tif ( tt.url instanceof Array ) {\n\n\t\t\tvar count = tt.url.length;\n\t\t\tvar url_array = [];\n\n\t\t\tfor( var i = 0; i < count; i ++ ) {\n\n\t\t\t\turl_array[ i ] = get_url( tt.url[ i ], data.urlBaseType );\n\n\t\t\t}\n\n\t\t\tvar isCompressed = url_array[ 0 ].endsWith( \".dds\" );\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, tt.mapping, generateTextureCallback( count ) );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, tt.mapping, generateTextureCallback( count ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar isCompressed = tt.url.toLowerCase().endsWith( \".dds\" );\n\t\t\tvar fullUrl = get_url( tt.url, data.urlBaseType );\n\t\t\tvar textureCallback = generateTextureCallback( 1 );\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, tt.mapping, textureCallback );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, tt.mapping, textureCallback );\n\n\t\t\t}\n\n\t\t\tif ( THREE[ tt.minFilter ] !== undefined )\n\t\t\t\ttexture.minFilter = THREE[ tt.minFilter ];\n\n\t\t\tif ( THREE[ tt.magFilter ] !== undefined )\n\t\t\t\ttexture.magFilter = THREE[ tt.magFilter ];\n\n\t\t\tif ( tt.anisotropy ) texture.anisotropy = tt.anisotropy;\n\n\t\t\tif ( tt.repeat ) {\n\n\t\t\t\ttexture.repeat.set( tt.repeat[ 0 ], tt.repeat[ 1 ] );\n\n\t\t\t\tif ( tt.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\tif ( tt.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t}\n\n\t\t\tif ( tt.offset ) {\n\n\t\t\t\ttexture.offset.set( tt.offset[ 0 ], tt.offset[ 1 ] );\n\n\t\t\t}\n\n\t\t\t// handle wrap after repeat so that default repeat can be overriden\n\n\t\t\tif ( tt.wrap ) {\n\n\t\t\t\tvar wrapMap = {\n\t\t\t\t\"repeat\" \t: THREE.RepeatWrapping,\n\t\t\t\t\"mirror\"\t: THREE.MirroredRepeatWrapping\n\t\t\t\t}\n\n\t\t\t\tif ( wrapMap[ tt.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ tt.wrap[ 0 ] ];\n\t\t\t\tif ( wrapMap[ tt.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ tt.wrap[ 1 ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.textures[ dt ] = texture;\n\n\t}\n\n\t// materials\n\n\tfor ( dm in data.materials ) {\n\n\t\tm = data.materials[ dm ];\n\n\t\tfor ( pp in m.parameters ) {\n\n\t\t\tif ( pp === \"envMap\" || pp === \"map\" || pp === \"lightMap\" || pp === \"bumpMap\" ) {\n\n\t\t\t\tm.parameters[ pp ] = result.textures[ m.parameters[ pp ] ];\n\n\t\t\t} else if ( pp === \"shading\" ) {\n\n\t\t\t\tm.parameters[ pp ] = ( m.parameters[ pp ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\n\n\t\t\t} else if ( pp === \"side\" ) {\n\n\t\t\t\tif (  m.parameters[ pp ] == \"double\" ) {\n\n\t\t\t\t\tm.parameters[ pp ] = THREE.DoubleSide;\n\n\t\t\t\t} else if ( m.parameters[ pp ] == \"back\" ) {\n\n\t\t\t\t\tm.parameters[ pp ] = THREE.BackSide;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tm.parameters[ pp ] = THREE.FrontSide;\n\n\t\t\t\t}\n\n\t\t\t} else if ( pp === \"blending\" ) {\n\n\t\t\t\tm.parameters[ pp ] = m.parameters[ pp ] in THREE ? THREE[ m.parameters[ pp ] ] : THREE.NormalBlending;\n\n\t\t\t} else if ( pp === \"combine\" ) {\n\n\t\t\t\tm.parameters[ pp ] = ( m.parameters[ pp ] == \"MixOperation\" ) ? THREE.MixOperation : THREE.MultiplyOperation;\n\n\t\t\t} else if ( pp === \"vertexColors\" ) {\n\n\t\t\t\tif ( m.parameters[ pp ] == \"face\" ) {\n\n\t\t\t\t\tm.parameters[ pp ] = THREE.FaceColors;\n\n\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\n\n\t\t\t\t} else if ( m.parameters[ pp ] )   {\n\n\t\t\t\t\tm.parameters[ pp ] = THREE.VertexColors;\n\n\t\t\t\t}\n\n\t\t\t} else if ( pp === \"wrapRGB\" ) {\n\n\t\t\t\tvar v3 = m.parameters[ pp ];\n\t\t\t\tm.parameters[ pp ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( m.parameters.opacity !== undefined && m.parameters.opacity < 1.0 ) {\n\n\t\t\tm.parameters.transparent = true;\n\n\t\t}\n\n\t\tif ( m.parameters.normalMap ) {\n\n\t\t\tvar shader = THREE.ShaderUtils.lib[ \"normal\" ];\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tvar diffuse = m.parameters.color;\n\t\t\tvar specular = m.parameters.specular;\n\t\t\tvar ambient = m.parameters.ambient;\n\t\t\tvar shininess = m.parameters.shininess;\n\n\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ m.parameters.normalMap ];\n\n\t\t\tif ( m.parameters.normalScale ) {\n\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.parameters.normalScale[ 0 ], m.parameters.normalScale[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( m.parameters.map ) {\n\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = m.parameters.map;\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( m.parameters.envMap ) {\n\n\t\t\t\tuniforms[ \"tCube\" ].value = m.parameters.envMap;\n\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\n\t\t\t\tuniforms[ \"uReflectivity\" ].value = m.parameters.reflectivity;\n\n\t\t\t}\n\n\t\t\tif ( m.parameters.lightMap ) {\n\n\t\t\t\tuniforms[ \"tAO\" ].value = m.parameters.lightMap;\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( m.parameters.specularMap ) {\n\n\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ m.parameters.specularMap ];\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t}\n\n\t\t\tif ( m.parameters.displacementMap ) {\n\n\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ m.parameters.displacementMap ];\n\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\n\n\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = m.parameters.displacementBias;\n\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = m.parameters.displacementScale;\n\n\t\t\t}\n\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( diffuse );\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( specular );\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( ambient );\n\n\t\t\tuniforms[ \"uShininess\" ].value = shininess;\n\n\t\t\tif ( m.parameters.opacity ) {\n\n\t\t\t\tuniforms[ \"uOpacity\" ].value = m.parameters.opacity;\n\n\t\t\t}\n\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\n\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\n\n\t\t} else {\n\n\t\t\tmaterial = new THREE[ m.type ]( m.parameters );\n\n\t\t}\n\n\t\tresult.materials[ dm ] = material;\n\n\t}\n\n\t// objects ( synchronous init of procedural primitives )\n\n\thandle_objects();\n\n\t// synchronous callback\n\n\tscope.callbackSync( result );\n\n\t// just in case there are no async elements\n\n\tasync_callback_gate();\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function () {\n\n\tTHREE.EventTarget.call( this );\n\n\tthis.crossOrigin = null;\n\n};\n\nTHREE.TextureLoader.prototype = {\n\n\tconstructor: THREE.TextureLoader,\n\n\tload: function ( url ) {\n\n\t\tvar scope = this;\n\n\t\tvar image = new Image();\n\n\t\timage.addEventListener( 'load', function () {\n\n\t\t\tvar texture = new THREE.Texture( image );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tscope.dispatchEvent( { type: 'load', content: texture } );\n\n\t\t}, false );\n\n\t\timage.addEventListener( 'error', function () {\n\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\n\n\t\t}, false );\n\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\n\n\t\timage.src = url;\n\n\t}\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tTHREE.MaterialLibrary.push( this );\n\n\tthis.id = THREE.MaterialIdCount ++;\n\n\tthis.name = '';\n\n\tthis.side = THREE.FrontSide;\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blending = THREE.NormalBlending;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\n\tthis.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.Material.prototype.setValues = function ( values ) {\n\n\tif ( values === undefined ) return;\n\n\tfor ( var key in values ) {\n\n\t\tvar newValue = values[ key ];\n\n\t\tif ( newValue === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif ( key in this ) {\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Color && typeof( newValue ) === \"number\" ) {\n\n\t\t\t\tcurrentValue.setHex( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Material.prototype.clone = function ( material ) {\n\n\tif ( material === undefined ) material = new THREE.Material();\n\n\tmaterial.name = this.name;\n\n\tmaterial.side = this.side;\n\n\tmaterial.opacity = this.opacity;\n\tmaterial.transparent = this.transparent;\n\n\tmaterial.blending = this.blending;\n\n\tmaterial.blendSrc = this.blendSrc;\n\tmaterial.blendDst = this.blendDst;\n\tmaterial.blendEquation = this.blendEquation;\n\n\tmaterial.depthTest = this.depthTest;\n\tmaterial.depthWrite = this.depthWrite;\n\n\tmaterial.polygonOffset = this.polygonOffset;\n\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\n\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\tmaterial.alphaTest = this.alphaTest;\n\n\tmaterial.overdraw = this.overdraw;\n\n\tmaterial.visible = this.visible;\n\n\treturn material;\n\n};\n\nTHREE.Material.prototype.deallocate = function () {\n\n\tvar index = THREE.MaterialLibrary.indexOf( this );\n\tif ( index !== -1 ) THREE.MaterialLibrary.splice( index, 1 );\n\n};\n\nTHREE.MaterialIdCount = 0;\nTHREE.MaterialLibrary = [];\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\",\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\tmaterial.linecap = this.linecap;\n\tmaterial.linejoin = this.linejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshLambertMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.metal = false;\n\tthis.perPixel = false;\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshPhongMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\tmaterial.specular.copy( this.specular );\n\tmaterial.shininess = this.shininess;\n\n\tmaterial.metal = this.metal;\n\tmaterial.perPixel = this.perPixel;\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.bumpMap = this.bumpMap;\n\tmaterial.bumpScale = this.bumpScale;\n\n\tmaterial.normalMap = this.normalMap;\n\tmaterial.normalScale.copy( this.normalScale );\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  opacity: <float>,\n\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n\n *  shading: THREE.FlatShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.shading = THREE.FlatShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshNormalMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshNormalMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MeshFaceMaterial = function () {};\n\nTHREE.MeshFaceMaterial.prototype.clone = function () {\n\n\treturn new THREE.MeshFaceMaterial();\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  vertexColors: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.ParticleBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.size = this.size;\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <hex>,\n *  program: <function>,\n *  opacity: <float>,\n *  blending: THREE.NormalBlending\n * }\n */\n\nTHREE.ParticleCanvasMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.program = function ( context, color ) {};\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleCanvasMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.program = this.program;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ParticleDOMMaterial = function ( element ) {\n\n\tthis.element = element;\n\n};\n\nTHREE.ParticleDOMMaterial.prototype.clone = function(){\n\n\treturn new THREE.ParticleDOMMaterial( this.element );\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n *\n *  defines: { \"label\" : \"value\" },\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.fragmentShader = \"void main() {}\";\n\tthis.vertexShader = \"void main() {}\";\n\tthis.uniforms = {};\n\tthis.defines = {};\n\tthis.attributes = null;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\n\tthis.lights = false; // set to use scene lights\n\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ShaderMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ShaderMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.fragmentShader = this.fragmentShader;\n\tmaterial.vertexShader = this.vertexShader;\n\tmaterial.uniforms = this.uniforms;\n\tmaterial.attributes = this.attributes;\n\tmaterial.defines = this.defines;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.lights = this.lights;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.TextureLibrary.push( this );\n\n\tthis.id = THREE.TextureIdCount ++;\n\n\tthis.image = image;\n\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\n\tthis.needsUpdate = false;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tclone: function () {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\ttexture.image = this.image;\n\n\t\ttexture.mapping = this.mapping;\n\n\t\ttexture.wrapS = this.wrapS;\n\t\ttexture.wrapT = this.wrapT;\n\n\t\ttexture.magFilter = this.magFilter;\n\t\ttexture.minFilter = this.minFilter;\n\n\t\ttexture.anisotropy = this.anisotropy;\n\n\t\ttexture.format = this.format;\n\t\ttexture.type = this.type;\n\n\t\ttexture.offset.copy( this.offset );\n\t\ttexture.repeat.copy( this.repeat );\n\n\t\ttexture.generateMipmaps = this.generateMipmaps;\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\n\t\ttexture.flipY = this.flipY;\n\n\t\treturn texture;\n\n\t},\n\n\tdeallocate: function () {\n\n\t\tvar index = THREE.TextureLibrary.indexOf( this );\n\t\tif ( index !== -1 ) THREE.TextureLibrary.splice( index, 1 );\n\n\t}\n\n};\n\nTHREE.TextureIdCount = 0;\nTHREE.TextureLibrary = [];\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.CompressedTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.CompressedTexture();\n\n\ttexture.image = this.image;\n\ttexture.mipmaps = this.mipmaps;\n\n\ttexture.format = this.format;\n\ttexture.type = this.type;\n\n\ttexture.mapping = this.mapping;\n\n\ttexture.wrapS = this.wrapS;\n\ttexture.wrapT = this.wrapT;\n\n\ttexture.magFilter = this.magFilter;\n\ttexture.minFilter = this.minFilter;\n\n\ttexture.anisotropy = this.anisotropy;\n\n\ttexture.offset.copy( this.offset );\n\ttexture.repeat.copy( this.repeat );\n\n\treturn texture;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type );\n\n\tthis.image = { data: data, width: width, height: height };\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.DataTexture.prototype.clone = function () {\n\n\tvar clonedTexture = new THREE.DataTexture( this.image.data,  this.image.width, this.image.height, this.format, this.type, this.mapping, this.wrapS, this.wrapT, this.magFilter, this.minFilter );\n\n\tclonedTexture.offset.copy( this.offset );\n\tclonedTexture.repeat.copy( this.repeat );\n\n\treturn clonedTexture;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Particle = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\n};\n\nTHREE.Particle.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Particle.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Particle( this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParticleSystem = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.sortParticles = false;\n\n\tif ( this.geometry ) {\n\n\t\t// calc bound radius\n\n\t\tif( this.geometry.boundingSphere === null ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundRadius = geometry.boundingSphere.radius;\n\n\t}\n\n\tthis.frustumCulled = false;\n\n};\n\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\n\tobject.sortParticles = this.sortParticles;\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, type ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\n\n\tif ( this.geometry ) {\n\n\t\tif ( ! this.geometry.boundingSphere ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\n\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Line.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );\n\n\tif ( this.geometry ) {\n\n\t\t// calc bound radius\n\n\t\tif ( this.geometry.boundingSphere === null ) {\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundRadius = geometry.boundingSphere.radius;\n\n\n\t\t// setup morph targets\n\n\t\tif ( this.geometry.morphTargets.length ) {\n\n\t\t\tthis.morphTargetBase = -1;\n\t\t\tthis.morphTargetForcedOrder = [];\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor( var m = 0; m < this.geometry.morphTargets.length; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\n\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\treturn this.morphTargetDictionary[ name ];\n\n\t}\n\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\n\n\treturn 0;\n\n};\n\nTHREE.Mesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Bone = function( belongsToSkin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.skin = belongsToSkin;\n\tthis.skinMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Bone.prototype.update = function( parentSkinMatrix, forceUpdate ) {\n\n\t// update local\n\n\tif ( this.matrixAutoUpdate ) {\n\n\t\tforceUpdate |= this.updateMatrix();\n\n\t}\n\n\t// update skin matrix\n\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\n\n\t\tif( parentSkinMatrix ) {\n\n\t\t\tthis.skinMatrix.multiply( parentSkinMatrix, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.skinMatrix.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\tforceUpdate = true;\n\n\t}\n\n\t// update children\n\n\tvar child, i, l = this.children.length;\n\n\tfor ( i = 0; i < l; i ++ ) {\n\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\n\n\t}\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t//\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t// init bones\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\tthis.bones = [];\n\tthis.boneMatrices = [];\n\n\tvar b, bone, gbone, p, q, s;\n\n\tif ( this.geometry.bones !== undefined ) {\n\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tp = gbone.pos;\n\t\t\tq = gbone.rotq;\n\t\t\ts = gbone.scl;\n\n\t\t\tbone = this.addBone();\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.set( p[0], p[1], p[2] );\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\tbone.useQuaternion = true;\n\n\t\t\tif ( s !== undefined ) {\n\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\n\n\t\t\t} else {\n\n\t\t\t\tbone.scale.set( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( gbone.parent === -1 ) {\n\n\t\t\t\tthis.add( bone );\n\n\t\t\t} else {\n\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar nBones = this.bones.length;\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n\n\t\t\tvar size;\n\n\t\t\tif ( nBones > 256 )\n\t\t\t\tsize = 64;\n\t\t\telse if ( nBones > 64 )\n\t\t\t\tsize = 32;\n\t\t\telse if ( nBones > 16 )\n\t\t\t\tsize = 16;\n\t\t\telse\n\t\t\t\tsize = 8;\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.generateMipmaps = false;\n\t\t\tthis.boneTexture.flipY = false;\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\n\n\t\t}\n\n\t\tthis.pose();\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\n\n\tif ( bone === undefined ) {\n\n\t\tbone = new THREE.Bone( this );\n\n\t}\n\n\tthis.bones.push( bone );\n\n\treturn bone;\n\n};\n\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {\n\n\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t// update matrixWorld\n\n\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.matrixWorld.multiply( this.parent.matrixWorld, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tforce = true;\n\n\t}\n\n\t// update children\n\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\tvar child = this.children[ i ];\n\n\t\tif ( child instanceof THREE.Bone ) {\n\n\t\t\tchild.update( this.identityMatrix, false );\n\n\t\t} else {\n\n\t\t\tchild.updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\t// make a snapshot of the bones' rest position\n\n\tif ( this.boneInverses == undefined ) {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\t// flatten bone matrices to array\n\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t// compute the offset between the current and the original transform;\n\n\t\t//TODO: we could get rid of this multiplication step if the skinMatrix\n\t\t// was already representing the offset; however, this requires some\n\t\t// major changes to the animation system\n\n\t\tTHREE.SkinnedMesh.offsetMatrix.multiply( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\n\n\t\tTHREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\n\n\t}\n\n\tif ( this.useVertexTexture ) {\n\n\t\tthis.boneTexture.needsUpdate = true;\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.pose = function() {\n\n\tthis.updateMatrixWorld( true );\n\n\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\n\n\t\t// normalize weights\n\n\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\tif ( scale !== Infinity ) {\n\n\t\t\tsw.multiplyScalar( scale );\n\n\t\t} else {\n\n\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphAnimMesh = function ( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t// API\n\n\tthis.duration = 1000; // milliseconds\n\tthis.mirroredLoop = false;\n\tthis.time = 0;\n\n\t// internals\n\n\tthis.lastKeyframe = 0;\n\tthis.currentKeyframe = 0;\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\n\n};\n\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\n\n\tthis.startKeyframe = start;\n\tthis.endKeyframe = end;\n\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n\n\tthis.direction = -1;\n\tthis.directionBackwards = true;\n\n};\n\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n\n\tvar geometry = this.geometry;\n\n\tif ( ! geometry.animations ) geometry.animations = {};\n\n\tvar firstAnimation, animations = geometry.animations;\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar parts = morph.name.match( pattern );\n\n\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\tvar label = parts[ 1 ];\n\t\t\tvar num = parts[ 2 ];\n\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar animation = animations[ label ];\n\n\t\t\tif ( i < animation.start ) animation.start = i;\n\t\t\tif ( i > animation.end ) animation.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\n\n\t\t}\n\n\t}\n\n\tgeometry.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\n\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\n\n\tthis.geometry.animations[ label ] = { start: start, end: end };\n\n};\n\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\n\n\tvar animation = this.geometry.animations[ label ];\n\n\tif ( animation ) {\n\n\t\tthis.setFrameRange( animation.start, animation.end );\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\n\t\tthis.time = 0;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\n\n\tvar frameTime = this.duration / this.length;\n\n\tthis.time += this.direction * delta;\n\n\tif ( this.mirroredLoop ) {\n\n\t\tif ( this.time > this.duration || this.time < 0 ) {\n\n\t\t\tthis.direction *= -1;\n\n\t\t\tif ( this.time > this.duration ) {\n\n\t\t\t\tthis.time = this.duration;\n\t\t\t\tthis.directionBackwards = true;\n\n\t\t\t}\n\n\t\t\tif ( this.time < 0 ) {\n\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.directionBackwards = false;\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tthis.time = this.time % this.duration;\n\n\t\tif ( this.time < 0 ) this.time += this.duration;\n\n\t}\n\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\n\n\tif ( keyframe !== this.currentKeyframe ) {\n\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\n\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\tthis.lastKeyframe = this.currentKeyframe;\n\t\tthis.currentKeyframe = keyframe;\n\n\t}\n\n\tvar mix = ( this.time % frameTime ) / frameTime;\n\n\tif ( this.directionBackwards ) {\n\n\t\tmix = 1 - mix;\n\n\t}\n\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\n\n};\n\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\n\n\tobject.duration = this.duration;\n\tobject.mirroredLoop = this.mirroredLoop;\n\tobject.time = this.time;\n\n\tobject.lastKeyframe = this.lastKeyframe;\n\tobject.currentKeyframe = this.currentKeyframe;\n\n\tobject.direction = this.direction;\n\tobject.directionBackwards = this.directionBackwards;\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Ribbon = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n};\n\nTHREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Ribbon.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.LODs = [];\n\n};\n\n\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {\n\n\tif ( visibleAtDistance === undefined ) {\n\n\t\tvisibleAtDistance = 0;\n\n\t}\n\n\tvisibleAtDistance = Math.abs( visibleAtDistance );\n\n\tfor ( var l = 0; l < this.LODs.length; l ++ ) {\n\n\t\tif ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tthis.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );\n\tthis.add( object3D );\n\n};\n\nTHREE.LOD.prototype.update = function ( camera ) {\n\n\tif ( this.LODs.length > 1 ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\tvar inverse  = camera.matrixWorldInverse;\n\t\tvar distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );\n\n\t\tthis.LODs[ 0 ].object3D.visible = true;\n\n\t\tfor ( var l = 1; l < this.LODs.length; l ++ ) {\n\n\t\t\tif( distance >= this.LODs[ l ].visibleAtDistance ) {\n\n\t\t\t\tthis.LODs[ l - 1 ].object3D.visible = false;\n\t\t\t\tthis.LODs[ l     ].object3D.visible = true;\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor( ; l < this.LODs.length; l ++ ) {\n\n\t\t\tthis.LODs[ l ].object3D.visible = false;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.LOD.prototype.clone = function () {\n\n\t// TODO\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.Sprite = function ( parameters ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.color = ( parameters.color !== undefined ) ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );\n\tthis.map = ( parameters.map !== undefined ) ? parameters.map : new THREE.Texture();\n\n\tthis.blending = ( parameters.blending !== undefined ) ? parameters.blending : THREE.NormalBlending;\n\n\tthis.blendSrc = parameters.blendSrc !== undefined ? parameters.blendSrc : THREE.SrcAlphaFactor;\n\tthis.blendDst = parameters.blendDst !== undefined ? parameters.blendDst : THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = parameters.blendEquation !== undefined ? parameters.blendEquation : THREE.AddEquation;\n\n\tthis.useScreenCoordinates = ( parameters.useScreenCoordinates !== undefined ) ? parameters.useScreenCoordinates : true;\n\tthis.mergeWith3D = ( parameters.mergeWith3D !== undefined ) ? parameters.mergeWith3D : !this.useScreenCoordinates;\n\tthis.affectedByDistance = ( parameters.affectedByDistance !== undefined ) ? parameters.affectedByDistance : !this.useScreenCoordinates;\n\tthis.scaleByViewport = ( parameters.scaleByViewport !== undefined ) ? parameters.scaleByViewport : !this.affectedByDistance;\n\tthis.alignment = ( parameters.alignment instanceof THREE.Vector2 ) ? parameters.alignment : THREE.SpriteAlignment.center;\n\n\tthis.rotation3d = this.rotation;\n\tthis.rotation = 0;\n\tthis.opacity = 1;\n\n\tthis.uvOffset = new THREE.Vector2( 0, 0 );\n\tthis.uvScale  = new THREE.Vector2( 1, 1 );\n\n};\n\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\n\n/*\n * Custom update matrix\n */\n\nTHREE.Sprite.prototype.updateMatrix = function () {\n\n\tthis.matrix.setPosition( this.position );\n\n\tthis.rotation3d.set( 0, 0, this.rotation );\n\tthis.matrix.setRotationFromEuler( this.rotation3d );\n\n\tif ( this.scale.x !== 1 || this.scale.y !== 1 ) {\n\n\t\tthis.matrix.scale( this.scale );\n\t\tthis.boundRadiusScale = Math.max( this.scale.x, this.scale.y );\n\n\t}\n\n\tthis.matrixWorldNeedsUpdate = true;\n\n};\n\nTHREE.Sprite.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Sprite( {} );\n\n\tobject.color.copy( this.color );\n\tobject.map = this.map;\n\tobject.blending = this.blending;\n\n\tobject.useScreenCoordinates = this.useScreenCoordinates;\n\tobject.mergeWith3D = this.mergeWith3D;\n\tobject.affectedByDistance = this.affectedByDistance;\n\tobject.scaleByViewport = this.scaleByViewport;\n\tobject.alignment = this.alignment;\n\n\tobject.rotation3d.copy( this.rotation3d );\n\tobject.rotation = this.rotation;\n\tobject.opacity = this.opacity;\n\n\tobject.uvOffset.copy( this.uvOffset );\n\tobject.uvScale.copy( this.uvScale);\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/*\n * Alignment\n */\n\nTHREE.SpriteAlignment = {};\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );\nTHREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );\nTHREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.__objects = [];\n\tthis.__lights = [];\n\n\tthis.__objectsAdded = [];\n\tthis.__objectsRemoved = [];\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Scene.prototype.__addObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__lights.push( object );\n\n\t\t}\n\n\t\tif ( object.target && object.target.parent === undefined ) {\n\n\t\t\tthis.add( object.target );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\n\n\t\tif ( this.__objects.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__objects.push( object );\n\t\t\tthis.__objectsAdded.push( object );\n\n\t\t\t// check if previously removed\n\n\t\t\tvar i = this.__objectsRemoved.indexOf( object );\n\n\t\t\tif ( i !== -1 ) {\n\n\t\t\t\tthis.__objectsRemoved.splice( i, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__addObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.__removeObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tvar i = this.__lights.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__lights.splice( i, 1 );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera ) ) {\n\n\t\tvar i = this.__objects.indexOf( object );\n\n\t\tif( i !== -1 ) {\n\n\t\t\tthis.__objects.splice( i, 1 );\n\t\t\tthis.__objectsRemoved.push( object );\n\n\t\t\t// check if previously added\n\n\t\t\tvar ai = this.__objectsAdded.indexOf( object );\n\n\t\t\tif ( ai !== -1 ) {\n\n\t\t\t\tthis.__objectsAdded.splice( ai, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__removeObject( object.children[ c ] );\n\n\t}\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( hex, near, far ) {\n\n\tthis.color = new THREE.Color( hex );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( hex, density ) {\n\n\tthis.color = new THREE.Color( hex );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t_renderData, _elements, _lights,\n\t_projector = new THREE.Projector(),\n\n\t_canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\n\t_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,\n\t_context = _canvas.getContext( '2d' ),\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearOpacity = 0,\n\n\t_contextGlobalAlpha = 1,\n\t_contextGlobalCompositeOperation = 0,\n\t_contextStrokeStyle = null,\n\t_contextFillStyle = null,\n\t_contextLineWidth = null,\n\t_contextLineCap = null,\n\t_contextLineJoin = null,\n\n\t_v1, _v2, _v3, _v4,\n\t_v5 = new THREE.RenderableVertex(),\n\t_v6 = new THREE.RenderableVertex(),\n\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\n\t_color = new THREE.Color(),\n\t_color1 = new THREE.Color(),\n\t_color2 = new THREE.Color(),\n\t_color3 = new THREE.Color(),\n\t_color4 = new THREE.Color(),\n\n\t_diffuseColor = new THREE.Color(),\n\t_emissiveColor = new THREE.Color(),\n\n\t_patterns = {}, _imagedatas = {},\n\n\t_near, _far,\n\n\t_image, _uvs,\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\n\t_clipRect = new THREE.Rectangle(),\n\t_clearRect = new THREE.Rectangle(),\n\t_bboxRect = new THREE.Rectangle(),\n\n\t_enableLighting = false,\n\t_ambientLight = new THREE.Color(),\n\t_directionalLights = new THREE.Color(),\n\t_pointLights = new THREE.Color(),\n\n\t_pi2 = Math.PI * 2,\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n\n\t_pixelMap = document.createElement( 'canvas' );\n\t_pixelMap.width = _pixelMap.height = 2;\n\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\n\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\n\t_pixelMapData = _pixelMapImage.data;\n\n\t_gradientMap = document.createElement( 'canvas' );\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\n\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\n\n\t_gradientMapQuality --; // Fix UVs\n\n\tthis.domElement = _canvas;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t}\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_canvasWidth = width;\n\t\t_canvasHeight = height;\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\t_clipRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );\n\t\t_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t};\n\n\tthis.setClearColor = function ( color, opacity ) {\n\n\t\t_clearColor.copy( color );\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\n\n\t\t_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, opacity ) {\n\n\t\t_clearColor.setHex( hex );\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\n\n\t\t_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );\n\n\t};\n\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn 0;\n\n\t};\n\n\tthis.clear = function () {\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\tif ( _clearRect.isEmpty() === false ) {\n\n\t\t\t_clearRect.minSelf( _clipRect );\n\t\t\t_clearRect.inflate( 2 );\n\n\t\t\tif ( _clearOpacity < 1 ) {\n\n\t\t\t\t_context.clearRect( Math.floor( _clearRect.getX() ), Math.floor( _clearRect.getY() ), Math.floor( _clearRect.getWidth() ), Math.floor( _clearRect.getHeight() ) );\n\n\t\t\t}\n\n\t\t\tif ( _clearOpacity > 0 ) {\n\n\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\tsetOpacity( 1 );\n\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );\n\n\t\t\t\t_context.fillRect( Math.floor( _clearRect.getX() ), Math.floor( _clearRect.getY() ), Math.floor( _clearRect.getWidth() ), Math.floor( _clearRect.getHeight() ) );\n\n\t\t\t}\n\n\t\t\t_clearRect.empty();\n\n\t\t}\n\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar e, el, element, material;\n\n\t\tthis.autoClear === true\n\t\t\t? this.clear()\n\t\t\t: _context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\n\t\t/* DEBUG\n\t\t_context.fillStyle = 'rgba( 0, 255, 255, 0.5 )';\n\t\t_context.fillRect( _clipRect.getX(), _clipRect.getY(), _clipRect.getWidth(), _clipRect.getHeight() );\n\t\t*/\n\n\t\t_enableLighting = _lights.length > 0;\n\n\t\tif ( _enableLighting === true ) {\n\n\t\t\t calculateLights();\n\n\t\t}\n\n\t\tfor ( e = 0, el = _elements.length; e < el; e++ ) {\n\n\t\t\telement = _elements[ e ];\n\n\t\t\tmaterial = element.material;\n\n\t\t\tif ( material === undefined || material.visible === false ) continue;\n\n\t\t\t_bboxRect.empty();\n\n\t\t\tif ( element instanceof THREE.RenderableParticle ) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderParticle( _v1, element, material, scene );\n\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );\n\t\t\t\t_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );\n\n\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === true ) {\n\n\t\t\t\t\trenderLine( _v1, _v2, element, material, scene );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif ( material.overdraw === true ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen );\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen );\n\n\t\t\t\t}\n\n\t\t\t\t_bboxRect.add3Points( _v1.positionScreen.x, _v1.positionScreen.y,\n\t\t\t\t\t\t      _v2.positionScreen.x, _v2.positionScreen.y,\n\t\t\t\t\t\t      _v3.positionScreen.x, _v3.positionScreen.y );\n\n\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === true ) {\n\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material, scene );\n\n\t\t\t\t}\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace4 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_v5.positionScreen.copy( _v2.positionScreen );\n\t\t\t\t_v6.positionScreen.copy( _v4.positionScreen );\n\n\t\t\t\tif ( material.overdraw === true ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\n\t\t\t\t\texpand( _v2.positionScreen, _v4.positionScreen );\n\t\t\t\t\texpand( _v4.positionScreen, _v1.positionScreen );\n\n\t\t\t\t\texpand( _v3.positionScreen, _v5.positionScreen );\n\t\t\t\t\texpand( _v3.positionScreen, _v6.positionScreen );\n\n\t\t\t\t}\n\n\t\t\t\t_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );\n\t\t\t\t_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );\n\t\t\t\t_bboxRect.addPoint( _v3.positionScreen.x, _v3.positionScreen.y );\n\t\t\t\t_bboxRect.addPoint( _v4.positionScreen.x, _v4.positionScreen.y );\n\n\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === true ) {\n\n\t\t\t\t\trenderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* DEBUG\n\t\t\t_context.lineWidth = 1;\n\t\t\t_context.strokeStyle = 'rgba( 0, 255, 0, 0.5 )';\n\t\t\t_context.strokeRect( _bboxRect.getX(), _bboxRect.getY(), _bboxRect.getWidth(), _bboxRect.getHeight() );\n\t\t\t*/\n\n\t\t\t_clearRect.addRectangle( _bboxRect );\n\n\n\t\t}\n\n\t\t/* DEBUG\n\t\t_context.lineWidth = 1;\n\t\t_context.strokeStyle = 'rgba( 255, 0, 0, 0.5 )';\n\t\t_context.strokeRect( _clearRect.getX(), _clearRect.getY(), _clearRect.getWidth(), _clearRect.getHeight() );\n\t\t*/\n\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t\t//\n\n\t\tfunction calculateLights() {\n\n\t\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t\t_pointLights.setRGB( 0, 0, 0 );\n\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\t\tvar light = _lights[ l ];\n\t\t\t\tvar lightColor = light.color;\n\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\t\t_ambientLight.r += lightColor.r;\n\t\t\t\t\t_ambientLight.g += lightColor.g;\n\t\t\t\t\t_ambientLight.b += lightColor.b;\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\t// for particles\n\n\t\t\t\t\t_directionalLights.r += lightColor.r;\n\t\t\t\t\t_directionalLights.g += lightColor.g;\n\t\t\t\t\t_directionalLights.b += lightColor.b;\n\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t\t// for particles\n\n\t\t\t\t\t_pointLights.r += lightColor.r;\n\t\t\t\t\t_pointLights.g += lightColor.g;\n\t\t\t\t\t_pointLights.b += lightColor.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction calculateLight( position, normal, color ) {\n\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\t\tvar light = _lights[ l ];\n\t\t\t\tvar lightColor = light.color;\n\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tvar lightPosition = light.matrixWorld.getPosition().normalize();\n\n\t\t\t\t\tvar amount = normal.dot( lightPosition );\n\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\t\tamount *= light.intensity;\n\n\t\t\t\t\tcolor.r += lightColor.r * amount;\n\t\t\t\t\tcolor.g += lightColor.g * amount;\n\t\t\t\t\tcolor.b += lightColor.b * amount;\n\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t\tvar lightPosition = light.matrixWorld.getPosition();\n\n\t\t\t\t\tvar amount = normal.dot( _vector3.sub( lightPosition, position ).normalize() );\n\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\n\t\t\t\t\tif ( amount == 0 ) continue;\n\n\t\t\t\t\tamount *= light.intensity;\n\n\t\t\t\t\tcolor.r += lightColor.r * amount;\n\t\t\t\t\tcolor.g += lightColor.g * amount;\n\t\t\t\t\tcolor.b += lightColor.b * amount;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderParticle( v1, element, material, scene ) {\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\tvar width, height, scaleX, scaleY,\n\t\t\tbitmap, bitmapWidth, bitmapHeight;\n\n\t\t\tif ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\t\tif ( material.map === null ) {\n\n\t\t\t\t\tscaleX = element.object.scale.x;\n\t\t\t\t\tscaleY = element.object.scale.y;\n\n\t\t\t\t\t// TODO: Be able to disable this\n\n\t\t\t\t\tscaleX *= element.scale.x * _canvasWidthHalf;\n\t\t\t\t\tscaleY *= element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t\t_bboxRect.set( v1.x - scaleX, v1.y - scaleY, v1.x  + scaleX, v1.y + scaleY );\n\n\t\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === false ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsetFillStyle( material.color.getContextStyle() );\n\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t\t_context.scale( scaleX, scaleY );\n\t\t\t\t\t_context.fillRect( -1, -1, 2, 2 );\n\t\t\t\t\t_context.restore();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbitmap = material.map.image;\n\t\t\t\t\tbitmapWidth = bitmap.width >> 1;\n\t\t\t\t\tbitmapHeight = bitmap.height >> 1;\n\n\t\t\t\t\tscaleX = element.scale.x * _canvasWidthHalf;\n\t\t\t\t\tscaleY = element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t\twidth = scaleX * bitmapWidth;\n\t\t\t\t\theight = scaleY * bitmapHeight;\n\n\t\t\t\t\t// TODO: Rotations break this...\n\n\t\t\t\t\t_bboxRect.set( v1.x - width, v1.y - height, v1.x  + width, v1.y + height );\n\n\t\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === false ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t\t_context.scale( scaleX, - scaleY );\n\n\t\t\t\t\t_context.translate( - bitmapWidth, - bitmapHeight );\n\t\t\t\t\t_context.drawImage( bitmap, 0, 0 );\n\t\t\t\t\t_context.restore();\n\n\t\t\t\t}\n\n\t\t\t\t/* DEBUG\n\t\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t\t\t_context.beginPath();\n\t\t\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t\t\t_context.stroke();\n\t\t\t\t*/\n\n\t\t\t} else if ( material instanceof THREE.ParticleCanvasMaterial ) {\n\n\t\t\t\twidth = element.scale.x * _canvasWidthHalf;\n\t\t\t\theight = element.scale.y * _canvasHeightHalf;\n\n\t\t\t\t_bboxRect.set( v1.x - width, v1.y - height, v1.x + width, v1.y + height );\n\n\t\t\t\tif ( _clipRect.intersects( _bboxRect ) === false ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tsetStrokeStyle( material.color.getContextStyle() );\n\t\t\t\tsetFillStyle( material.color.getContextStyle() );\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t_context.rotate( - element.rotation );\n\t\t\t\t_context.scale( width, height );\n\n\t\t\t\tmaterial.program( _context );\n\n\t\t\t\t_context.restore();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderLine( v1, v2, element, material, scene ) {\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\tsetLineWidth( material.linewidth );\n\t\t\t\tsetLineCap( material.linecap );\n\t\t\t\tsetLineJoin( material.linejoin );\n\t\t\t\tsetStrokeStyle( material.color.getContextStyle() );\n\n\t\t\t\t_context.stroke();\n\t\t\t\t_bboxRect.inflate( material.linewidth * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material, scene ) {\n\n\t\t\t_this.info.render.vertices += 3;\n\t\t\t_this.info.render.faces ++;\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\n\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\n\t\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null && material.map === null ) {\n\n\t\t\t\t_diffuseColor.copy( material.color );\n\t\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_diffuseColor.r *= element.color.r;\n\t\t\t\t\t_diffuseColor.g *= element.color.g;\n\t\t\t\t\t_diffuseColor.b *= element.color.b;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _enableLighting === true ) {\n\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {\n\n\t\t\t\t\t\t_color1.r = _color2.r = _color3.r = _ambientLight.r;\n\t\t\t\t\t\t_color1.g = _color2.g = _color3.g = _ambientLight.g;\n\t\t\t\t\t\t_color1.b = _color2.b = _color3.b = _ambientLight.b;\n\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsWorld[ 0 ], _color1 );\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsWorld[ 1 ], _color2 );\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsWorld[ 2 ], _color3 );\n\n\t\t\t\t\t\t_color1.r = _color1.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color1.g = _color1.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color1.b = _color1.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color2.r = _color2.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color2.g = _color2.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color2.b = _color2.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color3.r = _color3.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color3.g = _color3.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color3.b = _color3.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color4.r = ( _color2.r + _color3.r ) * 0.5;\n\t\t\t\t\t\t_color4.g = ( _color2.g + _color3.g ) * 0.5;\n\t\t\t\t\t\t_color4.b = ( _color2.b + _color3.b ) * 0.5;\n\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_color.r = _ambientLight.r;\n\t\t\t\t\t\t_color.g = _ambientLight.g;\n\t\t\t\t\t\t_color.b = _ambientLight.b;\n\n\t\t\t\t\t\tcalculateLight( element.centroidWorld, element.normalWorld, _color );\n\n\t\t\t\t\t\t_color.r = _color.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color.g = _color.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color.b = _color.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( material.color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\n\n\t\t\t\t\t\t_uvs = element.uvs[ 0 ];\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].u, _uvs[ uv1 ].v, _uvs[ uv2 ].u, _uvs[ uv2 ].v, _uvs[ uv3 ].u, _uvs[ uv3 ].v, material.map );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else if ( material.envMap !== null ) {\n\n\t\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\n\n\t\t\t\t\t\tvar cameraMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsWorld[ uv1 ] );\n\t\t\t\t\t\t_uv1x = ( _vector3.x * cameraMatrix.elements[0] + _vector3.y * cameraMatrix.elements[4] + _vector3.z * cameraMatrix.elements[8] ) * 0.5 + 0.5;\n\t\t\t\t\t\t_uv1y = ( _vector3.x * cameraMatrix.elements[1] + _vector3.y * cameraMatrix.elements[5] + _vector3.z * cameraMatrix.elements[9] ) * 0.5 + 0.5;\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsWorld[ uv2 ] );\n\t\t\t\t\t\t_uv2x = ( _vector3.x * cameraMatrix.elements[0] + _vector3.y * cameraMatrix.elements[4] + _vector3.z * cameraMatrix.elements[8] ) * 0.5 + 0.5;\n\t\t\t\t\t\t_uv2y = ( _vector3.x * cameraMatrix.elements[1] + _vector3.y * cameraMatrix.elements[5] + _vector3.z * cameraMatrix.elements[9] ) * 0.5 + 0.5;\n\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsWorld[ uv3 ] );\n\t\t\t\t\t\t_uv3x = ( _vector3.x * cameraMatrix.elements[0] + _vector3.y * cameraMatrix.elements[4] + _vector3.z * cameraMatrix.elements[8] ) * 0.5 + 0.5;\n\t\t\t\t\t\t_uv3y = ( _vector3.x * cameraMatrix.elements[1] + _vector3.y * cameraMatrix.elements[5] + _vector3.z * cameraMatrix.elements[9] ) * 0.5 + 0.5;\n\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\n\t\t\t\t\t}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\n\n\n\n\t\t\t\t\t}*/\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_color.copy( material.color );\n\n\t\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t\t_color.r *= element.color.r;\n\t\t\t\t\t\t_color.g *= element.color.g;\n\t\t\t\t\t\t_color.b *= element.color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\t_near = camera.near;\n\t\t\t\t_far = camera.far;\n\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z, _near, _far );\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z, _near, _far );\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z, _near, _far );\n\n\t\t\t\t_color4.r = ( _color2.r + _color3.r ) * 0.5;\n\t\t\t\t_color4.g = ( _color2.g + _color3.g ) * 0.5;\n\t\t\t\t_color4.b = ( _color2.b + _color3.b ) * 0.5;\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\t_color.r = normalToComponent( element.normalWorld.x );\n\t\t\t\t_color.g = normalToComponent( element.normalWorld.y );\n\t\t\t\t_color.b = normalToComponent( element.normalWorld.z );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderFace4( v1, v2, v3, v4, v5, v6, element, material, scene ) {\n\n\t\t\t_this.info.render.vertices += 4;\n\t\t\t_this.info.render.faces ++;\n\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\n\t\t\tif ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {\n\n\t\t\t\t// Let renderFace3() handle this\n\n\t\t\t\trenderFace3( v1, v2, v4, 0, 1, 3, element, material, scene );\n\t\t\t\trenderFace3( v5, v3, v6, 1, 2, 3, element, material, scene );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\t\t\t_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;\n\t\t\t_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;\n\t\t\t_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;\n\n\t\t\tif ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\t_diffuseColor.copy( material.color );\n\t\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_diffuseColor.r *= element.color.r;\n\t\t\t\t\t_diffuseColor.g *= element.color.g;\n\t\t\t\t\t_diffuseColor.b *= element.color.b;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _enableLighting === true ) {\n\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {\n\n\t\t\t\t\t\t_color1.r = _color2.r = _color3.r = _color4.r = _ambientLight.r;\n\t\t\t\t\t\t_color1.g = _color2.g = _color3.g = _color4.g = _ambientLight.g;\n\t\t\t\t\t\t_color1.b = _color2.b = _color3.b = _color4.b = _ambientLight.b;\n\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsWorld[ 0 ], _color1 );\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsWorld[ 1 ], _color2 );\n\t\t\t\t\t\tcalculateLight( element.v4.positionWorld, element.vertexNormalsWorld[ 3 ], _color3 );\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsWorld[ 2 ], _color4 );\n\n\t\t\t\t\t\t_color1.r = _color1.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color1.g = _color1.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color1.b = _color1.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color2.r = _color2.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color2.g = _color2.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color2.b = _color2.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color3.r = _color3.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color3.g = _color3.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color3.b = _color3.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_color4.r = _color4.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color4.g = _color4.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color4.b = _color4.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t\t\t// TODO: UVs are incorrect, v4->v3?\n\n\t\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\n\t\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_color.r = _ambientLight.r;\n\t\t\t\t\t\t_color.g = _ambientLight.g;\n\t\t\t\t\t\t_color.b = _ambientLight.b;\n\n\t\t\t\t\t\tcalculateLight( element.centroidWorld, element.normalWorld, _color );\n\n\t\t\t\t\t\t_color.r = _color.r * _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t\t_color.g = _color.g * _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t\t_color.b = _color.b * _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_color.r = _diffuseColor.r + _emissiveColor.r;\n\t\t\t\t\t_color.g = _diffuseColor.g + _emissiveColor.g;\n\t\t\t\t\t_color.b = _diffuseColor.b + _emissiveColor.b;\n\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t: fillPath( _color );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\t\t_color.copy( material.color );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_color.r *= element.color.r;\n\t\t\t\t\t_color.g *= element.color.g;\n\t\t\t\t\t_color.b *= element.color.b;\n\n\t\t\t\t}\n\n\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\t_color.r = normalToComponent( element.normalWorld.x );\n\t\t\t\t_color.g = normalToComponent( element.normalWorld.y );\n\t\t\t\t_color.b = normalToComponent( element.normalWorld.z );\n\n\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\t_near = camera.near;\n\t\t\t\t_far = camera.far;\n\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z, _near, _far );\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z, _near, _far );\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z, _near, _far );\n\t\t\t\t_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z, _near, _far );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\t// TODO: UVs are incorrect, v4->v3?\n\n\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\n\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( x0, y0 );\n\t\t\t_context.lineTo( x1, y1 );\n\t\t\t_context.lineTo( x2, y2 );\n\t\t\t_context.closePath();\n\n\t\t}\n\n\t\tfunction drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {\n\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( x0, y0 );\n\t\t\t_context.lineTo( x1, y1 );\n\t\t\t_context.lineTo( x2, y2 );\n\t\t\t_context.lineTo( x3, y3 );\n\t\t\t_context.closePath();\n\n\t\t}\n\n\t\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\n\t\t\tsetLineWidth( linewidth );\n\t\t\tsetLineCap( linecap );\n\t\t\tsetLineJoin( linejoin );\n\t\t\tsetStrokeStyle( color.getContextStyle() );\n\n\t\t\t_context.stroke();\n\n\t\t\t_bboxRect.inflate( linewidth * 2 );\n\n\t\t}\n\n\t\tfunction fillPath( color ) {\n\n\t\t\tsetFillStyle( color.getContextStyle() );\n\t\t\t_context.fill();\n\n\t\t}\n\n\t\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\n\t\t\tif ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;\n\n\t\t\tif ( texture.needsUpdate === true ) {\n\n\t\t\t\tvar repeatX = texture.wrapS == THREE.RepeatWrapping;\n\t\t\t\tvar repeatY = texture.wrapT == THREE.RepeatWrapping;\n\n\t\t\t\t_patterns[ texture.id ] = _context.createPattern(\n\t\t\t\t\ttexture.image, repeatX === true && repeatY === true\n\t\t\t\t\t\t? 'repeat'\n\t\t\t\t\t\t: repeatX === true && repeatY === false\n\t\t\t\t\t\t\t? 'repeat-x'\n\t\t\t\t\t\t\t: repeatX === false && repeatY === true\n\t\t\t\t\t\t\t\t? 'repeat-y'\n\t\t\t\t\t\t\t\t: 'no-repeat'\n\t\t\t\t);\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\t_patterns[ texture.id ] === undefined\n\t\t\t\t? setFillStyle( 'rgba(0,0,0,1)' )\n\t\t\t\t: setFillStyle( _patterns[ texture.id ] );\n\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\t\twidth = texture.image.width * texture.repeat.x,\n\t\t\theight = texture.image.height * texture.repeat.y;\n\n\t\t\tu0 = ( u0 + offsetX ) * width;\n\t\t\tv0 = ( 1.0 - v0 + offsetY ) * height;\n\n\t\t\tu1 = ( u1 + offsetX ) * width;\n\t\t\tv1 = ( 1.0 - v1 + offsetY ) * height;\n\n\t\t\tu2 = ( u2 + offsetX ) * width;\n\t\t\tv2 = ( 1.0 - v2 + offsetY ) * height;\n\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\n\t\t\tdet = u1 * v2 - u2 * v1;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tif ( _imagedatas[ texture.id ] === undefined ) {\n\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' )\n\t\t\t\t\tcanvas.width = texture.image.width;\n\t\t\t\t\tcanvas.height = texture.image.height;\n\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( texture.image, 0, 0 );\n\n\t\t\t\t\t_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;\n\n\t\t\t\t}\n\n\t\t\t\tvar data = _imagedatas[ texture.id ];\n\t\t\t\tvar index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;\n\n\t\t\t\t_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );\n\t\t\t\tfillPath( _color );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tidet = 1 / det;\n\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.fill();\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\twidth = image.width - 1,\n\t\t\theight = image.height - 1;\n\n\t\t\tu0 *= width; v0 *= height;\n\t\t\tu1 *= width; v1 *= height;\n\t\t\tu2 *= width; v2 *= height;\n\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\n\t\t\tdet = u1 * v2 - u2 * v1;\n\n\t\t\tidet = 1 / det;\n\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.clip();\n\t\t\t_context.drawImage( image, 0, 0 );\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\tfunction getGradientTexture( color1, color2, color3, color4 ) {\n\n\t\t\t// http://mrdoob.com/blog/post/710\n\n\t\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\n\n\t\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\n\t\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\n\t\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\n\n\t\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\n\t\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\n\n\t\t\treturn _gradientMap;\n\n\t\t}\n\n\t\tfunction smoothstep( value, min, max ) {\n\n\t\t\tvar x = ( value - min ) / ( max - min );\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t}\n\n\t\tfunction normalToComponent( normal ) {\n\n\t\t\tvar component = ( normal + 1 ) * 0.5;\n\t\t\treturn component < 0 ? 0 : ( component > 1 ? 1 : component );\n\n\t\t}\n\n\t\t// Hide anti-alias gaps\n\n\t\tfunction expand( v1, v2 ) {\n\n\t\t\tvar x = v2.x - v1.x, y =  v2.y - v1.y,\n\t\t\tdet = x * x + y * y, idet;\n\n\t\t\tif ( det === 0 ) return;\n\n\t\t\tidet = 1 / Math.sqrt( det );\n\n\t\t\tx *= idet; y *= idet;\n\n\t\t\tv2.x += x; v2.y += y;\n\t\t\tv1.x -= x; v1.y -= y;\n\n\t\t}\n\t};\n\n\t// Context cached methods.\n\n\tfunction setOpacity( value ) {\n\n\t\tif ( _contextGlobalAlpha !== value ) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\n\t\t}\n\n\t}\n\n\tfunction setBlending( value ) {\n\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\n\t\t\tif ( value === THREE.NormalBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineWidth( value ) {\n\n\t\tif ( _contextLineWidth !== value ) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineCap( value ) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif ( _contextLineCap !== value ) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineJoin( value ) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif ( _contextLineJoin !== value ) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\n\t\t}\n\n\t}\n\n\tfunction setStrokeStyle( value ) {\n\n\t\tif ( _contextStrokeStyle !== value ) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setFillStyle( value ) {\n\n\t\tif ( _contextFillStyle !== value ) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\n\t\t}\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderChunk = {\n\n\t// FOG\n\n\tfog_pars_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"uniform vec3 fogColor;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"uniform float fogDensity;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform float fogNear;\",\n\t\t\t\t\"uniform float fogFar;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tfog_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"const float LOG2 = 1.442695;\",\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ENVIRONMENT MAP\n\n\tenvmap_pars_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"uniform float reflectivity;\",\n\t\t\t\"uniform samplerCube envMap;\",\n\t\t\t\"uniform float flipEnvMap;\",\n\t\t\t\"uniform int combine;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"uniform bool useRefract;\",\n\t\t\t\t\"uniform float refractionRatio;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"vec3 reflectVec;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\"} else { \",\n\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"reflectVec = vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"if ( combine == 1 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_pars_vertex: [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform bool useRefract;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tworldpos_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"vec4 mPosition = modelMatrix * skinned;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 mPosition = modelMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 mPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"vec3 nWorld = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n\n\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\"vReflect = refract( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ), refractionRatio );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"vReflect = reflect( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ) );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (particles)\n\n\tmap_particle_pars_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tmap_particle_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (triangles)\n\n\tmap_pars_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"uniform vec4 offsetRepeat;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_pars_fragment: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\",\n\n\t].join(\"\\n\"),\n\n\tmap_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vUv );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHT MAP\n\n\tlightmap_pars_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\t\t\t\"uniform sampler2D lightMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_pars_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"vUv2 = uv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// BUMP MAP\n\n\tbumpmap_pars_fragment: [\n\n\t\t\"#ifdef USE_BUMPMAP\",\n\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform float bumpScale;\",\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\t\t\t\"vec2 dHdxy_fwd() {\",\n\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\n\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n\n\t\t\t\t\"return vec2( dBx, dBy );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\n\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\n\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\n\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// NORMAL MAP\n\n\tnormalmap_pars_fragment: [\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"uniform sampler2D normalMap;\",\n\t\t\t\"uniform vec2 normalScale;\",\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\n\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\n\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\n\t\t\t\t\"return normalize( tsn * mapN );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SPECULAR MAP\n\n\tspecularmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"uniform sampler2D specularMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tspecularmap_fragment: [\n\n\t\t\"float specularStrength;\",\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\t\t\t\"specularStrength = texelSpecular.r;\",\n\n\t\t\"#else\",\n\n\t\t\t\"specularStrength = 1.0;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS LAMBERT\n\n\tlights_lambert_pars_vertex: [\n\n\t\t\"uniform vec3 ambient;\",\n\t\t\"uniform vec3 diffuse;\",\n\t\t\"uniform vec3 emissive;\",\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_lambert_vertex: [\n\n\t\t\"vLightFront = vec3( 0.0 );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vec3( 0.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"transformedNormal = normalize( transformedNormal );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - mPosition.xyz ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngle[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = pow( spotEffect, spotLightExponent[ i ] );\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS PHONG\n\n\tlights_phong_pars_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tlights_phong_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"vWorldPosition = mPosition.xyz;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_pars_fragment: [\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\",\n\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_fragment: [\n\n\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"normal = perturbNormal2Arb( -viewPosition, normal );\",\n\n\t\t\"#elif defined( USE_BUMPMAP )\",\n\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngle[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = pow( spotEffect, spotLightExponent[ i ] );\",\n\n\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t// specular\n\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t/*\n\t\t\t\t\t// fresnel term from skin shader\n\t\t\t\t\t\"const float F0 = 0.128;\",\n\n\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\t\t\t\t\t*/\n\n\t\t\t\t\t/*\n\t\t\t\t\t// fresnel term from fresnel shader\n\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\n\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\t\t\t\t\t*/\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lPosition.xyz + vViewPosition.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t// specular (sky light)\n\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t// specular (ground light)\n\n\t\t\t\t\"vec3 lVectorGround = normalize( -lPosition.xyz + vViewPosition.xyz );\",\n\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef METAL\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\"#else\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// VERTEX COLORS\n\n\tcolor_pars_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tcolor_pars_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"vColor = color * color;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vColor = color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SKINNING\n\n\tskinning_pars_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef BONE_TEXTURE\",\n\n\t\t\t\t\"uniform sampler2D boneTexture;\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"float j = i * 4.0;\",\n\t\t\t\t\t\"float x = mod( j, N_BONE_PIXEL_X );\",\n\t\t\t\t\t\"float y = floor( j / N_BONE_PIXEL_X );\",\n\n\t\t\t\t\t\"const float dx = 1.0 / N_BONE_PIXEL_X;\",\n\t\t\t\t\t\"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\n\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\n\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\n\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinbase_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinning_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// MORPHING\n\n\tmorphtarget_pars_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmorphtarget_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"morphed += position;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefault_vertex : [\n\n\t\t\"vec4 mvPosition;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t].join(\"\\n\"),\n\n\tmorphnormal_vertex: [\n\n\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\n\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"morphedNormal += normal;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinnormal_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\n\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefaultnormal_vertex: [\n\n\t\t\"vec3 objectNormal;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = morphedNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = normal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\"objectNormal = -objectNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\",\n\n\t].join(\"\\n\"),\n\n\t// SHADOW MAP\n\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n\t//  http://spidergl.org/example.php?id=6\n\t// \thttp://fabiensanglard.net/shadowmapping\n\n\tshadowmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\t\"return depth;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\"vec3 frustumColors[3];\",\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\"int inFrustumCount = 0;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"float fDepth;\",\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\n\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\n\n\t\t\t\t\"if ( frustumTest ) {\",\n\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\n\n\t\t\t\t\t\"#ifdef SHADOWMAP_SOFT\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"shadow /= 9.0;\",\n\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\t\"shadowColor *= shadowColor;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_pars_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * mPosition;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ALPHATEST\n\n\talphatest_fragment: [\n\n\t\t\"#ifdef ALPHATEST\",\n\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LINEAR SPACE\n\n\tlinear_to_gamma_fragment: [\n\n\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n};\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar u, p, tmp, merged = {};\n\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\ttmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\n\n\t\tfor ( u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( p in uniforms_src[ u ] ) {\n\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\n\t\t\"map\" : { type: \"t\", value: null },\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"lightMap\" : { type: \"t\", value: null },\n\t\t\"specularMap\" : { type: \"t\", value: null },\n\n\t\t\"envMap\" : { type: \"t\", value: null },\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\n\t\t\"combine\" : { type: \"i\", value: 0 },\n\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\n\n\t},\n\n\tbump: {\n\n\t\t\"bumpMap\" : { type: \"t\", value: null },\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\" : { type: \"t\", value: null },\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\n\t},\n\n\tfog : {\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"hemisphereLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\n\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\n\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightAngle\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\n\n\t},\n\n\tparticle: {\n\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\t\t\"size\" : { type: \"f\", value: 1.0 },\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\n\t\t\"map\" : { type: \"t\", value: null },\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tshadowmap: {\n\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\n\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\n\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] },\n\n\t}\n\n};\n\nTHREE.ShaderLib = {\n\n\t'depth': {\n\n\t\tuniforms: {\n\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float mNear;\",\n\t\t\t\"uniform float mFar;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vNormal = normalMatrix * normal;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define LAMBERT\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\t\t\t\t\t\"else\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define PHONG\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"vNormal = transformedNormal;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'particle_basic': {\n\n\t\tuniforms:  THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float size;\",\n\t\t\t\"uniform float scale;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n\t\t\t\t\"#else\",\n\t\t\t\t\t\"gl_PointSize = size;\",\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 psColor;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t// Depth encoding into RGBA texture\n\t// \tbased on SpiderGL shadow map example\n\t// \t\thttp://spidergl.org/example.php?id=6\n\t// \toriginally from\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n\t// \tsee also here:\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\n\t'depthRGBA': {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\n\t\t\t\t\"return res;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t}\n\n};\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : true,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\n\t_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),\n\t_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0,\n\n\t_maxLights = parameters.maxLights !== undefined ? parameters.maxLights : 4;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\tthis.autoUpdateObjects = true;\n\tthis.autoUpdateScene = true;\n\n\t// physically based shading\n\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\tthis.physicallyBasedShading = false;\n\n\t// shadow map\n\n\tthis.shadowMapEnabled = false;\n\tthis.shadowMapAutoUpdate = true;\n\tthis.shadowMapSoft = true;\n\tthis.shadowMapCullFrontFaces = true;\n\tthis.shadowMapDebug = false;\n\tthis.shadowMapCascade = false;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// flags\n\n\tthis.autoScaleCubemaps = true;\n\n\t// custom render plugins\n\n\tthis.renderPluginsPre = [];\n\tthis.renderPluginsPost = [];\n\n\t// info\n\n\tthis.info = {\n\n\t\tmemory: {\n\n\t\t\tprograms: 0,\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\n\t\trender: {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t}\n\n\t};\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t_programs = [],\n\t_programs_counter = 0,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = -1,\n\t_currentGeometryGroupHash = null,\n\t_currentCamera = null,\n\t_geometryGroupCounter = 0,\n\n\t_usedTextureUnits = 0,\n\n\t// GL state cache\n\n\t_oldDoubleSided = -1,\n\t_oldFlipSided = -1,\n\n\t_oldBlending = -1,\n\n\t_oldBlendEquation = -1,\n\t_oldBlendSrc = -1,\n\t_oldBlendDst = -1,\n\n\t_oldDepthTest = -1,\n\t_oldDepthWrite = -1,\n\n\t_oldPolygonOffset = null,\n\t_oldPolygonOffsetFactor = null,\n\t_oldPolygonOffsetUnits = null,\n\n\t_oldLineWidth = null,\n\n\t_viewportX = 0,\n\t_viewportY = 0,\n\t_viewportWidth = 0,\n\t_viewportHeight = 0,\n\t_currentWidth = 0,\n\t_currentHeight = 0,\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t // camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\t_projScreenMatrixPS = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector4(),\n\n\t// light arrays cache\n\n\t_direction = new THREE.Vector3(),\n\n\t_lightsNeedUpdate = true,\n\n\t_lights = {\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), angles: new Array(), exponents: new Array() },\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\n\n\t};\n\n\t// initialize\n\n\tvar _gl;\n\n\tvar _glExtensionTextureFloat;\n\tvar _glExtensionStandardDerivatives;\n\tvar _glExtensionTextureFilterAnisotropic;\n\tvar _glExtensionCompressedTextureS3TC;\n\n\tinitGL();\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\n\t// GPU capabilities\n\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\n\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.supportsVertexTextures = function () {\n\n\t\treturn _supportsVertexTextures;\n\n\t};\n\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn _maxAnisotropy;\n\n\t};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_canvas.width = width;\n\t\t_canvas.height = height;\n\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewportX = x !== undefined ? x : 0;\n\t\t_viewportY = y !== undefined ? y : 0;\n\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t_gl.scissor( x, y, width, height );\n\n\t};\n\n\tthis.enableScissorTest = function ( enable ) {\n\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\n\n\t};\n\n\t// Clearing\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\t_clearColor.setHex( hex );\n\t\t_clearAlpha = alpha;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.copy( color );\n\t\t_clearAlpha = alpha;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Plugins\n\n\tthis.addPostPlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPost.push( plugin );\n\n\t};\n\n\tthis.addPrePlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPre.push( plugin );\n\n\t};\n\n\t// Deallocation\n\n\tthis.deallocateObject = function ( object ) {\n\n\t\tif ( ! object.__webglInit ) return;\n\n\t\tobject.__webglInit = false;\n\n\t\tdelete object._modelViewMatrix;\n\t\tdelete object._normalMatrix;\n\n\t\tdelete object._normalMatrixArray;\n\t\tdelete object._modelViewMatrixArray;\n\t\tdelete object._modelMatrixArray;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tfor ( var g in object.geometry.geometryGroups ) {\n\n\t\t\t\tdeleteMeshBuffers( object.geometry.geometryGroups[ g ] );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\tdeleteRibbonBuffers( object.geometry );\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tdeleteLineBuffers( object.geometry );\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tdeleteParticleBuffers( object.geometry );\n\n\t\t}\n\n\t};\n\n\tthis.deallocateTexture = function ( texture ) {\n\n\t\tif ( ! texture.__webglInit ) return;\n\n\t\ttexture.__webglInit = false;\n\t\t_gl.deleteTexture( texture.__webglTexture );\n\n\t\t_this.info.memory.textures --;\n\n\t};\n\n\tthis.deallocateRenderTarget = function ( renderTarget ) {\n\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\n\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\n\n\t\t}\n\n\t};\n\n\tthis.deallocateMaterial = function ( material ) {\n\n\t\tvar program = material.program;\n\n\t\tif ( ! program ) return;\n\n\t\tmaterial.program = undefined;\n\n\t\t// only deallocate GL program if this was the last use of shared program\n\t\t// assumed there is only single copy of any program in the _programs list\n\t\t// (that's how it's constructed)\n\n\t\tvar i, il, programInfo;\n\t\tvar deleteProgram = false;\n\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\tif ( programInfo.program === program ) {\n\n\t\t\t\tprogramInfo.usedTimes --;\n\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteProgram = true;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( deleteProgram ) {\n\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\n\n\t\t\tvar newPrograms = [];\n\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\t\tif ( programInfo.program !== program ) {\n\n\t\t\t\t\tnewPrograms.push( programInfo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_programs = newPrograms;\n\n\t\t\t_gl.deleteProgram( program );\n\n\t\t\t_this.info.memory.programs --;\n\n\t\t}\n\n\t};\n\n\t// Rendering\n\n\tthis.updateShadowMap = function ( scene, camera ) {\n\n\t\t_currentProgram = null;\n\t\t_oldBlending = -1;\n\t\t_oldDepthTest = -1;\n\t\t_oldDepthWrite = -1;\n\t\t_currentGeometryGroupHash = -1;\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\t\t_oldDoubleSided = -1;\n\t\t_oldFlipSided = -1;\n\n\t\tthis.shadowMapPlugin.update( scene, camera );\n\n\t};\n\n\t// Internal functions\n\n\t// Buffer allocation\n\n\tfunction createParticleBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createLineBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createRibbonBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createMeshBuffers ( geometryGroup ) {\n\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\t// Buffer deallocation\n\n\tfunction deleteParticleBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteLineBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteRibbonBuffers ( geometry ) {\n\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tfunction deleteMeshBuffers ( geometryGroup ) {\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglColorBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUVBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );\n\n\t\t_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );\n\t\t_gl.deleteBuffer( geometryGroup.__webglLineBuffer );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\tfor ( var id in geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglCustomAttributesList[ id ].buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\t// Buffer initialization\n\n\tfunction initCustomAttributes ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tvar material = object.material;\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\tvar attribute = material.attributes[ a ];\n\n\t\t\t\tif( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction initParticleBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__sortArray = [];\n\n\t\tgeometry.__webglParticleCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initLineBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__webglLineCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initRibbonBuffers ( geometry ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__webglVertexCount = nvertices;\n\n\t};\n\n\tfunction initMeshBuffers ( geometryGroup, object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tfaces3 = geometryGroup.faces3,\n\t\t\tfaces4 = geometryGroup.faces4,\n\n\t\t\tnvertices = faces3.length * 3 + faces4.length * 4,\n\t\t\tntris     = faces3.length * 1 + faces4.length * 2,\n\t\t\tnlines    = faces3.length * 3 + faces4.length * 4,\n\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\n\n\t\t\tuvType = bufferGuessUVType( material ),\n\t\t\tnormalType = bufferGuessNormalType( material ),\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\n\n\t\t//console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\n\n\t\tif ( normalType ) {\n\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( geometry.hasTangents ) {\n\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tif ( vertexColorType ) {\n\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( uvType ) {\n\n\t\t\tif ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {\n\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\n\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\n\n\n\t\t// custom attributes\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\n\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\n\n\t\t\t\tvar attribute = {};\n\n\t\t\t\tfor ( var property in originalAttribute ) {\n\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\n\n\t\t\t\t}\n\n\t\t\t\tif( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\n\t\t\t\t\tattribute.__original = originalAttribute;\n\n\t\t\t\t}\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__inittedArrays = true;\n\n\t};\n\n\tfunction getBufferMaterial( object, geometryGroup ) {\n\n\t\tif ( object.material && ! ( object.material instanceof THREE.MeshFaceMaterial ) ) {\n\n\t\t\treturn object.material;\n\n\t\t} else if ( geometryGroup.materialIndex >= 0 ) {\n\n\t\t\treturn object.geometry.materials[ geometryGroup.materialIndex ];\n\n\t\t}\n\n\t};\n\n\tfunction materialNeedsSmoothNormals ( material ) {\n\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n\n\t};\n\n\tfunction bufferGuessNormalType ( material ) {\n\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\n\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\n\n\t\t\treturn THREE.SmoothShading;\n\n\t\t} else {\n\n\t\t\treturn THREE.FlatShading;\n\n\t\t}\n\n\t};\n\n\tfunction bufferGuessVertexColorType ( material ) {\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\treturn material.vertexColors;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction bufferGuessUVType ( material ) {\n\n\t\t// material must use some texture to require uvs\n\n\t\tif ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t//\n\n\tfunction initDirectBuffers( geometry ) {\n\n\t\tvar a, attribute, type;\n\n\t\tfor ( a in geometry.attributes ) {\n\n\t\t\tif ( a === \"index\" ) {\n\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\n\n\t\t\t} else {\n\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\n\n\t\t\t}\n\n\t\t\tattribute = geometry.attributes[ a ];\n\n\t\t\tattribute.buffer = _gl.createBuffer();\n\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\n\n\t\t}\n\n\t};\n\n\t// Buffer setting\n\n\tfunction setParticleBuffers ( geometry, hint, object ) {\n\n\t\tvar v, c, vertex, offset, index, color,\n\n\t\tvertices = geometry.vertices,\n\t\tvl = vertices.length,\n\n\t\tcolors = geometry.colors,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tsortArray = geometry.__sortArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( object.sortParticles ) {\n\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\n\t\t\t_projScreenMatrixPS.multiplySelf( object.matrixWorld );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t_vector3.copy( vertex );\n\t\t\t\t_projScreenMatrixPS.multiplyVector3( _vector3 );\n\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\n\n\t\t\t}\n\n\t\t\tsortArray.sort( function( a, b ) { return b[ 0 ] - a[ 0 ]; } );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( dirtyVertices ) {\n\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t\toffset = v * 3;\n\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( dirtyColors ) {\n\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\t\toffset = c * 3;\n\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\n\n\t\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\t\toffset = 0;\n\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyVertices || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t};\n\n\tfunction setLineBuffers ( geometry, hint ) {\n\n\t\tvar v, c, vertex, offset, color,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setRibbonBuffers ( geometry, hint ) {\n\n\t\tvar v, c, vertex, offset, color,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t};\n\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\n\n\t\tif ( ! geometryGroup.__inittedArrays ) {\n\n\t\t\t// console.log( object );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalType = bufferGuessNormalType( material ),\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\n\t\tuvType = bufferGuessUVType( material ),\n\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\n\n\t\tvar f, fl, fi, face,\n\t\tvertexNormals, faceNormal, normal,\n\t\tvertexColors, faceColor,\n\t\tvertexTangents,\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\n\t\tc1, c2, c3, c4,\n\t\tsw1, sw2, sw3, sw4,\n\t\tsi1, si2, si3, si4,\n\t\tsa1, sa2, sa3, sa4,\n\t\tsb1, sb2, sb3, sb4,\n\t\tm, ml, i, il,\n\t\tvn, uvi, uv2i,\n\t\tvk, vkl, vka,\n\t\tnka, chf, faceVertexNormals,\n\t\ta,\n\n\t\tvertexIndex = 0,\n\n\t\toffset = 0,\n\t\toffset_uv = 0,\n\t\toffset_uv2 = 0,\n\t\toffset_face = 0,\n\t\toffset_normal = 0,\n\t\toffset_tangent = 0,\n\t\toffset_line = 0,\n\t\toffset_color = 0,\n\t\toffset_skin = 0,\n\t\toffset_morphTarget = 0,\n\t\toffset_custom = 0,\n\t\toffset_customSrc = 0,\n\n\t\tvalue,\n\n\t\tvertexArray = geometryGroup.__vertexArray,\n\t\tuvArray = geometryGroup.__uvArray,\n\t\tuv2Array = geometryGroup.__uv2Array,\n\t\tnormalArray = geometryGroup.__normalArray,\n\t\ttangentArray = geometryGroup.__tangentArray,\n\t\tcolorArray = geometryGroup.__colorArray,\n\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\n\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\n\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\n\t\tcustomAttribute,\n\n\t\tfaceArray = geometryGroup.__faceArray,\n\t\tlineArray = geometryGroup.__lineArray,\n\n\t\tgeometry = object.geometry, // this is shared for all chunks\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\n\n\t\tvertices = geometry.vertices,\n\t\tchunk_faces3 = geometryGroup.faces3,\n\t\tchunk_faces4 = geometryGroup.faces4,\n\t\tobj_faces = geometry.faces,\n\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\n\n\t\tobj_colors = geometry.colors,\n\n\t\tobj_skinIndices = geometry.skinIndices,\n\t\tobj_skinWeights = geometry.skinWeights,\n\n\t\tmorphTargets = geometry.morphTargets,\n\t\tmorphNormals = geometry.morphNormals;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\toffset += 9;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\t\t\t\tv4 = vertices[ face.d ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\tvertexArray[ offset + 9 ]  = v4.x;\n\t\t\t\tvertexArray[ offset + 10 ] = v4.y;\n\t\t\t\tvertexArray[ offset + 11 ] = v4.z;\n\n\t\t\t\toffset += 12;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyMorphTargets ) {\n\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\n\n\t\t\t\toffset_morphTarget = 0;\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces3[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 9;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces4[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\t\t\t\t\tv4 = morphTargets[ vk ].vertices[ face.d ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 9 ]  = v4.x;\n\t\t\t\t\tvka[ offset_morphTarget + 10 ] = v4.y;\n\t\t\t\t\tvka[ offset_morphTarget + 11 ] = v4.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\t\t\t\t\t\t\tn4 = faceVertexNormals.d;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\t\t\t\t\t\t\tn4 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 9 ]  = n4.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 10 ] = n4.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 11 ] = n4.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 12;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\n\n\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obj_skinWeights.length ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\toffset_skin += 12;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\t\t\t\tsw4 = obj_skinWeights[ face.d ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 12 ] = sw4.x;\n\t\t\t\tskinWeightArray[ offset_skin + 13 ] = sw4.y;\n\t\t\t\tskinWeightArray[ offset_skin + 14 ] = sw4.z;\n\t\t\t\tskinWeightArray[ offset_skin + 15 ] = sw4.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\t\t\t\tsi4 = obj_skinIndices[ face.d ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 12 ] = si4.x;\n\t\t\t\tskinIndexArray[ offset_skin + 13 ] = si4.y;\n\t\t\t\tskinIndexArray[ offset_skin + 14 ] = si4.z;\n\t\t\t\tskinIndexArray[ offset_skin + 15 ] = si4.w;\n\n\t\t\t\toffset_skin += 16;\n\n\t\t\t}\n\n\t\t\tif ( offset_skin > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyColors && vertexColorType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\toffset_color += 9;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\t\t\t\t\tc4 = vertexColors[ 3 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\t\t\t\t\tc4 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\tcolorArray[ offset_color + 9 ]  = c4.r;\n\t\t\t\tcolorArray[ offset_color + 10 ] = c4.g;\n\t\t\t\tcolorArray[ offset_color + 11 ] = c4.b;\n\n\t\t\t\toffset_color += 12;\n\n\t\t\t}\n\n\t\t\tif ( offset_color > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\toffset_tangent += 12;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\t\t\t\tt4 = vertexTangents[ 3 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 12 ] = t4.x;\n\t\t\t\ttangentArray[ offset_tangent + 13 ] = t4.y;\n\t\t\t\ttangentArray[ offset_tangent + 14 ] = t4.z;\n\t\t\t\ttangentArray[ offset_tangent + 15 ] = t4.w;\n\n\t\t\t\toffset_tangent += 16;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyNormals && normalType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 4 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.u;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.v;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces4[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.u;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.v;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.u;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.v;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces4[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.u;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.v;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv2 > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyElements ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\n\n\t\t\t\toffset_face += 3;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\toffset_line += 6;\n\n\t\t\t\tvertexIndex += 3;\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ]     = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 3;\n\n\t\t\t\tfaceArray[ offset_face + 3 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 4 ] = vertexIndex + 2;\n\t\t\t\tfaceArray[ offset_face + 5 ] = vertexIndex + 3;\n\n\t\t\t\toffset_face += 6;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 3;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 6 ] = vertexIndex + 2;\n\t\t\t\tlineArray[ offset_line + 7 ] = vertexIndex + 3;\n\n\t\t\t\toffset_line += 8;\n\n\t\t\t\tvertexIndex += 4;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\n\n\t\t\t\toffset_custom = 0;\n\t\t\t\toffset_customSrc = 0;\n\n\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\toffset_custom += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\n\n\t\t\t\t\t\t\toffset_custom += 8;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\n\n\t\t\t\t\t\t\toffset_custom += 8;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\tvar pp;\n\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\t\t\t\t\t\t\tv4 = value[ 3 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\t\t\t\t\t\t\tv4 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\t\t\t\t\t\t\tv4 = value[ 3 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\n\n\t\t\t\t\t\t\toffset_custom += 16;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tdelete geometryGroup.__inittedArrays;\n\t\t\tdelete geometryGroup.__colorArray;\n\t\t\tdelete geometryGroup.__normalArray;\n\t\t\tdelete geometryGroup.__tangentArray;\n\t\t\tdelete geometryGroup.__uvArray;\n\t\t\tdelete geometryGroup.__uv2Array;\n\t\t\tdelete geometryGroup.__faceArray;\n\t\t\tdelete geometryGroup.__vertexArray;\n\t\t\tdelete geometryGroup.__lineArray;\n\t\t\tdelete geometryGroup.__skinIndexArray;\n\t\t\tdelete geometryGroup.__skinWeightArray;\n\n\t\t}\n\n\t};\n\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\n\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar index = attributes[ \"index\" ];\n\t\tvar position = attributes[ \"position\" ];\n\t\tvar normal = attributes[ \"normal\" ];\n\t\tvar uv = attributes[ \"uv\" ];\n\t\tvar color = attributes[ \"color\" ];\n\t\tvar tangent = attributes[ \"tangent\" ];\n\n\t\tif ( geometry.elementsNeedUpdate && index !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate && position !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate && normal !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate && uv !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate && color !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );\n\n\t\t}\n\n\t\tif ( geometry.tangentsNeedUpdate && tangent !== undefined ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tfor ( var i in geometry.attributes ) {\n\n\t\t\t\tdelete geometry.attributes[ i ].array;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tvar nx, ny, nz,\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\n\t\t\t\t\tnormalArray,\n\t\t\t\t\ti, il = object.count * 3;\n\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\n\n\t\t\t\t\tnormalArray = object.normalArray;\n\n\t\t\t\t\tnax  = normalArray[ i ];\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\n\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\n\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\n\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\n\n\t\t\t\t\tnormalArray[ i ] \t = nx;\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar program, attributes, linewidth, primitives, a, attribute;\n\n\t\tprogram = setProgram( camera, lights, fog, material, object );\n\n\t\tattributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t// if there is more than 1 chunk\n\t\t\t// must set attribute pointers to use new offsets for each chunk\n\t\t\t// even if geometry and materials didn't change\n\n\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\n\n\t\t\tfor ( var i = 0, il = offsets.length; i < il; ++ i ) {\n\n\t\t\t\tvar startIndex = offsets[ i ].index;\n\n\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\n\n\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\n\n\t\t\t\t\t\tvar normalSize = normal.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\n\n\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\n\n\t\t\t\t\t\tif ( uv.buffer ) {\n\n\t\t\t\t\t\t\tvar uvSize = uv.itemSize;\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );\n\n\t\t\t\t\t\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_gl.disableVertexAttribArray( attributes.uv );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// tangents\n\n\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\n\n\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\n\n\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// indices\n\n\t\t\t\t\tvar index = geometry.attributes[ \"index\" ];\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\n\t\t\t\t}\n\n\t\t\t\t// render indexed triangles\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\n\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\n\n\t\t\t}\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\t\t\t\tvar positionSize = position.itemSize;\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t// colors\n\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\n\n\t\t\t\tif ( attributes.color >= 0 && color ) {\n\n\t\t\t\t\tvar colorSize = color.itemSize;\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// render particles\n\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.points += position.numItems / 3;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar program, attributes, linewidth, primitives, a, attribute, i, il;\n\n\t\tprogram = setProgram( camera, lights, fog, material, object );\n\n\t\tattributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// vertices\n\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.morphTargetBase ) {\n\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( updateBuffers ) {\n\n\t\t\t// custom attributes\n\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\n\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\n\n\t\t\t\t\tif( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// colors\n\n\t\t\tif ( attributes.color >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( attributes.normal >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// tangents\n\n\t\t\tif ( attributes.tangent >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( attributes.uv >= 0 ) {\n\n\t\t\t\tif ( geometryGroup.__webglUVBuffer ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.disableVertexAttribArray( attributes.uv );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( attributes.uv2 >= 0 ) {\n\n\t\t\t\tif ( geometryGroup.__webglUV2Buffer ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t_gl.enableVertexAttribArray( attributes.uv2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.disableVertexAttribArray( attributes.uv2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.skinning &&\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t// wireframe\n\n\t\t\tif ( material.wireframe ) {\n\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t// triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n\n\t\t// render lines\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tprimitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\n\n\t\t// render ribbon\n\n\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t}\n\n\t};\n\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\n\n\t\t// set base\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( object.morphTargetBase !== -1 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t} else if ( attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.morphTargetForcedOrder.length ) {\n\n\t\t\t// set forced order\n\n\t\t\tvar m = 0;\n\t\t\tvar order = object.morphTargetForcedOrder;\n\t\t\tvar influences = object.morphTargetInfluences;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\n\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\n\n\t\t\t\tm ++;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find the most influencing\n\n\t\t\tvar influence, activeInfluenceIndices = [];\n\t\t\tvar influences = object.morphTargetInfluences;\n\t\t\tvar i, il = influences.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tinfluence = influences[ i ];\n\n\t\t\t\tif ( influence > 0 ) {\n\n\t\t\t\t\tactiveInfluenceIndices.push( [ i, influence ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\n\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\n\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\n\n\t\t\t};\n\n\t\t\tvar influenceIndex, m = 0;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\n\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\n\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 0 ];\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\n\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tm ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// load updated influences uniform\n\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\n\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\n\n\t\t}\n\n\t};\n\n\t// Sorting\n\n\tfunction painterSort ( a, b ) {\n\n\t\treturn b.z - a.z;\n\n\t};\n\n\tfunction numericalSort ( a, b ) {\n\n\t\treturn b[ 1 ] - a[ 1 ];\n\n\t};\n\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i, il,\n\n\t\twebglObject, object,\n\t\trenderList,\n\n\t\tlights = scene.__lights,\n\t\tfog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\n\t\t// update scene graph\n\n\t\tif ( this.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tif ( ! camera._viewMatrixArray ) camera._viewMatrixArray = new Float32Array( 16 );\n\t\tif ( ! camera._projectionMatrixArray ) camera._projectionMatrixArray = new Float32Array( 16 );\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\tcamera.matrixWorldInverse.flattenToArray( camera._viewMatrixArray );\n\t\tcamera.projectionMatrix.flattenToArray( camera._projectionMatrixArray );\n\n\t\t_projScreenMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// update WebGL objects\n\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\n\n\t\t// custom render plugins (pre pass)\n\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\n\n\t\t//\n\n\t\t_this.info.render.calls = 0;\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\t\t_this.info.render.points = 0;\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\t// set matrices for regular objects (frustum culled)\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {\n\n\t\t\t\t\t//object.matrixWorld.flattenToArray( object._modelMatrixArray );\n\n\t\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\t\tunrollBufferMaterial( webglObject );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.copy( object.matrixWorld.getPosition() );\n\t\t\t\t\t\t\t_projScreenMatrix.multiplyVector3( _vector3 );\n\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.sortObjects ) {\n\n\t\t\trenderList.sort( painterSort );\n\n\t\t}\n\n\t\t// set matrices for immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\t/*\n\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\tobject.matrixWorld.flattenToArray( object._modelMatrixArray );\n\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar material = scene.overrideMaterial;\n\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tthis.setDepthTest( material.depthTest );\n\t\t\tthis.setDepthWrite( material.depthWrite );\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tthis.setBlending( THREE.NormalBlending );\n\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\n\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tupdateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tthis.setDepthTest( true );\n\t\tthis.setDepthWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction renderPlugins( plugins, scene, camera ) {\n\n\t\tif ( ! plugins.length ) return;\n\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\n\n\t\t\t// reset state for plugin (to start from clean slate)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\n\n\t\t\t// reset state after plugin (anything could have changed)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t}\n\n\t};\n\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, buffer, material, start, end, delta;\n\n\t\tif ( reverse ) {\n\n\t\t\tstart = renderList.length - 1;\n\t\t\tend = -1;\n\t\t\tdelta = -1;\n\n\t\t} else {\n\n\t\t\tstart = 0;\n\t\t\tend = renderList.length;\n\t\t\tdelta = 1;\n\t\t}\n\n\t\tfor ( var i = start; i !== end; i += delta ) {\n\n\t\t\twebglObject = renderList[ i ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.setMaterialFaces( material );\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, material, program;\n\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\t_currentGeometryGroupHash = -1;\n\n\t\t_this.setMaterialFaces( material );\n\n\t\tif ( object.immediateRenderCallback ) {\n\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\n\n\t\t} else {\n\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\n\n\t\t}\n\n\t};\n\n\tfunction unrollImmediateBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tmaterial = object.material;\n\n\t\tif ( material.transparent ) {\n\n\t\t\tglobject.transparent = material;\n\t\t\tglobject.opaque = null;\n\n\t\t} else {\n\n\t\t\tglobject.opaque = material;\n\t\t\tglobject.transparent = null;\n\n\t\t}\n\n\t};\n\n\tfunction unrollBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tbuffer = globject.buffer,\n\t\t\tmaterial, materialIndex, meshMaterial;\n\n\t\tmeshMaterial = object.material;\n\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\tmaterialIndex = buffer.materialIndex;\n\n\t\t\tif ( materialIndex >= 0 ) {\n\n\t\t\t\tmaterial = object.geometry.materials[ materialIndex ];\n\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tglobject.transparent = material;\n\t\t\t\t\tglobject.opaque = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglobject.opaque = material;\n\t\t\t\t\tglobject.transparent = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial = meshMaterial;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tglobject.transparent = material;\n\t\t\t\t\tglobject.opaque = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglobject.opaque = material;\n\t\t\t\t\tglobject.transparent = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Geometry splitting\n\n\tfunction sortFacesByMaterial ( geometry ) {\n\n\t\tvar f, fl, face, materialIndex, vertices,\n\t\t\tmaterialHash, groupHash,\n\t\t\thash_map = {};\n\n\t\tvar numMorphTargets = geometry.morphTargets.length;\n\t\tvar numMorphNormals = geometry.morphNormals.length;\n\n\t\tgeometry.geometryGroups = {};\n\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = geometry.faces[ f ];\n\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\tmaterialHash = ( materialIndex !== undefined ) ? materialIndex : -1;\n\n\t\t\tif ( hash_map[ materialHash ] === undefined ) {\n\n\t\t\t\thash_map[ materialHash ] = { 'hash': materialHash, 'counter': 0 };\n\n\t\t\t}\n\n\t\t\tgroupHash = hash_map[ materialHash ].hash + '_' + hash_map[ materialHash ].counter;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t}\n\n\t\t\tvertices = face instanceof THREE.Face3 ? 3 : 4;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\n\n\t\t\t\thash_map[ materialHash ].counter += 1;\n\t\t\t\tgroupHash = hash_map[ materialHash ].hash + '_' + hash_map[ materialHash ].counter;\n\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces4.push( f );\n\n\t\t\t}\n\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\n\n\t\t}\n\n\t\tgeometry.geometryGroupsList = [];\n\n\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\n\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\n\n\t\t}\n\n\t};\n\n\t// Objects refresh\n\n\tthis.initWebGLObjects = function ( scene ) {\n\n\t\tif ( !scene.__webglObjects ) {\n\n\t\t\tscene.__webglObjects = [];\n\t\t\tscene.__webglObjectsImmediate = [];\n\t\t\tscene.__webglSprites = [];\n\t\t\tscene.__webglFlares = [];\n\n\t\t}\n\n\t\twhile ( scene.__objectsAdded.length ) {\n\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\n\n\t\t}\n\n\t\twhile ( scene.__objectsRemoved.length ) {\n\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\n\n\t\t}\n\n\t\t// update must be called after objects adding / removal\n\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\n\n\t\t\tupdateObject( scene.__webglObjects[ o ].object );\n\n\t\t}\n\n\t};\n\n\t// Objects adding\n\n\tfunction addObject ( object, scene ) {\n\n\t\tvar g, geometry, geometryGroup;\n\n\t\tif ( ! object.__webglInit ) {\n\n\t\t\tobject.__webglInit = true;\n\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tif ( geometry.geometryGroups === undefined ) {\n\n\t\t\t\t\t\tsortFacesByMaterial( geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create separate VBOs per geometry chunk\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\t// initialise VBO on the first access\n\n\t\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\n\n\t\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\n\t\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\n\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateRibbonBuffers( geometry );\n\t\t\t\t\tinitRibbonBuffers( geometry );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateLineBuffers( geometry );\n\t\t\t\t\tinitLineBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\n\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! object.__webglActive ) {\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Ribbon ||\n\t\t\t\t\t\tobject instanceof THREE.Line ||\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tscene.__webglSprites.push( object );\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tscene.__webglFlares.push( object );\n\n\t\t\t}\n\n\t\t\tobject.__webglActive = true;\n\n\t\t}\n\n\t};\n\n\tfunction addBuffer ( objlist, buffer, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tbuffer: buffer,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null\n\t\t\t}\n\t\t);\n\n\t};\n\n\tfunction addBufferImmediate ( objlist, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null\n\t\t\t}\n\t\t);\n\n\t};\n\n\t// Objects updates\n\n\tfunction updateObject ( object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tgeometryGroup, customAttributesDirty, material;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {\n\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\t// check all geometry groups\n\n\t\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\n\n\t\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Ribbon ) {\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\n\n\t\t\t\tsetRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate ||  geometry.colorsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\n\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\n\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Objects updates - custom attributes check\n\n\tfunction areCustomAttributesDirty ( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction clearCustomAttributes ( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\n\n\t\t}\n\n\t};\n\n\t// Objects removal\n\n\tfunction removeObject ( object, scene ) {\n\n\t\tif ( object instanceof THREE.Mesh  ||\n\t\t\t object instanceof THREE.ParticleSystem ||\n\t\t\t object instanceof THREE.Ribbon ||\n\t\t\t object instanceof THREE.Line ) {\n\n\t\t\tremoveInstances( scene.__webglObjects, object );\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\n\n\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\n\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\n\n\t\t}\n\n\t\tobject.__webglActive = false;\n\n\t};\n\n\tfunction removeInstances ( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ].object === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction removeInstancesDirect ( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ] === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Materials\n\n\tthis.initMaterial = function ( material, lights, fog, object ) {\n\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\tshaderID = 'depth';\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tshaderID = 'normal';\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\tshaderID = 'lambert';\n\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tshaderID = 'phong';\n\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\tshaderID = 'particle_basic';\n\n\t\t}\n\n\t\tif ( shaderID ) {\n\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\n\n\t\t}\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tmaxLightCount = allocateLights( lights );\n\n\t\tmaxShadows = allocateShadows( lights );\n\n\t\tmaxBones = allocateBones( object );\n\n\t\tparameters = {\n\n\t\t\tmap: !!material.map,\n\t\t\tenvMap: !!material.envMap,\n\t\t\tlightMap: !!material.lightMap,\n\t\t\tbumpMap: !!material.bumpMap,\n\t\t\tnormalMap: !!material.normalMap,\n\t\t\tspecularMap: !!material.specularMap,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n\t\t\tboneTextureWidth: object && object.boneTextureWidth,\n\t\t\tboneTextureHeight: object && object.boneTextureHeight,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\n\n\t\t\tmaxDirLights: maxLightCount.directional,\n\t\t\tmaxPointLights: maxLightCount.point,\n\t\t\tmaxSpotLights: maxLightCount.spot,\n\t\t\tmaxHemiLights: maxLightCount.hemi,\n\n\t\t\tmaxShadows: maxShadows,\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n\t\t\tshadowMapSoft: this.shadowMapSoft,\n\t\t\tshadowMapDebug: this.shadowMapDebug,\n\t\t\tshadowMapCascade: this.shadowMapCascade,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tmetal: material.metal,\n\t\t\tperPixel: material.perPixel,\n\t\t\twrapAround: material.wrapAround,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide\n\n\t\t};\n\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( attributes.position >= 0 ) _gl.enableVertexAttribArray( attributes.position );\n\t\tif ( attributes.color >= 0 ) _gl.enableVertexAttribArray( attributes.color );\n\t\tif ( attributes.normal >= 0 ) _gl.enableVertexAttribArray( attributes.normal );\n\t\tif ( attributes.tangent >= 0 ) _gl.enableVertexAttribArray( attributes.tangent );\n\n\t\tif ( material.skinning &&\n\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\n\t\t\t_gl.enableVertexAttribArray( attributes.skinIndex );\n\t\t\t_gl.enableVertexAttribArray( attributes.skinWeight );\n\n\t\t}\n\n\t\tif ( material.attributes ) {\n\n\t\t\tfor ( a in material.attributes ) {\n\n\t\t\t\tif( attributes[ a ] !== undefined && attributes[ a ] >= 0 ) _gl.enableVertexAttribArray( attributes[ a ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tvar id, base = \"morphTarget\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\t_gl.enableVertexAttribArray( attributes[ id ] );\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tvar id, base = \"morphNormal\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\t_gl.enableVertexAttribArray( attributes[ id ] );\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterial.uniformsList = [];\n\n\t\tfor ( u in material.uniforms ) {\n\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\n\n\t\t}\n\n\t};\n\n\tfunction setMaterialShaders( material, shaders ) {\n\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\n\t\tmaterial.vertexShader = shaders.vertexShader;\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\n\n\t};\n\n\tfunction setProgram( camera, lights, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tif ( material.program ) _this.deallocateMaterial( material );\n\n\t\t\t_this.initMaterial( material, lights, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\n\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar refreshMaterial = false;\n\n\t\tvar program = material.program,\n\t\t\tp_uniforms = program.uniforms,\n\t\t\tm_uniforms = material.uniforms;\n\n\t\tif ( program !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program );\n\t\t\t_currentProgram = program;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera._projectionMatrixArray );\n\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\n\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\n\n\t\t\t\t\tvar textureUnit = getTextureUnit();\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material.lights ) {\n\n\t\t\t\tif ( _lightsNeedUpdate ) {\n\n\t\t\t\t\tsetupLights( program, lights );\n\t\t\t\t\t_lightsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tm_uniforms.mNear.value = camera.near;\n\t\t\t\tm_uniforms.mFar.value = camera.far;\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\n\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\n\n\t\t\t}\n\n\t\t\t// load common uniforms\n\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\n\n\t\t\t\t\tvar position = camera.matrixWorld.getPosition();\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, position.x, position.y, position.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera._viewMatrixArray );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tloadUniformsMatrices( p_uniforms, object );\n\n\t\tif ( p_uniforms.modelMatrix !== null ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\n\n\t\t} else {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.lightMap.value = material.lightMap;\n\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t//\t1. color map\n\t\t//\t2. specular map\n\t\t//\t3. normal map\n\t\t//\t4. bump map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t} else {\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t}\n\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\tuniforms.combine.value = material.combine;\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n\n\t};\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t};\n\n\tfunction refreshUniformsParticle ( uniforms, material ) {\n\n\t\tuniforms.psColor.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size;\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\n\t\tuniforms.map.value = material.map;\n\n\t};\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.shininess.value = material.shininess;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\t\t\tuniforms.specular.value = material.specular;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLights ( uniforms, lights ) {\n\n\t\tuniforms.ambientLightColor.value = lights.ambient;\n\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\n\n\t\tuniforms.pointLightColor.value = lights.point.colors;\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\n\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\n\t\tuniforms.spotLightAngle.value = lights.spot.angles;\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\n\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n\t\tuniforms.hemisphereLightPosition.value = lights.hemi.positions;\n\n\t};\n\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\n\n\t\tif ( uniforms.shadowMatrix ) {\n\n\t\t\tvar j = 0;\n\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\n\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\n\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\n\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\n\n\t\t\t\t\tj ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Uniforms (load to GPU)\n\n\tfunction loadUniformsMatrices ( uniforms, object ) {\n\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\n\n\t\tif ( uniforms.normalMatrix ) {\n\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\n\n\t\t}\n\n\t};\n\n\tfunction getTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= _maxTextures ) {\n\n\t\t\tconsole.warn( \"Trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t};\n\n\tfunction loadUniformsGeneric ( program, uniforms ) {\n\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\n\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\n\t\t\tif ( !location ) continue;\n\n\t\t\tuniform = uniforms[ j ][ 0 ];\n\n\t\t\ttype = uniform.type;\n\t\t\tvalue = uniform.value;\n\n\t\t\tif ( type === \"i\" ) { // single integer\n\n\t\t\t\t_gl.uniform1i( location, value );\n\n\t\t\t} else if ( type === \"f\" ) { // single float\n\n\t\t\t\t_gl.uniform1f( location, value );\n\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\n\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\n\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\n\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\n\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\n\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\n\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\n\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\n\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\n\n\t\t\t\t_gl.uniform1iv( location, value );\n\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3iv( location, value );\n\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\n\n\t\t\t\t_gl.uniform1fv( location, value );\n\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3fv( location, value );\n\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 2;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 3;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 4;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\n\n\t\t\t\t}\n\n\t\t\t\tvalue.flattenToArray( uniform._array );\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\n\n\t\t\t\ttexture = value;\n\t\t\t\ttextureUnit = getTextureUnit();\n\n\t\t\t\t_gl.uniform1i( location, textureUnit );\n\n\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\n\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\n\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\ttexture = uniform.value[ i ];\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\n\n\t\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMatrices ( object, camera ) {\n\n\t\tobject._modelViewMatrix.multiply( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\tobject._normalMatrix.getInverse( object._modelViewMatrix );\n\t\tobject._normalMatrix.transpose();\n\n\t};\n\n\t//\n\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\n\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\n\n\t};\n\n\tfunction setColorLinear( array, offset, color, intensity ) {\n\n\t\tarray[ offset ]     = color.r * intensity;\n\t\tarray[ offset + 1 ] = color.g * intensity;\n\t\tarray[ offset + 2 ] = color.b * intensity;\n\n\t};\n\n\tfunction setupLights ( program, lights ) {\n\n\t\tvar l, ll, light, n,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor, skyColor, groundColor,\n\t\tintensity,  intensitySq,\n\t\tposition,\n\t\tdistance,\n\n\t\tzlights = _lights,\n\n\t\tdirColors = zlights.directional.colors,\n\t\tdirPositions = zlights.directional.positions,\n\n\t\tpointColors = zlights.point.colors,\n\t\tpointPositions = zlights.point.positions,\n\t\tpointDistances = zlights.point.distances,\n\n\t\tspotColors = zlights.spot.colors,\n\t\tspotPositions = zlights.spot.positions,\n\t\tspotDistances = zlights.spot.distances,\n\t\tspotDirections = zlights.spot.directions,\n\t\tspotAngles = zlights.spot.angles,\n\t\tspotExponents = zlights.spot.exponents,\n\n\t\themiSkyColors = zlights.hemi.skyColors,\n\t\themiGroundColors = zlights.hemi.groundColors,\n\t\themiPositions = zlights.hemi.positions,\n\n\t\tdirLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0,\n\n\t\tdirOffset = 0,\n\t\tpointOffset = 0,\n\t\tspotOffset = 0,\n\t\themiOffset = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow || ! light.visible ) continue;\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tr += color.r * color.r;\n\t\t\t\t\tg += color.g * color.g;\n\t\t\t\t\tb += color.b * color.b;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr += color.r;\n\t\t\t\t\tg += color.g;\n\t\t\t\t\tb += color.b;\n\n\t\t\t\t}\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tdirOffset = dirLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_direction.copy( light.matrixWorld.getPosition() );\n\t\t\t\t_direction.subSelf( light.target.matrixWorld.getPosition() );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\n\n\t\t\t\tdirLength += 1;\n\n\t\t\t} else if( light instanceof THREE.PointLight ) {\n\n\t\t\t\tpointOffset = pointLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tposition = light.matrixWorld.getPosition();\n\n\t\t\t\tpointPositions[ pointOffset ]     = position.x;\n\t\t\t\tpointPositions[ pointOffset + 1 ] = position.y;\n\t\t\t\tpointPositions[ pointOffset + 2 ] = position.z;\n\n\t\t\t\tpointDistances[ pointLength ] = distance;\n\n\t\t\t\tpointLength += 1;\n\n\t\t\t} else if( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tspotOffset = spotLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tposition = light.matrixWorld.getPosition();\n\n\t\t\t\tspotPositions[ spotOffset ]     = position.x;\n\t\t\t\tspotPositions[ spotOffset + 1 ] = position.y;\n\t\t\t\tspotPositions[ spotOffset + 2 ] = position.z;\n\n\t\t\t\tspotDistances[ spotLength ] = distance;\n\n\t\t\t\t_direction.copy( position );\n\t\t\t\t_direction.subSelf( light.target.matrixWorld.getPosition() );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\n\n\t\t\t\tspotAngles[ spotLength ] = Math.cos( light.angle );\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\n\n\t\t\t\tspotLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tskyColor = light.color;\n\t\t\t\tgroundColor = light.groundColor;\n\n\t\t\t\themiOffset = hemiLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tintensitySq = intensity * intensity;\n\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tposition = light.matrixWorld.getPosition();\n\n\t\t\t\themiPositions[ hemiOffset ]     = position.x;\n\t\t\t\themiPositions[ hemiOffset + 1 ] = position.y;\n\t\t\t\themiPositions[ hemiOffset + 2 ] = position.z;\n\n\t\t\t\themiLength += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// null eventual remains from removed lights\n\t\t// (this is to avoid if in shader)\n\n\t\tfor ( l = dirLength * 3, ll = dirColors.length; l < ll; l ++ ) dirColors[ l ] = 0.0;\n\t\tfor ( l = pointLength * 3, ll = pointColors.length; l < ll; l ++ ) pointColors[ l ] = 0.0;\n\t\tfor ( l = spotLength * 3, ll = spotColors.length; l < ll; l ++ ) spotColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = hemiSkyColors.length; l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = hemiGroundColors.length; l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\n\n\t\tzlights.directional.length = dirLength;\n\t\tzlights.point.length = pointLength;\n\t\tzlights.spot.length = spotLength;\n\t\tzlights.hemi.length = hemiLength;\n\n\t\tzlights.ambient[ 0 ] = r;\n\t\tzlights.ambient[ 1 ] = g;\n\t\tzlights.ambient[ 2 ] = b;\n\n\t};\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFace ) {\n\n\t\tif ( cullFace ) {\n\n\t\t\tif ( !frontFace || frontFace === \"ccw\" ) {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t}\n\n\t\t\tif( cullFace === \"back\" ) {\n\n\t\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t\t} else if( cullFace === \"front\" ) {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\n\n\t\t\t}\n\n\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t} else {\n\n\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t}\n\n\t};\n\n\tthis.setMaterialFaces = function ( material ) {\n\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\n\t\tvar flipSided = material.side === THREE.BackSide;\n\n\t\tif ( _oldDoubleSided !== doubleSided ) {\n\n\t\t\tif ( doubleSided ) {\n\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\t_oldDoubleSided = doubleSided;\n\n\t\t}\n\n\t\tif ( _oldFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\t_oldFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tif ( _oldDepthTest !== depthTest ) {\n\n\t\t\tif ( depthTest ) {\n\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t}\n\n\t\t\t_oldDepthTest = depthTest;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tif ( _oldDepthWrite !== depthWrite ) {\n\n\t\t\t_gl.depthMask( depthWrite );\n\t\t\t_oldDepthWrite = depthWrite;\n\n\t\t}\n\n\t};\n\n\tfunction setLineWidth ( width ) {\n\n\t\tif ( width !== _oldLineWidth ) {\n\n\t\t\t_gl.lineWidth( width );\n\n\t\t\t_oldLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\n\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\n\n\t\t\tif ( polygonoffset ) {\n\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t\t_oldPolygonOffset = polygonoffset;\n\n\t\t}\n\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\n\n\t\t\t_gl.polygonOffset( factor, units );\n\n\t\t\t_oldPolygonOffsetFactor = factor;\n\t\t\t_oldPolygonOffsetUnits = units;\n\n\t\t}\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\n\n\t\tif ( blending !== _oldBlending ) {\n\n\t\t\tif ( blending === THREE.NoBlending ) {\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t}\n\n\t\t\t_oldBlending = blending;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\n\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\n\n\t\t\t\t_oldBlendEquation = blendEquation;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\n\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\n\n\t\t\t\t_oldBlendSrc = blendSrc;\n\t\t\t\t_oldBlendDst = blendDst;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_oldBlendEquation = null;\n\t\t\t_oldBlendSrc = null;\n\t\t\t_oldBlendDst = null;\n\n\t\t}\n\n\t};\n\n\t// Defines\n\n\tfunction generateDefines ( defines ) {\n\n\t\tvar value, chunk, chunks = [];\n\n\t\tfor ( var d in defines ) {\n\n\t\t\tvalue = defines[ d ];\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunk = \"#define \" + d + \" \" + value;\n\t\t\tchunks.push( chunk );\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\t// Shaders\n\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {\n\n\t\tvar p, pl, d, program, code;\n\t\tvar chunks = [];\n\n\t\t// Generate code\n\n\t\tif ( shaderID ) {\n\n\t\t\tchunks.push( shaderID );\n\n\t\t} else {\n\n\t\t\tchunks.push( fragmentShader );\n\t\t\tchunks.push( vertexShader );\n\n\t\t}\n\n\t\tfor ( d in defines ) {\n\n\t\t\tchunks.push( d );\n\t\t\tchunks.push( defines[ d ] );\n\n\t\t}\n\n\t\tfor ( p in parameters ) {\n\n\t\t\tchunks.push( p );\n\t\t\tchunks.push( parameters[ p ] );\n\n\t\t}\n\n\t\tcode = chunks.join();\n\n\t\t// Check if code has been already compiled\n\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = _programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t// console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\n\n\t\t\t\tprogramInfo.usedTimes ++;\n\n\t\t\t\treturn programInfo.program;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log( \"building new program \" );\n\n\t\t//\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tprogram = _gl.createProgram();\n\n\t\tvar prefix_vertex = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\n\t\t\tcustomDefines,\n\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n\t\t\tparameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed( 1 ) : \"\",\n\t\t\tparameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed( 1 ) : \"\",\n\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapSoft ? \"#define SHADOWMAP_SOFT\" : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n\n\t\t\t\"uniform mat4 modelMatrix;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform mat3 normalMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\n\t\t\t\"attribute vec3 position;\",\n\t\t\t\"attribute vec3 normal;\",\n\t\t\t\"attribute vec2 uv;\",\n\t\t\t\"attribute vec2 uv2;\",\n\n\t\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\t\"attribute vec3 color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\t\"attribute vec3 morphTarget0;\",\n\t\t\t\t\"attribute vec3 morphTarget1;\",\n\t\t\t\t\"attribute vec3 morphTarget2;\",\n\t\t\t\t\"attribute vec3 morphTarget3;\",\n\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"attribute vec4 skinIndex;\",\n\t\t\t\t\"attribute vec4 skinWeight;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar prefix_fragment = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n\n\t\t\tcustomDefines,\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\n\t\t\t( parameters.useFog && parameters.fog instanceof THREE.FogExp2 ) ? \"#define FOG_EXP2\" : \"\",\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapSoft ? \"#define SHADOWMAP_SOFT\" : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\n\n\t\t_gl.attachShader( program, glVertexShader );\n\t\t_gl.attachShader( program, glFragmentShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\n\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\n\n\t\t}\n\n\t\t// clean up\n\n\t\t_gl.deleteShader( glFragmentShader );\n\t\t_gl.deleteShader( glVertexShader );\n\n\t\t//console.log( prefix_fragment + fragmentShader );\n\t\t//console.log( prefix_vertex + vertexShader );\n\n\t\tprogram.uniforms = {};\n\t\tprogram.attributes = {};\n\n\t\tvar identifiers, u, a, i;\n\n\t\t// cache uniform locations\n\n\t\tidentifiers = [\n\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\n\t\t\t'morphTargetInfluences'\n\n\t\t];\n\n\t\tif ( parameters.useVertexTexture ) {\n\n\t\t\tidentifiers.push( 'boneTexture' );\n\n\t\t} else {\n\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\n\n\t\t}\n\n\t\tfor ( u in uniforms ) {\n\n\t\t\tidentifiers.push( u );\n\n\t\t}\n\n\t\tcacheUniformLocations( program, identifiers );\n\n\t\t// cache attributes locations\n\n\t\tidentifiers = [\n\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\n\t\t\t\"skinIndex\", \"skinWeight\"\n\n\t\t];\n\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphTarget\" + i );\n\n\t\t}\n\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphNormal\" + i );\n\n\t\t}\n\n\t\tfor ( a in attributes ) {\n\n\t\t\tidentifiers.push( a );\n\n\t\t}\n\n\t\tcacheAttributeLocations( program, identifiers );\n\n\t\tprogram.id = _programs_counter ++;\n\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\n\n\t\t_this.info.memory.programs = _programs.length;\n\n\t\treturn program;\n\n\t};\n\n\t// Shader parameters cache\n\n\tfunction cacheUniformLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction cacheAttributeLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction addLineNumbers ( string ) {\n\n\t\tvar chunks = string.split( \"\\n\" );\n\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\n\n\t\t\t// Chrome reports shader errors on lines\n\t\t\t// starting counting from 1\n\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\tfunction getShader ( type, string ) {\n\n\t\tvar shader;\n\n\t\tif ( type === \"fragment\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t} else if ( type === \"vertex\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t}\n\n\t\t_gl.shaderSource( shader, string );\n\t\t_gl.compileShader( shader );\n\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\n\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\n\t\t\tconsole.error( addLineNumbers( string ) );\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn shader;\n\n\t};\n\n\t// Textures\n\n\n\tfunction isPowerOfTwo ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0;\n\n\t};\n\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\n\n\t\tif ( isImagePowerOfTwo ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t}\n\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\n\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.setTexture = function ( texture, slot ) {\n\n\t\tif ( texture.needsUpdate ) {\n\n\t\t\tif ( ! texture.__webglInit ) {\n\n\t\t\t\ttexture.__webglInit = true;\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t}\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\n\t\t\tvar image = texture.image,\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\n\n\t\t\tif ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttexture.needsUpdate = false;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t} else {\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t// premultiplied alpha.\n\n\t\tvar maxDimension = Math.max( image.width, image.height );\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\tvar ctx = canvas.getContext( \"2d\" );\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\n\n\t\treturn canvas;\n\n\t}\n\n\tfunction setCubeTexture ( texture, slot ) {\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.needsUpdate ) {\n\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\n\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t\t} else {\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setCubeTextureDynamic ( texture, slot ) {\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\n\n\t};\n\n\t// Render targets\n\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\n\n\t};\n\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\t*/\n\t\t} else if( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\n\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\n\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\n\n\t\t\t// Setup texture, create render and frame buffers\n\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTarget.__webglFramebuffer = [];\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t} else {\n\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\n\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\n\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t}\n\n\t\t\t// Release everything\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null);\n\n\t\t}\n\n\t\tvar framebuffer, width, height, vx, vy;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\twidth = renderTarget.width;\n\t\t\theight = renderTarget.height;\n\n\t\t\tvx = 0;\n\t\t\tvy = 0;\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\twidth = _viewportWidth;\n\t\t\theight = _viewportHeight;\n\n\t\t\tvx = _viewportX;\n\t\t\tvy = _viewportY;\n\n\t\t}\n\n\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.viewport( vx, vy, width, height );\n\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\t_currentWidth = width;\n\t\t_currentHeight = height;\n\n\t};\n\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t};\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t};\n\n\t// Allocations\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader\n\t\t\t//   to be used with multiple objects )\n\t\t\t//\n\t\t\t// \t- leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.bones.length ) {\n\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t};\n\n\tfunction allocateLights ( lights ) {\n\n\t\tvar l, ll, light, dirLights, pointLights, spotLights, hemiLights, maxDirLights, maxPointLights, maxSpotLights, maxHemiLights;\n\n\t\tdirLights = pointLights = spotLights = hemiLights = maxDirLights = maxPointLights = maxSpotLights = maxHemiLights = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\n\n\t\t}\n\n\t\tif ( ( pointLights + spotLights + dirLights + hemiLights) <= _maxLights ) {\n\n\t\t\tmaxDirLights = dirLights;\n\t\t\tmaxPointLights = pointLights;\n\t\t\tmaxSpotLights = spotLights;\n\t\t\tmaxHemiLights = hemiLights;\n\n\t\t} else {\n\n\t\t\tmaxDirLights = Math.ceil( _maxLights * dirLights / ( pointLights + dirLights ) );\n\t\t\tmaxPointLights = _maxLights - maxDirLights;\n\n\t\t\t// these are not really correct\n\n\t\t\tmaxSpotLights = maxPointLights;\n\t\t\tmaxHemiLights = maxDirLights;\n\n\t\t}\n\n\t\treturn { 'directional' : maxDirLights, 'point' : maxPointLights, 'spot': maxSpotLights, 'hemi': maxHemiLights };\n\n\t};\n\n\tfunction allocateShadows ( lights ) {\n\n\t\tvar l, ll, light, maxShadows = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\n\n\t\t}\n\n\t\treturn maxShadows;\n\n\t};\n\n\t// Initialization\n\n\tfunction initGL () {\n\n\t\ttry {\n\n\t\t\tif ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\n\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\n\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( ! _glExtensionTextureFloat ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionStandardDerivatives ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\n\n\t\t}\n\n\t};\n\n\tfunction setDefaultGLState () {\n\n\t\t_gl.clearColor( 0, 0, 0, 1 );\n\t\t_gl.clearDepth( 1 );\n\t\t_gl.clearStencil( 0 );\n\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthFunc( _gl.LEQUAL );\n\n\t\t_gl.frontFace( _gl.CCW );\n\t\t_gl.cullFace( _gl.BACK );\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t_gl.enable( _gl.BLEND );\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\t// default plugins (order is important)\n\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\n\tthis.addPrePlugin( this.shadowMapPlugin );\n\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\n\n};\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\toptions = options || {};\n\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\n\tthis.generateMipmaps = true;\n\n};\n\nTHREE.WebGLRenderTarget.prototype.clone = function() {\n\n\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\n\n\ttmp.wrapS = this.wrapS;\n\ttmp.wrapT = this.wrapT;\n\n\ttmp.magFilter = this.magFilter;\n\ttmp.anisotropy = this.anisotropy;\n\n\ttmp.minFilter = this.minFilter;\n\n\ttmp.offset.copy( this.offset );\n\ttmp.repeat.copy( this.repeat );\n\n\ttmp.format = this.format;\n\ttmp.type = this.type;\n\n\ttmp.depthBuffer = this.depthBuffer;\n\ttmp.stencilBuffer = this.stencilBuffer;\n\n\ttmp.generateMipmaps = this.generateMipmaps;\n\n\treturn tmp;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableVertex = function () {\n\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n}\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace3 = function () {\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.centroidWorld = new THREE.Vector3();\n\tthis.centroidScreen = new THREE.Vector3();\n\n\tthis.normalWorld = new THREE.Vector3();\n\tthis.vertexNormalsWorld = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace4 = function () {\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\tthis.v4 = new THREE.RenderableVertex();\n\n\tthis.centroidWorld = new THREE.Vector3();\n\tthis.centroidScreen = new THREE.Vector3();\n\n\tthis.normalWorld = new THREE.Vector3();\n\tthis.vertexNormalsWorld = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.object = null;\n\tthis.z = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableParticle = function () {\n\n\tthis.object = null;\n\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\n\tthis.rotation = null;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableLine = function () {\n\n\tthis.z = null;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.material = null;\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ColorUtils = {\n\n\tadjustHSV : function ( color, h, s, v ) {\n\n\t\tvar hsv = THREE.ColorUtils.__hsv;\n\n\t\tTHREE.ColorUtils.rgbToHsv( color, hsv );\n\n\t\thsv.h = THREE.Math.clamp( hsv.h + h, 0, 1 );\n\t\thsv.s = THREE.Math.clamp( hsv.s + s, 0, 1 );\n\t\thsv.v = THREE.Math.clamp( hsv.v + v, 0, 1 );\n\n\t\tcolor.setHSV( hsv.h, hsv.s, hsv.v );\n\n\t},\n\n\t// based on MochiKit implementation by Bob Ippolito\n\n\trgbToHsv : function ( color, hsv ) {\n\n\t\tvar r = color.r;\n\t\tvar g = color.g;\n\t\tvar b = color.b;\n\n\t\tvar max = Math.max( Math.max( r, g ), b );\n\t\tvar min = Math.min( Math.min( r, g ), b );\n\n\t\tvar hue;\n\t\tvar saturation;\n\t\tvar value = max;\n\n\t\tif ( min === max )\t{\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = ( max - min );\n\t\t\tsaturation = delta / max;\n\n\t\t\tif ( r === max ) {\n\n\t\t\t\thue = ( g - b ) / delta;\n\n\t\t\t} else if ( g === max ) {\n\n\t\t\t\thue = 2 + ( ( b - r ) / delta );\n\n\t\t\t} else\t{\n\n\t\t\t\thue = 4 + ( ( r - g ) / delta );\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t\tif ( hue < 0 ) {\n\n\t\t\t\thue += 1;\n\n\t\t\t}\n\n\t\t\tif ( hue > 1 ) {\n\n\t\t\t\thue -= 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hsv === undefined ) {\n\n\t\t\thsv = { h: 0, s: 0, v: 0 };\n\n\t\t}\n\n\t\thsv.h = hue;\n\t\thsv.s = saturation;\n\t\thsv.v = value;\n\n\t\treturn hsv;\n\n\t}\n\n};\n\nTHREE.ColorUtils.__hsv = { h: 0, s: 0, v: 0 };/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.GeometryUtils = {\n\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\n\tmerge: function ( geometry1, object2 /* mesh | geometry */ ) {\n\n\t\tvar matrix, matrixRotation,\n\t\tvertexOffset = geometry1.vertices.length,\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\n\t\tvertices1 = geometry1.vertices,\n\t\tvertices2 = geometry2.vertices,\n\t\tfaces1 = geometry1.faces,\n\t\tfaces2 = geometry2.faces,\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\n\n\t\tvar geo1MaterialsMap = {};\n\n\t\tfor ( var i = 0; i < geometry1.materials.length; i ++ ) {\n\n\t\t\tvar id = geometry1.materials[ i ].id;\n\n\t\t\tgeo1MaterialsMap[ id ] = i;\n\n\t\t}\n\n\t\tif ( object2 instanceof THREE.Mesh ) {\n\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\n\n\t\t\tmatrix = object2.matrix;\n\t\t\tmatrixRotation = new THREE.Matrix4();\n\t\t\tmatrixRotation.extractRotation( matrix, object2.scale );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix ) matrix.multiplyVector3( vertexCopy );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tfaceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );\n\n\t\t\t}\n\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( matrixRotation ) matrixRotation.multiplyVector3( faceCopy.normal );\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( matrixRotation ) matrixRotation.multiplyVector3( normal );\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tif ( face.materialIndex !== undefined ) {\n\n\t\t\t\tvar material2 = geometry2.materials[ face.materialIndex ];\n\t\t\t\tvar materialId2 = material2.id;\n\n\t\t\t\tvar materialIndex = geo1MaterialsMap[ materialId2 ];\n\n\t\t\t\tif ( materialIndex === undefined ) {\n\n\t\t\t\t\tmaterialIndex = geometry1.materials.length;\n\t\t\t\t\tgeo1MaterialsMap[ materialId2 ] = materialIndex;\n\n\t\t\t\t\tgeometry1.materials.push( material2 );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = materialIndex;\n\n\t\t\t}\n\n\t\t\tfaceCopy.centroid.copy( face.centroid );\n\t\t\tif ( matrix ) matrix.multiplyVector3( faceCopy.centroid );\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.UV( uv[ j ].u, uv[ j ].v ) );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tclone: function ( geometry ) {\n\n\t\tvar cloneGeo = new THREE.Geometry();\n\n\t\tvar i, il;\n\n\t\tvar vertices = geometry.vertices,\n\t\t\tfaces = geometry.faces,\n\t\t\tuvs = geometry.faceVertexUvs[ 0 ];\n\n\t\t// materials\n\n\t\tif ( geometry.materials ) {\n\n\t\t\tcloneGeo.materials = geometry.materials.slice();\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices[ i ];\n\n\t\t\tcloneGeo.vertices.push( vertex.clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tcloneGeo.faces.push( face.clone() );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.UV( uv[ j ].u, uv[ j ].v ) );\n\n\t\t\t}\n\n\t\t\tcloneGeo.faceVertexUvs[ 0 ].push( uvCopy );\n\n\t\t}\n\n\t\treturn cloneGeo;\n\n\t},\n\n\t// Get random point in triangle (via barycentric coordinates)\n\t// \t(uniform distribution)\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\n\trandomPointInTriangle: function ( vectorA, vectorB, vectorC ) {\n\n\t\tvar a, b, c,\n\t\t\tpoint = new THREE.Vector3(),\n\t\t\ttmp = THREE.GeometryUtils.__v1;\n\n\t\ta = THREE.GeometryUtils.random();\n\t\tb = THREE.GeometryUtils.random();\n\n\t\tif ( ( a + b ) > 1 ) {\n\n\t\t\ta = 1 - a;\n\t\t\tb = 1 - b;\n\n\t\t}\n\n\t\tc = 1 - a - b;\n\n\t\tpoint.copy( vectorA );\n\t\tpoint.multiplyScalar( a );\n\n\t\ttmp.copy( vectorB );\n\t\ttmp.multiplyScalar( b );\n\n\t\tpoint.addSelf( tmp );\n\n\t\ttmp.copy( vectorC );\n\t\ttmp.multiplyScalar( c );\n\n\t\tpoint.addSelf( tmp );\n\n\t\treturn point;\n\n\t},\n\n\t// Get random point in face (triangle / quad)\n\t// (uniform distribution)\n\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\n\n\t\tvar vA, vB, vC, vD;\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\tvA = geometry.vertices[ face.a ];\n\t\t\tvB = geometry.vertices[ face.b ];\n\t\t\tvC = geometry.vertices[ face.c ];\n\n\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\tvA = geometry.vertices[ face.a ];\n\t\t\tvB = geometry.vertices[ face.b ];\n\t\t\tvC = geometry.vertices[ face.c ];\n\t\t\tvD = geometry.vertices[ face.d ];\n\n\t\t\tvar area1, area2;\n\n\t\t\tif ( useCachedAreas ) {\n\n\t\t\t\tif ( face._area1 && face._area2 ) {\n\n\t\t\t\t\tarea1 = face._area1;\n\t\t\t\t\tarea2 = face._area2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\n\t\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t\t\tface._area1 = area1;\n\t\t\t\t\tface._area2 = area2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),\n\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t}\n\n\t\t\tvar r = THREE.GeometryUtils.random() * ( area1 + area2 );\n\n\t\t\tif ( r < area1 ) {\n\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );\n\n\t\t\t} else {\n\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// Get uniformly distributed random points in mesh\n\t// \t- create array with cumulative sums of face areas\n\t//  - pick random number from 0 to total area\n\t//  - find corresponding place in area array by binary search\n\t//\t- get random point in face\n\n\trandomPointsInGeometry: function ( geometry, n ) {\n\n\t\tvar face, i,\n\t\t\tfaces = geometry.faces,\n\t\t\tvertices = geometry.vertices,\n\t\t\til = faces.length,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC, vD;\n\n\t\t// precompute face areas\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\tvA = vertices[ face.a ];\n\t\t\t\tvB = vertices[ face.b ];\n\t\t\t\tvC = vertices[ face.c ];\n\n\t\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvA = vertices[ face.a ];\n\t\t\t\tvB = vertices[ face.b ];\n\t\t\t\tvC = vertices[ face.c ];\n\t\t\t\tvD = vertices[ face.d ];\n\n\t\t\t\tface._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\n\t\t\t\tface._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\n\n\t\t\t\tface._area = face._area1 + face._area2;\n\n\t\t\t}\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[ i ] = totalArea;\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tvar stats = {};\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = THREE.GeometryUtils.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\n\t\t\tif ( ! stats[ index ] ) {\n\n\t\t\t\tstats[ index ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tstats[ index ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Get triangle area (by Heron's formula)\n\t// \thttp://en.wikipedia.org/wiki/Heron%27s_formula\n\n\ttriangleArea: function ( vectorA, vectorB, vectorC ) {\n\n\t\tvar s, a, b, c,\n\t\t\ttmp = THREE.GeometryUtils.__v1;\n\n\t\ttmp.sub( vectorA, vectorB );\n\t\ta = tmp.length();\n\n\t\ttmp.sub( vectorA, vectorC );\n\t\tb = tmp.length();\n\n\t\ttmp.sub( vectorB, vectorC );\n\t\tc = tmp.length();\n\n\t\ts = 0.5 * ( a + b + c );\n\n\t\treturn Math.sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n\n\t},\n\n\t// Center geometry so that 0,0,0 is in center of bounding box\n\n\tcenter: function ( geometry ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t\tvar bb = geometry.boundingBox;\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\toffset.add( bb.min, bb.max );\n\t\toffset.multiplyScalar( -0.5 );\n\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\n\t\tgeometry.computeBoundingBox();\n\n\t\treturn offset;\n\n\t},\n\n\t// Normalize UVs to be from <0,1>\n\t// (for now just the first set of UVs)\n\n\tnormalizeUVs: function ( geometry ) {\n\n\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\n\n\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\n\n\t\t\tvar uvs = uvSet[ i ];\n\n\t\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\n\n\t\t\t\t// texture repeat\n\n\t\t\t\tif( uvs[ j ].u !== 1.0 ) uvs[ j ].u = uvs[ j ].u - Math.floor( uvs[ j ].u );\n\t\t\t\tif( uvs[ j ].v !== 1.0 ) uvs[ j ].v = uvs[ j ].v - Math.floor( uvs[ j ].v );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttriangulateQuads: function ( geometry ) {\n\n\t\tvar i, il, j, jl;\n\n\t\tvar faces = [];\n\t\tvar faceUvs = [];\n\t\tvar faceVertexUvs = [];\n\n\t\tfor ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = geometry.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\t\t\t\tvar d = face.d;\n\n\t\t\t\tvar triA = new THREE.Face3();\n\t\t\t\tvar triB = new THREE.Face3();\n\n\t\t\t\ttriA.color.copy( face.color );\n\t\t\t\ttriB.color.copy( face.color );\n\n\t\t\t\ttriA.materialIndex = face.materialIndex;\n\t\t\t\ttriB.materialIndex = face.materialIndex;\n\n\t\t\t\ttriA.a = a;\n\t\t\t\ttriA.b = b;\n\t\t\t\ttriA.c = d;\n\n\t\t\t\ttriB.a = b;\n\t\t\t\ttriB.b = c;\n\t\t\t\ttriB.c = d;\n\n\t\t\t\tif ( face.vertexColors.length === 4 ) {\n\n\t\t\t\t\ttriA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();\n\t\t\t\t\ttriA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();\n\t\t\t\t\ttriA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\n\n\t\t\t\t\ttriB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();\n\t\t\t\t\ttriB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();\n\t\t\t\t\ttriB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\n\n\t\t\t\t}\n\n\t\t\t\tfaces.push( triA, triB );\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\n\n\t\t\t\t\t\tvar uvs = geometry.faceVertexUvs[ j ][ i ];\n\n\t\t\t\t\t\tvar uvA = uvs[ 0 ];\n\t\t\t\t\t\tvar uvB = uvs[ 1 ];\n\t\t\t\t\t\tvar uvC = uvs[ 2 ];\n\t\t\t\t\t\tvar uvD = uvs[ 3 ];\n\n\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];\n\t\t\t\t\t\tvar uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];\n\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tif ( geometry.faceUvs[ j ].length ) {\n\n\t\t\t\t\t\tvar faceUv = geometry.faceUvs[ j ][ i ];\n\n\t\t\t\t\t\tfaceUvs[ j ].push( faceUv, faceUv );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfaces.push( face );\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tfaceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.faces = faces;\n\t\tgeometry.faceUvs = faceUvs;\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\n\t\tgeometry.computeCentroids();\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\n\n\t},\n\n\t// Make all faces use unique vertices\n\t// so that each face can be separated from others\n\n\texplode: function( geometry ) {\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tvar n = vertices.length;\n\n\t\t\tvar face = geometry.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face4 ) {\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\t\t\t\tvar d = face.d;\n\n\t\t\t\tvar va = geometry.vertices[ a ];\n\t\t\t\tvar vb = geometry.vertices[ b ];\n\t\t\t\tvar vc = geometry.vertices[ c ];\n\t\t\t\tvar vd = geometry.vertices[ d ];\n\n\t\t\t\tvertices.push( va.clone() );\n\t\t\t\tvertices.push( vb.clone() );\n\t\t\t\tvertices.push( vc.clone() );\n\t\t\t\tvertices.push( vd.clone() );\n\n\t\t\t\tface.a = n;\n\t\t\t\tface.b = n + 1;\n\t\t\t\tface.c = n + 2;\n\t\t\t\tface.d = n + 3;\n\n\t\t\t} else {\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\n\t\t\t\tvar va = geometry.vertices[ a ];\n\t\t\t\tvar vb = geometry.vertices[ b ];\n\t\t\t\tvar vc = geometry.vertices[ c ];\n\n\t\t\t\tvertices.push( va.clone() );\n\t\t\t\tvertices.push( vb.clone() );\n\t\t\t\tvertices.push( vc.clone() );\n\n\t\t\t\tface.a = n;\n\t\t\t\tface.b = n + 1;\n\t\t\t\tface.c = n + 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.vertices = vertices;\n\t\tdelete geometry.__tmpVertices;\n\n\t},\n\n\t// Break faces with edges longer than maxEdgeLength\n\t// - not recursive\n\n\ttessellate: function ( geometry, maxEdgeLength ) {\n\n\t\tvar i, il, face,\n\t\ta, b, c, d,\n\t\tva, vb, vc, vd,\n\t\tdab, dbc, dac, dcd, dad,\n\t\tm, m1, m2,\n\t\tvm, vm1, vm2,\n\t\tvnm, vnm1, vnm2,\n\t\tvcm, vcm1, vcm2,\n\t\ttriA, triB,\n\t\tquadA, quadB,\n\t\tedge;\n\n\t\tvar faces = [];\n\t\tvar faceVertexUvs = [];\n\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tface = geometry.faces[ i ];\n\n\t\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t\ta = face.a;\n\t\t\t\tb = face.b;\n\t\t\t\tc = face.c;\n\n\t\t\t\tva = geometry.vertices[ a ];\n\t\t\t\tvb = geometry.vertices[ b ];\n\t\t\t\tvc = geometry.vertices[ c ];\n\n\t\t\t\tdab = va.distanceTo( vb );\n\t\t\t\tdbc = vb.distanceTo( vc );\n\t\t\t\tdac = va.distanceTo( vc );\n\n\t\t\t\tif ( dab > maxEdgeLength || dbc > maxEdgeLength || dac > maxEdgeLength ) {\n\n\t\t\t\t\tm = geometry.vertices.length;\n\n\t\t\t\t\ttriA = face.clone();\n\t\t\t\t\ttriB = face.clone();\n\n\t\t\t\t\tif ( dab >= dbc && dab >= dac ) {\n\n\t\t\t\t\t\tvm = va.clone();\n\t\t\t\t\t\tvm.lerpSelf( vb, 0.5 );\n\n\t\t\t\t\t\ttriA.a = a;\n\t\t\t\t\t\ttriA.b = m;\n\t\t\t\t\t\ttriA.c = c;\n\n\t\t\t\t\t\ttriB.a = m;\n\t\t\t\t\t\ttriB.b = b;\n\t\t\t\t\t\ttriB.c = c;\n\n\t\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\n\n\t\t\t\t\t\t\tvnm = face.vertexNormals[ 0 ].clone();\n\t\t\t\t\t\t\tvnm.lerpSelf( face.vertexNormals[ 1 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexNormals[ 1 ].copy( vnm );\n\t\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\n\n\t\t\t\t\t\t\tvcm = face.vertexColors[ 0 ].clone();\n\t\t\t\t\t\t\tvcm.lerpSelf( face.vertexColors[ 1 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexColors[ 1 ].copy( vcm );\n\t\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = 0;\n\n\t\t\t\t\t} else if ( dbc >= dab && dbc >= dac ) {\n\n\t\t\t\t\t\tvm = vb.clone();\n\t\t\t\t\t\tvm.lerpSelf( vc, 0.5 );\n\n\t\t\t\t\t\ttriA.a = a;\n\t\t\t\t\t\ttriA.b = b;\n\t\t\t\t\t\ttriA.c = m;\n\n\t\t\t\t\t\ttriB.a = m;\n\t\t\t\t\t\ttriB.b = c;\n\t\t\t\t\t\ttriB.c = a;\n\n\t\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\n\n\t\t\t\t\t\t\tvnm = face.vertexNormals[ 1 ].clone();\n\t\t\t\t\t\t\tvnm.lerpSelf( face.vertexNormals[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexNormals[ 2 ].copy( vnm );\n\n\t\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\n\t\t\t\t\t\t\ttriB.vertexNormals[ 1 ].copy( face.vertexNormals[ 2 ] );\n\t\t\t\t\t\t\ttriB.vertexNormals[ 2 ].copy( face.vertexNormals[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\n\n\t\t\t\t\t\t\tvcm = face.vertexColors[ 1 ].clone();\n\t\t\t\t\t\t\tvcm.lerpSelf( face.vertexColors[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexColors[ 2 ].copy( vcm );\n\n\t\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\n\t\t\t\t\t\t\ttriB.vertexColors[ 1 ].copy( face.vertexColors[ 2 ] );\n\t\t\t\t\t\t\ttriB.vertexColors[ 2 ].copy( face.vertexColors[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = 1;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvm = va.clone();\n\t\t\t\t\t\tvm.lerpSelf( vc, 0.5 );\n\n\t\t\t\t\t\ttriA.a = a;\n\t\t\t\t\t\ttriA.b = b;\n\t\t\t\t\t\ttriA.c = m;\n\n\t\t\t\t\t\ttriB.a = m;\n\t\t\t\t\t\ttriB.b = b;\n\t\t\t\t\t\ttriB.c = c;\n\n\t\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\n\n\t\t\t\t\t\t\tvnm = face.vertexNormals[ 0 ].clone();\n\t\t\t\t\t\t\tvnm.lerpSelf( face.vertexNormals[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexNormals[ 2 ].copy( vnm );\n\t\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\n\n\t\t\t\t\t\t\tvcm = face.vertexColors[ 0 ].clone();\n\t\t\t\t\t\t\tvcm.lerpSelf( face.vertexColors[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\ttriA.vertexColors[ 2 ].copy( vcm );\n\t\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( triA, triB );\n\t\t\t\t\tgeometry.vertices.push( vm );\n\n\t\t\t\t\tvar j, jl, uvs, uvA, uvB, uvC, uvM, uvsTriA, uvsTriB;\n\n\t\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\n\n\t\t\t\t\t\t\tuvs = geometry.faceVertexUvs[ j ][ i ];\n\n\t\t\t\t\t\t\tuvA = uvs[ 0 ];\n\t\t\t\t\t\t\tuvB = uvs[ 1 ];\n\t\t\t\t\t\t\tuvC = uvs[ 2 ];\n\n\t\t\t\t\t\t\t// AB\n\n\t\t\t\t\t\t\tif ( edge === 0 ) {\n\n\t\t\t\t\t\t\t\tuvM = uvA.clone();\n\t\t\t\t\t\t\t\tuvM.lerpSelf( uvB, 0.5 );\n\n\t\t\t\t\t\t\t\tuvsTriA = [ uvA.clone(), uvM.clone(), uvC.clone() ];\n\t\t\t\t\t\t\t\tuvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\n\n\t\t\t\t\t\t\t// BC\n\n\t\t\t\t\t\t\t} else if ( edge === 1 ) {\n\n\t\t\t\t\t\t\t\tuvM = uvB.clone();\n\t\t\t\t\t\t\t\tuvM.lerpSelf( uvC, 0.5 );\n\n\t\t\t\t\t\t\t\tuvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\n\t\t\t\t\t\t\t\tuvsTriB = [ uvM.clone(), uvC.clone(), uvA.clone() ];\n\n\t\t\t\t\t\t\t// AC\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tuvM = uvA.clone();\n\t\t\t\t\t\t\t\tuvM.lerpSelf( uvC, 0.5 );\n\n\t\t\t\t\t\t\t\tuvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\n\t\t\t\t\t\t\t\tuvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ta = face.a;\n\t\t\t\tb = face.b;\n\t\t\t\tc = face.c;\n\t\t\t\td = face.d;\n\n\t\t\t\tva = geometry.vertices[ a ];\n\t\t\t\tvb = geometry.vertices[ b ];\n\t\t\t\tvc = geometry.vertices[ c ];\n\t\t\t\tvd = geometry.vertices[ d ];\n\n\t\t\t\tdab = va.distanceTo( vb );\n\t\t\t\tdbc = vb.distanceTo( vc );\n\t\t\t\tdcd = vc.distanceTo( vd );\n\t\t\t\tdad = va.distanceTo( vd );\n\n\t\t\t\tif ( dab > maxEdgeLength || dbc > maxEdgeLength || dcd > maxEdgeLength || dad > maxEdgeLength ) {\n\n\t\t\t\t\tm1 = geometry.vertices.length;\n\t\t\t\t\tm2 = geometry.vertices.length + 1;\n\n\t\t\t\t\tquadA = face.clone();\n\t\t\t\t\tquadB = face.clone();\n\n\t\t\t\t\tif ( ( dab >= dbc && dab >= dcd && dab >= dad ) || ( dcd >= dbc && dcd >= dab && dcd >= dad ) ) {\n\n\t\t\t\t\t\tvm1 = va.clone();\n\t\t\t\t\t\tvm1.lerpSelf( vb, 0.5 );\n\n\t\t\t\t\t\tvm2 = vc.clone();\n\t\t\t\t\t\tvm2.lerpSelf( vd, 0.5 );\n\n\t\t\t\t\t\tquadA.a = a;\n\t\t\t\t\t\tquadA.b = m1;\n\t\t\t\t\t\tquadA.c = m2;\n\t\t\t\t\t\tquadA.d = d;\n\n\t\t\t\t\t\tquadB.a = m1;\n\t\t\t\t\t\tquadB.b = b;\n\t\t\t\t\t\tquadB.c = c;\n\t\t\t\t\t\tquadB.d = m2;\n\n\t\t\t\t\t\tif ( face.vertexNormals.length === 4 ) {\n\n\t\t\t\t\t\t\tvnm1 = face.vertexNormals[ 0 ].clone();\n\t\t\t\t\t\t\tvnm1.lerpSelf( face.vertexNormals[ 1 ], 0.5 );\n\n\t\t\t\t\t\t\tvnm2 = face.vertexNormals[ 2 ].clone();\n\t\t\t\t\t\t\tvnm2.lerpSelf( face.vertexNormals[ 3 ], 0.5 );\n\n\t\t\t\t\t\t\tquadA.vertexNormals[ 1 ].copy( vnm1 );\n\t\t\t\t\t\t\tquadA.vertexNormals[ 2 ].copy( vnm2 );\n\n\t\t\t\t\t\t\tquadB.vertexNormals[ 0 ].copy( vnm1 );\n\t\t\t\t\t\t\tquadB.vertexNormals[ 3 ].copy( vnm2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( face.vertexColors.length === 4 ) {\n\n\t\t\t\t\t\t\tvcm1 = face.vertexColors[ 0 ].clone();\n\t\t\t\t\t\t\tvcm1.lerpSelf( face.vertexColors[ 1 ], 0.5 );\n\n\t\t\t\t\t\t\tvcm2 = face.vertexColors[ 2 ].clone();\n\t\t\t\t\t\t\tvcm2.lerpSelf( face.vertexColors[ 3 ], 0.5 );\n\n\t\t\t\t\t\t\tquadA.vertexColors[ 1 ].copy( vcm1 );\n\t\t\t\t\t\t\tquadA.vertexColors[ 2 ].copy( vcm2 );\n\n\t\t\t\t\t\t\tquadB.vertexColors[ 0 ].copy( vcm1 );\n\t\t\t\t\t\t\tquadB.vertexColors[ 3 ].copy( vcm2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvm1 = vb.clone();\n\t\t\t\t\t\tvm1.lerpSelf( vc, 0.5 );\n\n\t\t\t\t\t\tvm2 = vd.clone();\n\t\t\t\t\t\tvm2.lerpSelf( va, 0.5 );\n\n\t\t\t\t\t\tquadA.a = a;\n\t\t\t\t\t\tquadA.b = b;\n\t\t\t\t\t\tquadA.c = m1;\n\t\t\t\t\t\tquadA.d = m2;\n\n\t\t\t\t\t\tquadB.a = m2;\n\t\t\t\t\t\tquadB.b = m1;\n\t\t\t\t\t\tquadB.c = c;\n\t\t\t\t\t\tquadB.d = d;\n\n\t\t\t\t\t\tif ( face.vertexNormals.length === 4 ) {\n\n\t\t\t\t\t\t\tvnm1 = face.vertexNormals[ 1 ].clone();\n\t\t\t\t\t\t\tvnm1.lerpSelf( face.vertexNormals[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\tvnm2 = face.vertexNormals[ 3 ].clone();\n\t\t\t\t\t\t\tvnm2.lerpSelf( face.vertexNormals[ 0 ], 0.5 );\n\n\t\t\t\t\t\t\tquadA.vertexNormals[ 2 ].copy( vnm1 );\n\t\t\t\t\t\t\tquadA.vertexNormals[ 3 ].copy( vnm2 );\n\n\t\t\t\t\t\t\tquadB.vertexNormals[ 0 ].copy( vnm2 );\n\t\t\t\t\t\t\tquadB.vertexNormals[ 1 ].copy( vnm1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( face.vertexColors.length === 4 ) {\n\n\t\t\t\t\t\t\tvcm1 = face.vertexColors[ 1 ].clone();\n\t\t\t\t\t\t\tvcm1.lerpSelf( face.vertexColors[ 2 ], 0.5 );\n\n\t\t\t\t\t\t\tvcm2 = face.vertexColors[ 3 ].clone();\n\t\t\t\t\t\t\tvcm2.lerpSelf( face.vertexColors[ 0 ], 0.5 );\n\n\t\t\t\t\t\t\tquadA.vertexColors[ 2 ].copy( vcm1 );\n\t\t\t\t\t\t\tquadA.vertexColors[ 3 ].copy( vcm2 );\n\n\t\t\t\t\t\t\tquadB.vertexColors[ 0 ].copy( vcm2 );\n\t\t\t\t\t\t\tquadB.vertexColors[ 1 ].copy( vcm1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( quadA, quadB );\n\t\t\t\t\tgeometry.vertices.push( vm1, vm2 );\n\n\t\t\t\t\tvar j, jl, uvs, uvA, uvB, uvC, uvD, uvM1, uvM2, uvsQuadA, uvsQuadB;\n\n\t\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\n\n\t\t\t\t\t\t\tuvs = geometry.faceVertexUvs[ j ][ i ];\n\n\t\t\t\t\t\t\tuvA = uvs[ 0 ];\n\t\t\t\t\t\t\tuvB = uvs[ 1 ];\n\t\t\t\t\t\t\tuvC = uvs[ 2 ];\n\t\t\t\t\t\t\tuvD = uvs[ 3 ];\n\n\t\t\t\t\t\t\t// AB + CD\n\n\t\t\t\t\t\t\tif ( edge === 0 ) {\n\n\t\t\t\t\t\t\t\tuvM1 = uvA.clone();\n\t\t\t\t\t\t\t\tuvM1.lerpSelf( uvB, 0.5 );\n\n\t\t\t\t\t\t\t\tuvM2 = uvC.clone();\n\t\t\t\t\t\t\t\tuvM2.lerpSelf( uvD, 0.5 );\n\n\t\t\t\t\t\t\t\tuvsQuadA = [ uvA.clone(), uvM1.clone(), uvM2.clone(), uvD.clone() ];\n\t\t\t\t\t\t\t\tuvsQuadB = [ uvM1.clone(), uvB.clone(), uvC.clone(), uvM2.clone() ];\n\n\t\t\t\t\t\t\t// BC + AD\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tuvM1 = uvB.clone();\n\t\t\t\t\t\t\t\tuvM1.lerpSelf( uvC, 0.5 );\n\n\t\t\t\t\t\t\t\tuvM2 = uvD.clone();\n\t\t\t\t\t\t\t\tuvM2.lerpSelf( uvA, 0.5 );\n\n\t\t\t\t\t\t\t\tuvsQuadA = [ uvA.clone(), uvB.clone(), uvM1.clone(), uvM2.clone() ];\n\t\t\t\t\t\t\t\tuvsQuadB = [ uvM2.clone(), uvM1.clone(), uvC.clone(), uvD.clone() ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsQuadA, uvsQuadB );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.faces = faces;\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\n\t}\n\n};\n\nTHREE.GeometryUtils.random = THREE.Math.random16;\n\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: 'anonymous',\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar image = new Image();\n\t\tvar texture = new THREE.Texture( image, mapping );\n\n\t\tvar loader = new THREE.ImageLoader();\n\n\t\tloader.addEventListener( 'load', function ( event ) {\n\n\t\t\ttexture.image = event.content;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t} );\n\n\t\tloader.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event.message );\n\n\t\t} );\n\n\t\tloader.crossOrigin = this.crossOrigin;\n\t\tloader.load( url, image );\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.mapping = mapping;\n\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.onload = function () {\n\n\t\t\tvar buffer = request.response;\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\ttexture.format = dds.format;\n\n\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\ttexture.image.width = dds.width;\n\t\t\ttexture.image.height = dds.height;\n\n\t\t\t// gl.generateMipmap fails for compressed textures\n\t\t\t// mipmaps must be embedded in the DDS file\n\t\t\t// or texture filters must not use mipmapping\n\n\t\t\ttexture.generateMipmaps = false;\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t}\n\n\t\trequest.onerror = onError;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.responseType = \"arraybuffer\";\n\t\trequest.send( null );\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.Texture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping needed for cube textures\n\n\t\ttexture.flipY = false;\n\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\tvar cubeImage = new Image();\n\t\t\timages[ i ] = cubeImage;\n\n\t\t\tcubeImage.onload = function () {\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad();\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcubeImage.onerror = onError;\n\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\n\t\t\tcubeImage.src = array[ i ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tvar buffer = rq.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\timg.format = dds.format;\n\n\t\t\t\timg.mipmaps = dds.mipmaps;\n\t\t\t\timg.width = dds.width;\n\t\t\t\timg.height = dds.height;\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\tvar cubeImage = {};\n\t\t\timages[ i ] = cubeImage;\n\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\n\t\t\trequest.onerror = onError;\n\n\t\t\tvar url = array[ i ];\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tparseDDS: function ( buffer, loadMipmaps ) {\n\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\tvar DDSD_CAPS = 0x1,\n\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\tDDSD_WIDTH = 0x4,\n\t\t\tDDSD_PITCH = 0x8,\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\tDDPF_ALPHA = 0x2,\n\t\t\tDDPF_FOURCC = 0x4,\n\t\t\tDDPF_RGB = 0x40,\n\t\t\tDDPF_YUV = 0x200,\n\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt(0) +\n\t\t\t\t(value.charCodeAt(1) << 8) +\n\t\t\t\t(value.charCodeAt(2) << 16) +\n\t\t\t\t(value.charCodeAt(3) << 24);\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t(value >> 8) & 0xff,\n\t\t\t\t(value >> 16) & 0xff,\n\t\t\t\t(value >> 24) & 0xff\n\t\t\t);\n\t\t}\n\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tvar off_magic = 0;\n\n\t\tvar off_size = 1;\n\t\tvar off_flags = 2;\n\t\tvar off_height = 3;\n\t\tvar off_width = 4;\n\n\t\tvar off_mipmapCount = 7;\n\n\t\tvar off_pfFlags = 20;\n\t\tvar off_pfFourCC = 21;\n\n\t\t// Parse header\n\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n        if ( header[ off_magic ] !== DDS_MAGIC ) {\n\n            console.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\n            return dds;\n\n        }\n\n        if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n            console.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\n            return dds;\n\n        }\n\n\t\tvar blockBytes;\n\n\t\tvar fourCC = header[ off_pfFourCC ];\n\n        switch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n                dds.format = THREE.RGB_S3TC_DXT1_Format;\n                break;\n\n            case FOURCC_DXT3:\n\n                blockBytes = 16;\n                dds.format = THREE.RGBA_S3TC_DXT3_Format;\n                break;\n\n            case FOURCC_DXT5:\n\n                blockBytes = 16;\n                dds.format = THREE.RGBA_S3TC_DXT5_Format;\n                break;\n\n            default:\n\n                console.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\n                return dds;\n\n        }\n\n\t\tdds.mipmapCount = 1;\n\n        if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n            dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n        }\n\n        dds.width = header[ off_width ];\n        dds.height = header[ off_height ];\n\n        var dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\tdataOffset += dataLength;\n\n\t\t\twidth = Math.max( width * 0.5, 1 );\n\t\t\theight = Math.max( height * 0.5, 1 );\n\n\t\t}\n\n\t\treturn dds;\n\n\t},\n\n\tgetNormalMap: function ( image, depth ) {\n\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n\n\t\tvar cross = function ( a, b ) {\n\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\n\n\t\t}\n\n\t\tvar subtract = function ( a, b ) {\n\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\n\n\t\t}\n\n\t\tvar normalize = function ( a ) {\n\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\n\n\t\t}\n\n\t\tdepth = depth | 1;\n\n\t\tvar width = image.width;\n\t\tvar height = image.height;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\n\t\tvar imageData = context.createImageData( width, height );\n\t\tvar output = imageData.data;\n\n\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\n\n\t\t\t\tvar points = [];\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\n\n\t\t\t\tvar normals = [];\n\t\t\t\tvar num_points = points.length;\n\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\n\n\t\t\t\t\tvar v1 = points[ i ];\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\n\t\t\t\t\tv1 = subtract( v1, origin );\n\t\t\t\t\tv2 = subtract( v2, origin );\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar normal = [ 0, 0, 0 ];\n\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\n\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tnormal[ 0 ] /= normals.length;\n\t\t\t\tnormal[ 1 ] /= normals.length;\n\t\t\t\tnormal[ 2 ] /= normals.length;\n\n\t\t\t\tvar idx = ( y * width + x ) * 4;\n\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\n\t\t\t\toutput[ idx + 3 ] = 255;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t},\n\n\tgenerateDataTexture: function ( width, height, color ) {\n\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array( 3 * size );\n\n\t\tvar r = Math.floor( color.r * 255 );\n\t\tvar g = Math.floor( color.g * 255 );\n\t\tvar b = Math.floor( color.b * 255 );\n\n\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\tdata[ i * 3 ] \t  = r;\n\t\t\tdata[ i * 3 + 1 ] = g;\n\t\t\tdata[ i * 3 + 2 ] = b;\n\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Object3D();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach : function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n *\n * ShaderUtils currently contains:\n *\n *\tfresnel\n *\tnormal\n * \tcube\n *\n */\n\nif ( THREE.WebGLRenderer ) {\n\nTHREE.ShaderUtils = {\n\n\tlib: {\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tFresnel shader\n\t\t//\t- based on Nvidia Cg tutorial\n\t\t ------------------------------------------------------------------------- */\n\n\t\t'fresnel': {\n\n\t\t\tuniforms: {\n\n\t\t\t\t\"mRefractionRatio\": { type: \"f\", value: 1.02 },\n\t\t\t\t\"mFresnelBias\": { type: \"f\", value: 0.1 },\n\t\t\t\t\"mFresnelPower\": { type: \"f\", value: 2.0 },\n\t\t\t\t\"mFresnelScale\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"tCube\": { type: \"t\", value: null }\n\n\t\t\t},\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\t\t\t\t\t\"vec4 refractedColor = vec4( 1.0, 1.0, 1.0, 1.0 );\",\n\n\t\t\t\t\t\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n\t\t\t\t\t\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n\t\t\t\t\t\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n\t\t\t\t\t\"refractedColor.a = 1.0;\",\n\n\t\t\t\t\t\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\"),\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform float mRefractionRatio;\",\n\t\t\t\t\"uniform float mFresnelBias;\",\n\t\t\t\t\"uniform float mFresnelScale;\",\n\t\t\t\t\"uniform float mFresnelPower;\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\t\"vec4 mPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\t\"vec3 nWorld = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n\n\t\t\t\t\t\"vec3 I = mPosition.xyz - cameraPosition;\",\n\n\t\t\t\t\t\"vReflect = reflect( I, nWorld );\",\n\t\t\t\t\t\"vRefract[0] = refract( normalize( I ), nWorld, mRefractionRatio );\",\n\t\t\t\t\t\"vRefract[1] = refract( normalize( I ), nWorld, mRefractionRatio * 0.99 );\",\n\t\t\t\t\t\"vRefract[2] = refract( normalize( I ), nWorld, mRefractionRatio * 0.98 );\",\n\t\t\t\t\t\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), nWorld ), mFresnelPower );\",\n\n\t\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\")\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tNormal map shader\n\t\t//\t\t- Blinn-Phong\n\t\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\t\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t\t ------------------------------------------------------------------------- */\n\n\t\t'normal' : {\n\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t\t{\n\n\t\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\n\t\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\n\t\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\n\t\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\n\t\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\n\n\t\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\n\t\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\n\t\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\n\t\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\n\t\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\n\t\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\n\n\t\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\n\t\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\n\n\t\t\t\t\"uDiffuseColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"uSpecularColor\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"uAmbientColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"uShininess\": { type: \"f\", value: 30 },\n\t\t\t\t\"uOpacity\": { type: \"f\", value: 1 },\n\n\t\t\t\t\"useRefract\": { type: \"i\", value: 0 },\n\t\t\t\t\"uRefractionRatio\": { type: \"f\", value: 0.98 },\n\t\t\t\t\"uReflectivity\": { type: \"f\", value: 0.5 },\n\n\t\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\n\t\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform vec3 uAmbientColor;\",\n\t\t\t\t\"uniform vec3 uDiffuseColor;\",\n\t\t\t\t\"uniform vec3 uSpecularColor;\",\n\t\t\t\t\"uniform float uShininess;\",\n\t\t\t\t\"uniform float uOpacity;\",\n\n\t\t\t\t\"uniform bool enableDiffuse;\",\n\t\t\t\t\"uniform bool enableSpecular;\",\n\t\t\t\t\"uniform bool enableAO;\",\n\t\t\t\t\"uniform bool enableReflection;\",\n\n\t\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\t\"uniform sampler2D tSpecular;\",\n\t\t\t\t\"uniform sampler2D tAO;\",\n\n\t\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\t\"uniform vec2 uNormalScale;\",\n\n\t\t\t\t\"uniform bool useRefract;\",\n\t\t\t\t\"uniform float uRefractionRatio;\",\n\t\t\t\t\"uniform float uReflectivity;\",\n\n\t\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\t\"uniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\n\n\t\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\n\t\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\t\"if( enableDiffuse ) {\",\n\n\t\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"if( enableAO ) {\",\n\n\t\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\n\t\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\n\n\t\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"if( enableSpecular )\",\n\t\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n\n\t\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n\t\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\n\t\t\t\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\t\t\t\"finalNormal = -finalNormal;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\t\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\t\t\t// point lights\n\n\t\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\t\"float pointDistance = 1.0;\",\n\t\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t// spot lights\n\n\t\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\t\"float spotDistance = 1.0;\",\n\t\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\n\n\t\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\t\t\t\"if ( spotEffect > spotLightAngle[ i ] ) {\",\n\n\t\t\t\t\t\t\t\t\"spotEffect = pow( spotEffect, spotLightExponent[ i ] );\",\n\n\t\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n\t\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\t\"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t// directional lights\n\n\t\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t// hemisphere lights\n\n\t\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\t\"vec3 lVector = normalize( lPosition.xyz + vViewPosition.xyz );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t\t\"hemiDiffuse += uDiffuseColor * hemiColor;\",\n\n\t\t\t\t\t\t\t// specular (sky light)\n\n\n\t\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\t\"vec3 lVectorGround = normalize( -lPosition.xyz + vViewPosition.xyz );\",\n\n\t\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\n\t\t\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\t\"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\t\t\t\"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t// all lights contribution summation\n\n\t\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#ifdef METAL\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"if ( enableReflection ) {\",\n\n\t\t\t\t\t\t\"vec3 vReflect;\",\n\t\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\n\t\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\"),\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"attribute vec4 tangent;\",\n\n\t\t\t\t\"uniform vec2 uOffset;\",\n\t\t\t\t\"uniform vec2 uRepeat;\",\n\n\t\t\t\t\"uniform bool enableDisplacement;\",\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\n\t\t\t\t\t// normal, tangent and binormal vectors\n\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\"vNormal = normalMatrix * skinnedNormal.xyz;\",\n\n\t\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n\t\t\t\t\t\t\"vTangent = normalMatrix * skinnedTangent.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vNormal = normalMatrix * normal;\",\n\t\t\t\t\t\t\"vTangent = normalMatrix * tangent.xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\",\n\n\t\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\n\n\t\t\t\t\t// displacement mapping\n\n\t\t\t\t\t\"vec3 displacedPosition;\",\n\n\t\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\t\"if ( enableDisplacement ) {\",\n\n\t\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\t\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t//\n\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\t\t\t\t\t\"vec4 mPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\n\t\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t\t//\n\n\t\t\t\t\t\"vWorldPosition = mPosition.xyz;\",\n\t\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t\t// shadows\n\n\t\t\t\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * mPosition;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\")\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\t'cube': {\n\n\t\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\n\t\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vec4 mPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\t\"vViewPosition = cameraPosition - mPosition.xyz;\",\n\n\t\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\"),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform samplerCube tCube;\",\n\t\t\t\t\"uniform float tFlip;\",\n\n\t\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vec3 wPos = cameraPosition - vViewPosition;\",\n\t\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * wPos.x, wPos.yz ) );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join(\"\\n\")\n\n\t\t}\n\n\t}\n\n};\n\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For Text operations in three.js (See TextGeometry)\n *\n * It uses techniques used in:\n *\n * \ttypeface.js and canvastext\n * \t\tFor converting fonts and rendering with javascript\n *\t\thttp://typeface.neocracy.org\n *\n *\tTriangulation ported from AS3\n *\t\tSimple Polygon Triangulation\n *\t\thttp://actionsnippet.com/?p=1462\n *\n * \tA Method to triangulate shapes with holes\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n *\n */\n\nTHREE.FontUtils = {\n\n\tfaces : {},\n\n\t// Just for now. face[weight][style]\n\n\tface : \"helvetiker\",\n\tweight: \"normal\",\n\tstyle : \"normal\",\n\tsize : 150,\n\tdivisions : 10,\n\n\tgetFace : function() {\n\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\n\n\t},\n\n\tloadFace : function( data ) {\n\n\t\tvar family = data.familyName.toLowerCase();\n\n\t\tvar ThreeFont = this;\n\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\n\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\treturn data;\n\n\t},\n\n\tdrawText : function( text ) {\n\n\t\tvar characterPts = [], allPts = [];\n\n\t\t// RenderText\n\n\t\tvar i, p,\n\t\t\tface = this.getFace(),\n\t\t\tscale = this.size / face.resolution,\n\t\t\toffset = 0,\n\t\t\tchars = String( text ).split( '' ),\n\t\t\tlength = chars.length;\n\n\t\tvar fontPaths = [];\n\n\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\n\t\t\toffset += ret.offset;\n\n\t\t\tfontPaths.push( ret.path );\n\n\t\t}\n\n\t\t// get the width\n\n\t\tvar width = offset / 2;\n\t\t//\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\n\t\t//\n\t\t// \tallPts[ p ].x -= width;\n\t\t//\n\t\t// }\n\n\t\t//var extract = this.extractPoints( allPts, characterPts );\n\t\t//extract.contour = allPts;\n\n\t\t//extract.paths = fontPaths;\n\t\t//extract.offset = width;\n\n\t\treturn { paths : fontPaths, offset : width };\n\n\t},\n\n\n\n\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\n\n\t\tvar pts = [];\n\n\t\tvar i, i2, divisions,\n\t\t\toutline, action, length,\n\t\t\tscaleX, scaleY,\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\n\t\t\tlaste,\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\n\n\t\tif ( !glyph ) return;\n\n\t\tif ( glyph.o ) {\n\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\t\tlength = outline.length;\n\n\t\t\tscaleX = scale;\n\t\t\tscaleY = scale;\n\n\t\t\tfor ( i = 0; i < length; ) {\n\n\t\t\t\taction = outline[ i ++ ];\n\n\t\t\t\t//console.log( action );\n\n\t\t\t\tswitch( action ) {\n\n\t\t\t\tcase 'm':\n\n\t\t\t\t\t// Move To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\n\t\t\t\t\t// Line To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\t\t\t\t\tpath.lineTo(x,y);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q':\n\n\t\t\t\t\t// QuadraticCurveTo\n\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\t\t\t\t\t  }\n\n\t\t\t\t  }\n\n\t\t\t\t  break;\n\n\t\t\t\tcase 'b':\n\n\t\t\t\t\t// Cubic Bezier Curve\n\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn { offset: glyph.ha*scale, path:path};\n\t}\n\n};\n\n\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\n\n\t// Parameters\n\n\tparameters = parameters || {};\n\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\n\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\n\n\tTHREE.FontUtils.size = size;\n\tTHREE.FontUtils.divisions = curveSegments;\n\n\tTHREE.FontUtils.face = font;\n\tTHREE.FontUtils.weight = weight;\n\tTHREE.FontUtils.style = style;\n\n\t// Get a Font data json object\n\n\tvar data = THREE.FontUtils.drawText( text );\n\n\tvar paths = data.paths;\n\tvar shapes = [];\n\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t}\n\n\treturn shapes;\n\n};\n\n\n/**\n * This code is a quick port of code written in C++ which was submitted to\n * flipcode.com by John W. Ratcliff  // July 22, 2000\n * See original code and more information here:\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n *\n * ported to actionscript by Zevan Rosser\n * www.actionsnippet.com\n *\n * ported to javascript by Joshua Koo\n * http://www.lab4games.net/zz85/blog\n *\n */\n\n\n( function( namespace ) {\n\n\tvar EPSILON = 0.0000000001;\n\n\t// takes in an contour array and returns\n\n\tvar process = function( contour, indices ) {\n\n\t\tvar n = contour.length;\n\n\t\tif ( n < 3 ) return null;\n\n\t\tvar result = [],\n\t\t\tverts = [],\n\t\t\tvertIndices = [];\n\n\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\tvar u, v, w;\n\n\t\tif ( area( contour ) > 0.0 ) {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\n\n\t\t} else {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t}\n\n\t\tvar nv = n;\n\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\tvar count = 2 * nv;   /* error detection */\n\n\t\tfor( v = nv - 1; nv > 2; ) {\n\n\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\tif ( ( count-- ) <= 0 ) {\n\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t//return null;\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t/* true names of the vertices */\n\n\t\t\t\ta = verts[ u ];\n\t\t\t\tb = verts[ v ];\n\t\t\t\tc = verts[ w ];\n\n\t\t\t\t/* output Triangle */\n\n\t\t\t\t/*\n\t\t\t\tresult.push( contour[ a ] );\n\t\t\t\tresult.push( contour[ b ] );\n\t\t\t\tresult.push( contour[ c ] );\n\t\t\t\t*/\n\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\tcontour[ b ],\n\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\n\n\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t}\n\n\t\t\t\tnv--;\n\n\t\t\t\t/* reset error detection counter */\n\n\t\t\t\tcount = 2 * nv;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices ) return vertIndices;\n\t\treturn result;\n\n\t};\n\n\t// calculate area of the contour polygon\n\n\tvar area = function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t};\n\n\t// see if p is inside triangle abc\n\n\tvar insideTriangle = function( ax, ay,\n\t\t\t\t\t\t\t\t   bx, by,\n\t\t\t\t\t\t\t\t   cx, cy,\n\t\t\t\t\t\t\t\t   px, py ) {\n\n\t\t  var aX, aY, bX, bY;\n\t\t  var cX, cY, apx, apy;\n\t\t  var bpx, bpy, cpx, cpy;\n\t\t  var cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t  aX = cx - bx;  aY = cy - by;\n\t\t  bX = ax - cx;  bY = ay - cy;\n\t\t  cX = bx - ax;  cY = by - ay;\n\t\t  apx= px  -ax;  apy= py - ay;\n\t\t  bpx= px - bx;  bpy= py - by;\n\t\t  cpx= px - cx;  cpy= py - cy;\n\n\t\t  aCROSSbp = aX*bpy - aY*bpx;\n\t\t  cCROSSap = cX*apy - cY*apx;\n\t\t  bCROSScp = bX*cpy - bY*cpx;\n\n\t\t  return ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) );\n\n\t};\n\n\n\tvar snip = function ( contour, u, v, w, n, verts ) {\n\n\t\tvar p;\n\t\tvar ax, ay, bx, by;\n\t\tvar cx, cy, px, py;\n\n\t\tax = contour[ verts[ u ] ].x;\n\t\tay = contour[ verts[ u ] ].y;\n\n\t\tbx = contour[ verts[ v ] ].x;\n\t\tby = contour[ verts[ v ] ].y;\n\n\t\tcx = contour[ verts[ w ] ].x;\n\t\tcy = contour[ verts[ w ] ].y;\n\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\n\n\t\t\tfor ( p = 0; p < n; p++ ) {\n\n\t\t\t\tif( (p == u) || (p == v) || (p == w) ) continue;\n\n\t\t\t\tpx = contour[ verts[ p ] ].x\n\t\t\t\tpy = contour[ verts[ p ] ].y\n\n\t\t\t\tif ( insideTriangle( ax, ay, bx, by, cx, cy, px, py ) ) return false;\n\n\t\t  }\n\n\t\t  return true;\n\n\t};\n\n\n\tnamespace.Triangulate = process;\n\tnamespace.Triangulate.area = area;\n\n\treturn namespace;\n\n})(THREE.FontUtils);\n\n// To use the typeface.js face files, hook up the API\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This file contains following classes:\n *\n * -- 2d classes --\n * THREE.Curve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n * THREE.ClosedSplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\nTHREE.Curve.prototype.getPoint = function ( t ) {\n\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\n\treturn null;\n\n};\n\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\nTHREE.Curve.prototype.getPointAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getPoint( t );\n\n};\n\n// Get sequence of points using getPoint( t )\n\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get sequence of points using getPointAt( u )\n\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get total curve arc length\n\nTHREE.Curve.prototype.getLength = function () {\n\n\tvar lengths = this.getLengths();\n\treturn lengths[ lengths.length - 1 ];\n\n};\n\n// Get list of cumulative segment lengths\n\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\n\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\n\n\tif ( this.cacheArcLengths\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\n\t\t&& !this.needsUpdate) {\n\n\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\treturn this.cacheArcLengths;\n\n\t}\n\n\tthis.needsUpdate = false;\n\n\tvar cache = [];\n\tvar current, last = this.getPoint( 0 );\n\tvar p, sum = 0;\n\n\tcache.push( 0 );\n\n\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\tcurrent = this.getPoint ( p / divisions );\n\t\tsum += current.distanceTo( last );\n\t\tcache.push( sum );\n\t\tlast = current;\n\n\t}\n\n\tthis.cacheArcLengths = cache;\n\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n};\n\n\nTHREE.Curve.prototype.updateArcLengths = function() {\n\tthis.needsUpdate = true;\n\tthis.getLengths();\n};\n\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\n\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\n\n\tvar arcLengths = this.getLengths();\n\n\tvar i = 0, il = arcLengths.length;\n\n\tvar targetArcLength; // The targeted u distance value to get\n\n\tif ( distance ) {\n\n\t\ttargetArcLength = distance;\n\n\t} else {\n\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t}\n\n\t//var time = Date.now();\n\n\t// binary search for the index with largest value smaller than target u distance\n\n\tvar low = 0, high = il - 1, comparison;\n\n\twhile ( low <= high ) {\n\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\tif ( comparison < 0 ) {\n\n\t\t\tlow = i + 1;\n\t\t\tcontinue;\n\n\t\t} else if ( comparison > 0 ) {\n\n\t\t\thigh = i - 1;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\thigh = i;\n\t\t\tbreak;\n\n\t\t\t// DONE\n\n\t\t}\n\n\t}\n\n\ti = high;\n\n\t//console.log('b' , i, low, high, Date.now()- time);\n\n\tif ( arcLengths[ i ] == targetArcLength ) {\n\n\t\tvar t = i / ( il - 1 );\n\t\treturn t;\n\n\t}\n\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\n\n\tvar lengthBefore = arcLengths[ i ];\n    var lengthAfter = arcLengths[ i + 1 ];\n\n    var segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n    // add that fractional amount to t\n\n    var t = ( i + segmentFraction ) / ( il -1 );\n\n\treturn t;\n\n};\n\n\n// In 2D space, there are actually 2 normal vectors,\n// and in 3D space, infinte\n// TODO this should be depreciated.\nTHREE.Curve.prototype.getNormalVector = function( t ) {\n\n\tvar vec = this.getTangent( t );\n\n\treturn new THREE.Vector2( -vec.y , vec.x );\n\n};\n\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent / normal finding,\n// we get 2 points with a small delta and find a gradient of the 2 points\n// which seems to make a reasonable approximation\n\nTHREE.Curve.prototype.getTangent = function( t ) {\n\n\tvar delta = 0.0001;\n\tvar t1 = t - delta;\n\tvar t2 = t + delta;\n\n\t// Capping in case of danger\n\n\tif ( t1 < 0 ) t1 = 0;\n\tif ( t2 > 1 ) t2 = 1;\n\n\tvar pt1 = this.getPoint( t1 );\n\tvar pt2 = this.getPoint( t2 );\n\n\tvar vec = pt2.clone().subSelf(pt1);\n\treturn vec.normalize();\n\n};\n\n\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getTangent( t );\n\n};\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().subSelf(this.v1);\n\tpoint.multiplyScalar( t ).addSelf( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().subSelf(this.v1);\n\n\treturn tangent.normalize();\n\n};\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\n\n\t// returns unit vector\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = (points == undefined) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar v = new THREE.Vector2();\n\tvar c = [];\n\tvar points = this.points, point, intPoint, weight;\n\tpoint = ( points.length - 1 ) * t;\n\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\n\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\n\treturn v;\n\n};\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\taStartAngle, aEndAngle,\n\t\t\t\t\t\t\taClockwise ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( !this.aClockwise ) {\n\n\t\tt = 1 - t;\n\n\t}\n\n\tvar angle = this.aStartAngle + t * deltaAngle;\n\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Curve.Utils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\n\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\t},\n\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\tvar h01 = -6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar r = new THREE.Vector3();\n\n\n\t\tr.sub( this.v2, this.v1 ); // diff\n\t\tr.multiplyScalar( t );\n\t\tr.addSelf( this.v1 );\n\n\t\treturn r;\n\n\t}\n\n);\n\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n\n\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n\n\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar v = new THREE.Vector3();\n\t\tvar c = [];\n\t\tvar points = this.points, point, intPoint, weight;\n\t\tpoint = ( points.length - 1 ) * t;\n\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n\t\tvar pt0 = points[ c[0] ],\n\t\t\tpt1 = points[ c[1] ],\n\t\t\tpt2 = points[ c[2] ],\n\t\t\tpt3 = points[ c[3] ];\n\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n\n\t\treturn v;\n\n\t}\n\n);\n\n\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\n// \t\tvar v = new THREE.Vector3();\n// \t\tvar c = [];\n// \t\tvar points = this.points, point, intPoint, weight;\n// \t\tpoint = ( points.length - 1 ) * t;\n\n// \t\tintPoint = Math.floor( point );\n// \t\tweight = point - intPoint;\n\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n// \t\tc[ 1 ] = intPoint;\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n// \t\tvar pt0 = points[ c[0] ],\n// \t\t\tpt1 = points[ c[1] ],\n// \t\t\tpt2 = points[ c[2] ],\n// \t\t\tpt3 = points[ c[3] ];\n\n// \t// t = weight;\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n\n// \treturn v;\n\n// }\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n    function ( t ) {\n\n        var v = new THREE.Vector3();\n        var c = [];\n        var points = this.points, point, intPoint, weight;\n        point = ( points.length - 0 ) * t;\n            // This needs to be from 0-length +1\n\n        intPoint = Math.floor( point );\n        weight = point - intPoint;\n\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\n        c[ 1 ] = ( intPoint ) % points.length;\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\n\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\n\n        return v;\n\n    }\n\n);\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\tthis.bends = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n};\n\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CurvePath.prototype.add = function ( curve ) {\n\n\tthis.curves.push( curve );\n\n};\n\nTHREE.CurvePath.prototype.checkConnection = function() {\n\t// TODO\n\t// If the ending of curve is not connected to the starting\n\t// or the next curve, then, this is not a real path\n};\n\nTHREE.CurvePath.prototype.closePath = function() {\n\t// TODO Test\n\t// and verify for vector3 (needs to implement equals)\n\t// Add a line curve if start and end of lines are not connected\n\tvar startPoint = this.curves[0].getPoint(0);\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\n\n\tif (!startPoint.equals(endPoint)) {\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\n\t}\n\n};\n\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\nTHREE.CurvePath.prototype.getPoint = function( t ) {\n\n\tvar d = t * this.getLength();\n\tvar curveLengths = this.getCurveLengths();\n\tvar i = 0, diff, curve;\n\n\t// To think about boundaries points.\n\n\twhile ( i < curveLengths.length ) {\n\n\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\tdiff = curveLengths[ i ] - d;\n\t\t\tcurve = this.curves[ i ];\n\n\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\treturn curve.getPointAt( u );\n\n\t\t\tbreak;\n\t\t}\n\n\t\ti ++;\n\n\t}\n\n\treturn null;\n\n\t// loop where sum != 0, sum > d , sum+1 <d\n\n};\n\n/*\nTHREE.CurvePath.prototype.getTangent = function( t ) {\n};*/\n\n\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\nTHREE.CurvePath.prototype.getLength = function() {\n\n\tvar lens = this.getCurveLengths();\n\treturn lens[ lens.length - 1 ];\n\n};\n\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\nTHREE.CurvePath.prototype.getCurveLengths = function() {\n\n\t// We use cache values if curves and cache array are same length\n\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\n\n\t\treturn this.cacheLengths;\n\n\t};\n\n\t// Get length of subsurve\n\t// Push sums into cached array\n\n\tvar lengths = [], sums = 0;\n\tvar i, il = this.curves.length;\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tsums += this.curves[ i ].getLength();\n\t\tlengths.push( sums );\n\n\t}\n\n\tthis.cacheLengths = lengths;\n\n\treturn lengths;\n\n};\n\n\n\n// Returns min and max coordinates, as well as centroid\n\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n\n\tvar points = this.getPoints();\n\n\tvar maxX, maxY, maxZ;\n\tvar minX, minY, minZ;\n\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\n\tminX = minY = Number.POSITIVE_INFINITY;\n\n\tvar p, i, il, sum;\n\n\tvar v3 = points[0] instanceof THREE.Vector3;\n\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\n\n\t\tp = points[ i ];\n\n\t\tif ( p.x > maxX ) maxX = p.x;\n\t\telse if ( p.x < minX ) minX = p.x;\n\n\t\tif ( p.y > maxY ) maxY = p.y;\n\t\telse if ( p.y < minY ) minY = p.y;\n\n\t\tif (v3) {\n\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\n\n\t\t}\n\n\t\tsum.addSelf( p );\n\n\t}\n\n\tvar ret = {\n\n\t\tminX: minX,\n\t\tminY: minY,\n\t\tmaxX: maxX,\n\t\tmaxY: maxY,\n\t\tcentroid: sum.divideScalar( il )\n\n\t};\n\n\tif (v3) {\n\n\t\tret.maxZ = maxZ;\n\t\tret.minZ = minZ;\n\n\t}\n\n\treturn ret;\n\n};\n\n/**************************************************************\n *\tCreate Geometries Helpers\n **************************************************************/\n\n/// Generate geometry from path points (for Line or ParticleSystem objects)\n\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\n// Generate geometry from equidistance sampling along the path\n\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getSpacedPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < points.length; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\n\n\t}\n\n\treturn geometry;\n\n};\n\n\n/**************************************************************\n *\tBend / Wrap Helper Methods\n **************************************************************/\n\n// Wrap path / Bend modifiers?\n\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\n\n\tthis.bends.push( bendpath );\n\n};\n\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getSpacedPoints( segments );\n\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\n// This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\n\n\tvar bounds = this.getBoundingBox();\n\n\tvar i, il, p, oldX, oldY, xNorm;\n\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\n\n\t\tp = oldPts[ i ];\n\n\t\toldX = p.x;\n\t\toldY = p.y;\n\n\t\txNorm = oldX / bounds.maxX;\n\n\t\t// If using actual distance, for length > path, requires line extrusions\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\n\n\t\t// check for out of bounds?\n\n\t\tvar pathPt = path.getPoint( xNorm );\n\t\tvar normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );\n\n\t\tp.x = pathPt.x + normal.x;\n\t\tp.y = pathPt.y + normal.y;\n\n\t}\n\n\treturn oldPts;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Gyroscope = function () {\n\n\tTHREE.Object3D.call( this );\n\n};\n\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\n\n\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t// update matrixWorld\n\n\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.matrixWorld.multiply( this.parent.matrixWorld, this.matrix );\n\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );\n\t\t\tthis.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );\n\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );\n\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t}\n\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tforce = true;\n\n\t}\n\n\t// update children\n\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t}\n\n};\n\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call(this);\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\n\nTHREE.PathActions = {\n\n\tMOVE_TO: 'moveTo',\n\tLINE_TO: 'lineTo',\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\n\tELLIPSE: 'ellipse'\n};\n\n// TODO Clean up PATH API\n\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\n\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\n\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\n\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\n\n\t};\n\n};\n\n// startPath() endPath()?\n\nTHREE.Path.prototype.moveTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.lineTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\n                                               aCP2x, aCP2y,\n                                               aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n//---\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\tArray.prototype.push.apply( npts, pts );\n\n\tvar curve = new THREE.SplineCurve( npts );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\n\n};\n\n// FUTURE: Change the API or follow canvas API?\n\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absarc(aX + x0, aY + y0, aRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n };\n\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\tthis.curves.push( curve );\n\n\tvar lastPoint = curve.getPoint(aClockwise ? 1 : 0);\n\targs.push(lastPoint.x);\n\targs.push(lastPoint.y);\n\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\n\n };\n\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\n\n\tif ( ! divisions ) divisions = 40;\n\n\tvar points = [];\n\n\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t}\n\n\t// if ( closedPath ) {\n\t//\n\t// \tpoints.push( points[ 0 ] );\n\t//\n\t// }\n\n\treturn points;\n\n};\n\n/* Return an array of vectors based on contour of the path */\n\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\n\n\tif (this.useSpacedPoints) {\n\t\tconsole.log('tata');\n\t\treturn this.getSpacedPoints( divisions, closedPath );\n\t}\n\n\tdivisions = divisions || 12;\n\n\tvar points = [];\n\n\tvar i, il, item, action, args;\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\tlaste, j,\n\t\tt, tx, ty;\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\taction = item.action;\n\t\targs = item.args;\n\n\t\tswitch( action ) {\n\n\t\tcase THREE.PathActions.MOVE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.LINE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\n\n\t\t\tcpx  = args[ 2 ];\n\t\t\tcpy  = args[ 3 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t  \t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\n\n\t\t\tcpx  = args[ 4 ];\n\t\t\tcpy  = args[ 5 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tcpx2 = args[ 2 ];\n\t\t\tcpy2 = args[ 3 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.CSPLINE_THRU:\n\n\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\tvar spts = [ last ];\n\n\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\n\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.ARC:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\taRadius = args[ 2 ],\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\taClockwise = !!args[ 5 ];\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\n\t\tcase THREE.PathActions.ELLIPSE:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\txRadius = args[ 2 ],\n\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\taClockwise = !!args[ 6 ];\n\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\n\t\t} // end switch\n\n\t}\n\n\n\n\t// Normalize to remove the closing point by default.\n\tvar lastPoint = points[ points.length - 1];\n\tvar EPSILON = 0.0000000001;\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\n             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\n\t\tpoints.splice( points.length - 1, 1);\n\tif ( closedPath ) {\n\n\t\tpoints.push( points[ 0 ] );\n\n\t}\n\n\treturn points;\n\n};\n\n// Breaks path into shapes\n\nTHREE.Path.prototype.toShapes = function() {\n\n\tvar i, il, item, action, args;\n\n\tvar subPaths = [], lastPath = new THREE.Path();\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\targs = item.args;\n\t\taction = item.action;\n\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\n\n\t\t\tif ( lastPath.actions.length != 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t}\n\n\t\t}\n\n\t\tlastPath[ action ].apply( lastPath, args );\n\n\t}\n\n\tif ( lastPath.actions.length != 0 ) {\n\n\t\tsubPaths.push( lastPath );\n\n\t}\n\n\t// console.log(subPaths);\n\n\tif ( subPaths.length == 0 ) return [];\n\n\tvar tmpPath, tmpShape, shapes = [];\n\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\n\t// console.log(\"Holes first\", holesFirst);\n\n\tif ( subPaths.length == 1) {\n\t\ttmpPath = subPaths[0];\n\t\ttmpShape = new THREE.Shape();\n\t\ttmpShape.actions = tmpPath.actions;\n\t\ttmpShape.curves = tmpPath.curves;\n\t\tshapes.push( tmpShape );\n\t\treturn shapes;\n\t};\n\n\tif ( holesFirst ) {\n\n\t\ttmpShape = new THREE.Shape();\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\n\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpShape = new THREE.Shape();\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// Shapes first\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\n\n\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\n\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tshapes.push( tmpShape );\n\n\t}\n\n\t//console.log(\"shape\", shapes);\n\n\treturn shapes;\n\n};\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function ( ) {\n\n\tTHREE.Path.apply( this, arguments );\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\n\n// Convenience method to return ExtrudeGeometry\n\nTHREE.Shape.prototype.extrude = function ( options ) {\n\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\n\treturn extruded;\n\n};\n\n// Convenience method to return ShapeGeometry\n\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\n\n\tvar geometry = new THREE.ShapeGeometry( this, options );\n\treturn geometry;\n\n};\n\n// Get points of holes\n\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n// Get points of holes (spaced by regular distance)\n\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n\n// Get points of shape and holes (keypoints based on segments parameter)\n\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedPoints( divisions ),\n\t\tholes: this.getPointsHoles( divisions )\n\n\t};\n\n};\n\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\n\n\tif (this.useSpacedPoints) {\n\t\treturn this.extractAllSpacedPoints(divisions);\n\t}\n\n\treturn this.extractAllPoints(divisions);\n\n};\n\n//\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n\n// Get points of shape and holes (spaced by regular distance)\n\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\n\t\tholes: this.getSpacedPointsHoles( divisions )\n\n\t};\n\n};\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Shape.Utils = {\n\n\t/*\n\t\tcontour - array of vector2 for contour\n\t\tholes   - array of array of vector2\n\t*/\n\n\tremoveHoles: function ( contour, holes ) {\n\n\t\tvar shape = contour.concat(); // work on this shape\n\t\tvar allpoints = shape.concat();\n\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\n\n\n\t\tvar prevShapeVert, nextShapeVert,\n\t\t\tprevHoleVert, nextHoleVert,\n\t\t\tholeIndex, shapeIndex,\n\t\t\tshapeId, shapeGroup,\n\t\t\th, h2,\n\t\t\thole, shortest, d,\n\t\t\tp, pts1, pts2,\n\t\t\ttmpShape1, tmpShape2,\n\t\t\ttmpHole1, tmpHole2,\n\t\t\tverts = [];\n\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\n\n\t\t\thole = holes[ h ];\n\n\t\t\t/*\n\t\t\tshapeholes[ h ].concat(); // preserves original\n\t\t\tholes.push( hole );\n\t\t\t*/\n\n\t\t\tArray.prototype.push.apply( allpoints, hole );\n\n\t\t\tshortest = Number.POSITIVE_INFINITY;\n\n\n\t\t\t// Find the shortest pair of pts between shape and hole\n\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\n\t\t\t// since running square roots operations are reduced.\n\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\tpts1 = hole[ h2 ];\n\t\t\t\tvar dist = [];\n\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\n\n\t\t\t\t\tpts2 = shape[ p ];\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\n\t\t\t\t\tdist.push( d );\n\n\t\t\t\t\tif ( d < shortest ) {\n\n\t\t\t\t\t\tshortest = d;\n\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\tshapeIndex = p;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shortest\", shortest, dist);\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tvar areaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tvar areabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\n\n\t\t\tvar shapeOffset = 1;\n\t\t\tvar holeOffset = -1;\n\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n\t\t\tshapeIndex += shapeOffset;\n\t\t\tholeIndex += holeOffset;\n\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\tshapeIndex %= shape.length;\n\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\tholeIndex %= hole.length;\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tareaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tareabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\n\n\t\t\t\t// In case areas are not correct.\n\t\t\t\t//console.log(\"USE THIS\");\n\n\t\t\t\tshapeIndex = oldShapeIndex;\n\t\t\t\tholeIndex = oldHoleIndex ;\n\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\t\tshapeIndex %= shape.length;\n\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\t\tholeIndex %= hole.length;\n\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log(\"USE THAT \")\n\n\t\t\t}\n\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\n\n\t\t\t// Should check orders here again?\n\n\t\t\tvar trianglea = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar triangleb = [\n\n\t\t\t\thole[ holeIndex ] ,\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tverts.push( trianglea );\n\t\t\tverts.push( triangleb );\n\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tshape:shape, \t\t/* shape with no holes */\n\t\t\tisolatedPts: verts, /* isolated faces */\n\t\t\tallpoints: allpoints\n\n\t\t}\n\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\n\n\t\tvar shape = shapeWithoutHoles.shape,\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\n\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {},\n\t\t\tisolatedPointsMap = {};\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.log( \"Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check isolated points vertices against all points map\n\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\n\n\t\t\tface = isolatedPts[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat( isolatedPts );\n\n\t}, // end triangulate shapes\n\n\t/*\n\ttriangulate2 : function( pts, holes ) {\n\n\t\t// For use with Poly2Tri.js\n\n\t\tvar allpts = pts.concat();\n\t\tvar shape = [];\n\t\tfor (var p in pts) {\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\t\t}\n\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\n\t\tfor (var h in holes) {\n\t\t\tvar aHole = holes[h];\n\t\t\tvar newHole = []\n\t\t\tfor (i in aHole) {\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\t\t\t\tallpts.push(aHole[i]);\n\t\t\t}\n\t\t\tswctx.AddHole(newHole);\n\t\t}\n\n\t\tvar find;\n\t\tvar findIndexForPt = function (pt) {\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\t\t\tvar p;\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\t\t\t\tif (allpts[p].equals(find)) return p;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\t// triangulate\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\n\t\tvar triangles =  swctx.GetTriangles();\n\t\tvar tr ;\n\t\tvar facesPts = [];\n\t\tfor (var t in triangles) {\n\t\t\ttr =  triangles[t];\n\t\t\tfacesPts.push([\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\t\t\t\t\t]);\n\t\t}\n\n\n\t//\tconsole.log(facesPts);\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\n\t\t// Returns array of faces with 3 element each\n\treturn facesPts;\n\t},\n*/\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * p;\n\n\t},\n\n\tb2p1: function ( t, p ) {\n\n\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t},\n\n\tb2p2: function ( t, p ) {\n\n\t\treturn t * t * p;\n\n\t},\n\n\tb2: function ( t, p0, p1, p2 ) {\n\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\n\n\t},\n\n\t// Cubic Bezier Functions\n\n\tb3p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * k * p;\n\n\t},\n\n\tb3p1: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\n\t},\n\n\tb3p2: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * t * t * p;\n\n\t},\n\n\tb3p3: function ( t, p ) {\n\n\t\treturn t * t * t * p;\n\n\t},\n\n\tb3: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\n\n\t}\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.AnimationHandler = (function() {\n\n\tvar playing = [];\n\tvar library = {};\n\tvar that    = {};\n\n\n\t//--- update ---\n\n\tthat.update = function( deltaTimeMS ) {\n\n\t\tfor( var i = 0; i < playing.length; i ++ )\n\t\t\tplaying[ i ].update( deltaTimeMS );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.addToUpdate = function( animation ) {\n\n\t\tif ( playing.indexOf( animation ) === -1 )\n\t\t\tplaying.push( animation );\n\n\t};\n\n\n\t//--- remove ---\n\n\tthat.removeFromUpdate = function( animation ) {\n\n\t\tvar index = playing.indexOf( animation );\n\n\t\tif( index !== -1 )\n\t\t\tplaying.splice( index, 1 );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.add = function( data ) {\n\n\t\tif ( library[ data.name ] !== undefined )\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\n\n\t\tlibrary[ data.name ] = data;\n\t\tinitData( data );\n\n\t};\n\n\n\t//--- get ---\n\n\tthat.get = function( name ) {\n\n\t\tif ( typeof name === \"string\" ) {\n\n\t\t\tif ( library[ name ] ) {\n\n\t\t\t\treturn library[ name ];\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// todo: add simple tween library\n\n\t\t}\n\n\t};\n\n\t//--- parse ---\n\n\tthat.parse = function( root ) {\n\n\t\t// setup hierarchy\n\n\t\tvar hierarchy = [];\n\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\n\n\t\t\t\thierarchy.push( root.bones[ b ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparseRecurseHierarchy( root, hierarchy );\n\n\t\t}\n\n\t\treturn hierarchy;\n\n\t};\n\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\n\n\t\thierarchy.push( root );\n\n\t\tfor( var c = 0; c < root.children.length; c++ )\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\n\t}\n\n\n\t//--- init data ---\n\n\tvar initData = function( data ) {\n\n\t\tif( data.initialized === true )\n\t\t\treturn;\n\n\n\t\t// loop through all keys\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\n\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t// remove minus times\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\n\n\n\t\t\t\t// create quaternions\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// prepare morph target keys\n\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\n\t\t\t\t// get all used\n\n\t\t\t\tvar usedMorphTargets = {};\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\n\n\t\t\t\t// set all used on all frames\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tvar influences = {};\n\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// remove all keys that are on the same time\n\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\t\t\t\t\tk --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// set index\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// JIT\n\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\n\n\t\tdata.JIT = {};\n\t\tdata.JIT.hierarchy = [];\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\n\n\n\t\t// done\n\n\t\tdata.initialized = true;\n\n\t};\n\n\n\t// interpolation types\n\n\tthat.LINEAR = 0;\n\tthat.CATMULLROM = 1;\n\tthat.CATMULLROM_FORWARD = 2;\n\n\treturn that;\n\n}());\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Animation = function ( root, name, interpolationType ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( name );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\n\tthis.currentTime = 0;\n\tthis.timeScale = 1;\n\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n\n\tthis.points = [];\n\tthis.target = new THREE.Vector3();\n\n};\n\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\n\n\tif ( this.isPlaying === false ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject;\n\n\t\tfor ( h = 0; h < hl; h ++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\n\t\t\tif ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\tobject.useQuaternion = true;\n\n\t\t\t}\n\n\t\t\tobject.matrixAutoUpdate = true;\n\n\t\t\tif ( object.animationCache === undefined ) {\n\n\t\t\t\tobject.animationCache = {};\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar prevKey = object.animationCache.prevKey;\n\t\t\tvar nextKey = object.animationCache.nextKey;\n\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\n\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.pause = function() {\n\n\tif ( this.isPaused === true ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\nTHREE.Animation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\n\n\t// early out\n\n\tif ( this.isPlaying === false ) return;\n\n\n\t// vars\n\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\n\tvar type;\n\tvar scale;\n\tvar vector;\n\tvar prevXYZ, nextXYZ;\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar animationCache;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar currentPoint, forwardPoint, angle;\n\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tanimationCache = object.animationCache;\n\n\t\t// loop through pos/rot/scl\n\n\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t// get keys\n\n\t\t\ttype    = types[ t ];\n\t\t\tprevKey = animationCache.prevKey[ type ];\n\t\t\tnextKey = animationCache.nextKey[ type ];\n\n\t\t\t// switch keys?\n\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t// did we loop?\n\n\t\t\t\tif ( currentTime < unloopedCurrentTime ) {\n\n\t\t\t\t\tif ( this.loop ) {\n\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\t\t\twhile( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t} while( nextKey.time < currentTime )\n\n\t\t\t\t}\n\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t}\n\n\n\t\t\tobject.matrixAutoUpdate = true;\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\t\t\tprevXYZ = prevKey[ type ];\n\t\t\tnextXYZ = nextKey[ type ];\n\n\n\t\t\t// check scale error\n\n\t\t\tif ( scale < 0 || scale > 1 ) {\n\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\n\t\t\t\tscale = scale < 0 ? 0 : 1;\n\n\t\t\t}\n\n\t\t\t// interpolate\n\n\t\t\tif ( type === \"pos\" ) {\n\n\t\t\t\tvector = object.position;\n\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\n\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\n\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\n\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\t\t\t\t\t\tthis.target.subSelf( vector );\n\t\t\t\t\t\tthis.target.y = 0;\n\t\t\t\t\t\tthis.target.normalize();\n\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"rot\" ) {\n\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\n\n\t\t\t} else if ( type === \"scl\" ) {\n\n\t\t\t\tvector = object.scale;\n\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Catmull-Rom spline\n\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\n\n\tvar c = [], v3 = [],\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tpoint = ( points.length - 1 ) * scale;\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\n\tpa = points[ c[ 0 ] ];\n\tpb = points[ c[ 1 ] ];\n\tpc = points[ c[ 2 ] ];\n\tpd = points[ c[ 3 ] ];\n\n\tw2 = weight * weight;\n\tw3 = weight * w2;\n\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\n\treturn v3;\n\n};\n\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n};\n\n\n\n// Get next key with\n\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\n\t} else {\n\n\t\tkey = key % keys.length;\n\n\t}\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key > 0 ? key : 0;\n\n\t} else {\n\n\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t}\n\n\n\tfor ( ; key >= 0; key -- ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */\n\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\tthis.currentTime = 0;\n\tthis.timeScale = 0.001;\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\n\n\t// initialize to first keyframes\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\tobj = this.hierarchy[h];\n\n\t\tif ( keys.length && sids ) {\n\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\n\t\t\t\tif ( next ) {\n\n\t\t\t\t\tnext.apply( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n};\n\n// Play\n\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\n\n\tif( !this.isPlaying ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\t\tthis.startTimeMs = startTimeMS;\n\t\tthis.startTime = 10000000;\n\t\tthis.endTime = -this.startTime;\n\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject,\n\t\t\tnode;\n\n\t\tfor ( h = 0; h < hl; h++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\t\t\tnode = this.data.hierarchy[ h ];\n\t\t\tobject.useQuaternion = true;\n\n\t\t\tif ( node.animationCache === undefined ) {\n\n\t\t\t\tnode.animationCache = {};\n\t\t\t\tnode.animationCache.prevKey = null;\n\t\t\t\tnode.animationCache.nextKey = null;\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar keys = this.data.hierarchy[h].keys;\n\n\t\t\tif (keys.length) {\n\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\n\n// Pause\n\nTHREE.KeyFrameAnimation.prototype.pause = function() {\n\n\tif( this.isPaused ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\n// Stop\n\nTHREE.KeyFrameAnimation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\n\t// reset JIT matrix and remove cache\n\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\n\n        var obj = this.hierarchy[ h ];\n\t\tvar node = this.data.hierarchy[ h ];\n\n\t\tif ( node.animationCache !== undefined ) {\n\n\t\t\tvar original = node.animationCache.originalMatrix;\n\n\t\t\tif( obj instanceof THREE.Bone ) {\n\n\t\t\t\toriginal.copy( obj.skinMatrix );\n\t\t\t\tobj.skinMatrix = original;\n\n\t\t\t} else {\n\n\t\t\t\toriginal.copy( obj.matrix );\n\t\t\t\tobj.matrix = original;\n\n\t\t\t}\n\n\t\t\tdelete node.animationCache;\n\n\t\t}\n\n\t}\n\n};\n\n\n// Update\n\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\n\n\t// early out\n\n\tif( !this.isPlaying ) return;\n\n\n\t// vars\n\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar node;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar looped;\n\n\n\t// update\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\n\n\t// if looped around, the current time should be based on the startTime\n\tif ( currentTime < this.startTimeMs ) {\n\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\n\n\t}\n\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\n\n\tif ( looped && !this.loop ) {\n\n\t\t// Set the animation to the last keyframes and stop\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\t\tend = keys.length-1,\n\t\t\t\tobj = this.hierarchy[h];\n\n\t\t\tif ( keys.length ) {\n\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\n\n\t\t\t\t\tif ( prev ) {\n\t\t\t\t\t\tprev.apply( sid );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.stop();\n\t\treturn;\n\n\t}\n\n\t// check pre-infinity\n\tif ( currentTime < this.startTime ) {\n\n\t\treturn;\n\n\t}\n\n\t// update\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tnode = this.data.hierarchy[ h ];\n\n\t\tvar keys = node.keys,\n\t\t\tanimationCache = node.animationCache;\n\n\t\t// use JIT?\n\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\n\n\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t// use interpolation\n\n\t\t} else if ( keys.length ) {\n\n\t\t\t// make sure so original matrix and not JIT matrix is set\n\n\t\t\tif ( this.JITCompile && animationCache ) {\n\n\t\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprevKey = animationCache.prevKey;\n\t\t\tnextKey = animationCache.nextKey;\n\n\t\t\tif ( prevKey && nextKey ) {\n\n\t\t\t\t// switch keys?\n\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t\t// did we loop?\n\n\t\t\t\t\tif ( looped && this.loop ) {\n\n\t\t\t\t\t\tprevKey = keys[ 0 ];\n\t\t\t\t\t\tnextKey = keys[ 1 ];\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( !looped ) {\n\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationCache.prevKey = prevKey;\n\t\t\t\t\tanimationCache.nextKey = nextKey;\n\n\t\t\t\t}\n                if(nextKey.time >= currentTime)\n                    prevKey.interpolate( nextKey, currentTime );\n                else\n                    prevKey.interpolate( nextKey, nextKey.time);\n\n\t\t\t}\n\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// update JIT?\n\n\tif ( this.JITCompile ) {\n\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\n\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\n\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\n\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Get next key with\n\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key % keys.length;\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key >= 0 ? key : key + keys.length;\n\n\tfor ( ; key >= 0; key-- ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ keys.length - 1 ];\n\n};\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, -1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, -1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, -1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, -1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, -1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\n\tthis.add( cameraNZ );\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\n\n\t\trenderTarget.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */\n\n\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov;\n\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\n\n\tthis.zoom = 1;\n\n\tthis.toPerspective();\n\n\tvar aspect = width/height;\n\n};\n\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n\n\t// Switches to the Perspective Camera\n\n\tthis.near = this.cameraP.near;\n\tthis.far = this.cameraP.far;\n\n\tthis.cameraP.fov =  this.fov / this.zoom ;\n\n\tthis.cameraP.updateProjectionMatrix();\n\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\n\tthis.inPerspectiveMode = true;\n\tthis.inOrthographicMode = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\n\n\t// Switches to the Orthographic camera estimating viewport from Perspective\n\n\tvar fov = this.fov;\n\tvar aspect = this.cameraP.aspect;\n\tvar near = this.cameraP.near;\n\tvar far = this.cameraP.far;\n\n\t// The size that we set is the mid plane of the viewing frustum\n\n\tvar hyperfocus = ( near + far ) / 2;\n\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\n\tvar planeHeight = 2 * halfHeight;\n\tvar planeWidth = planeHeight * aspect;\n\tvar halfWidth = planeWidth / 2;\n\n\thalfHeight /= this.zoom;\n\thalfWidth /= this.zoom;\n\n\tthis.cameraO.left = -halfWidth;\n\tthis.cameraO.right = halfWidth;\n\tthis.cameraO.top = halfHeight;\n\tthis.cameraO.bottom = -halfHeight;\n\n\t// this.cameraO.left = -farHalfWidth;\n\t// this.cameraO.right = farHalfWidth;\n\t// this.cameraO.top = farHalfHeight;\n\t// this.cameraO.bottom = -farHalfHeight;\n\n\t// this.cameraO.left = this.left / this.zoom;\n\t// this.cameraO.right = this.right / this.zoom;\n\t// this.cameraO.top = this.top / this.zoom;\n\t// this.cameraO.bottom = this.bottom / this.zoom;\n\n\tthis.cameraO.updateProjectionMatrix();\n\n\tthis.near = this.cameraO.near;\n\tthis.far = this.cameraO.far;\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\n\tthis.inPerspectiveMode = false;\n\tthis.inOrthographicMode = true;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\n\tthis.cameraP.aspect = width / height;\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\n\n\tthis.fov = fov;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n// For mantaining similar API with PerspectiveCamera\n\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toPerspective();\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (fullframe) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tvar fov = 2 * Math.atan( frameHeight / ( focalLength * 2 ) ) * ( 180 / Math.PI );\n\n\tthis.setFov( fov );\n\n\treturn fov;\n};\n\n\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\n\tthis.zoom = zoom;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n\t// should we be modifing the matrix instead?\n\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBackView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = - Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toRightView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toTopView = function() {\n\n\tthis.rotation.x = - Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n\n\tthis.rotation.x = Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n    THREE.Geometry.call( this );\n\n    radius = radius || 50;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n    segments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n    var i, uvs = [],\n    center = new THREE.Vector3(), centerUV = new THREE.UV( 0.5, 0.5 );\n\n    this.vertices.push(center);\n    uvs.push( centerUV );\n\n    for ( i = 0; i <= segments; i ++ ) {\n\n        var vertex = new THREE.Vector3();\n\n        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );\n        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );\n\n        this.vertices.push( vertex );\n        uvs.push( new THREE.UV( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );\n\n    }\n\n    var n = new THREE.Vector3( 0, 0, -1 );\n\n    for ( i = 1; i <= segments; i ++ ) {\n\n        var v1 = i;\n        var v2 = i + 1 ;\n        var v3 = 0;\n\n        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\n        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );\n\n    }\n\n    this.computeCentroids();\n    this.computeFaceNormals();\n\n    this.boundingSphere = { radius: radius };\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.CubeGeometry = function ( width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth, materials, sides ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this,\n\twidth_half = width / 2,\n\theight_half = height / 2,\n\tdepth_half = depth / 2;\n\n\tvar mpx, mpy, mpz, mnx, mny, mnz;\n\n\tif ( materials !== undefined ) {\n\n\t\tif ( materials instanceof Array ) {\n\n\t\t\tthis.materials = materials;\n\n\t\t} else {\n\n\t\t\tthis.materials = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis.materials.push( materials );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmpx = 0; mnx = 1; mpy = 2; mny = 3; mpz = 4; mnz = 5;\n\n\t} else {\n\n\t\tthis.materials = [];\n\n\t}\n\n\tthis.sides = { px: true, nx: true, py: true, ny: true, pz: true, nz: true };\n\n\tif ( sides != undefined ) {\n\n\t\tfor ( var s in sides ) {\n\n\t\t\tif ( this.sides[ s ] !== undefined ) {\n\n\t\t\t\tthis.sides[ s ] = sides[ s ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.sides.px && buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, mpx ); // px\n\tthis.sides.nx && buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, mnx ); // nx\n\tthis.sides.py && buildPlane( 'x', 'z',   1,   1, width, depth, height_half, mpy ); // py\n\tthis.sides.ny && buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, mny ); // ny\n\tthis.sides.pz && buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, mpz ); // pz\n\tthis.sides.nz && buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, mnz ); // nz\n\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, material ) {\n\n\t\tvar w, ix, iy,\n\t\tgridX = segmentsWidth || 1,\n\t\tgridY = segmentsHeight || 1,\n\t\twidth_half = width / 2,\n\t\theight_half = height / 2,\n\t\toffset = scope.vertices.length;\n\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\n\n\t\t\tw = 'z';\n\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\n\n\t\t\tw = 'y';\n\t\t\tgridY = segmentsDepth || 1;\n\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\n\n\t\t\tw = 'x';\n\t\t\tgridX = segmentsDepth || 1;\n\n\t\t}\n\n\t\tvar gridX1 = gridX + 1,\n\t\tgridY1 = gridY + 1,\n\t\tsegment_width = width / gridX,\n\t\tsegment_height = height / gridY,\n\t\tnormal = new THREE.Vector3();\n\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar vector = new THREE.Vector3();\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\n\t\t\t\tvector[ w ] = depth;\n\n\t\t\t\tscope.vertices.push( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tvar face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = material;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\t\t\tnew THREE.UV( ix / gridX, 1 - iy / gridY ),\n\t\t\t\t\t\t\tnew THREE.UV( ix / gridX, 1 - ( iy + 1 ) / gridY ),\n\t\t\t\t\t\t\tnew THREE.UV( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),\n\t\t\t\t\t\t\tnew THREE.UV( ( ix + 1 ) / gridX, 1 - iy / gridY )\n\t\t\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.mergeVertices();\n\n};\n\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tvar heightHalf = height / 2;\n\tvar segmentsX = radiusSegments || 8;\n\tvar segmentsY = heightSegments || 1;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= segmentsY; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tvar v = y / segmentsY;\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\tfor ( x = 0; x <= segmentsX; x ++ ) {\n\n\t\t\tvar u = x / segmentsX;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\n\t\t\tvertex.y = - v * height + heightHalf;\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.UV( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\tvar na, nb;\n\n\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\tif ( radiusTop !== 0 ) {\n\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\n\n\t\t} else {\n\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\n\n\t\t}\n\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\n\n\t\tfor ( y = 0; y < segmentsY; y ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x ];\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\n\n\t\t\tvar n1 = na.clone();\n\t\t\tvar n2 = na.clone();\n\t\t\tvar n3 = nb.clone();\n\t\t\tvar n4 = nb.clone();\n\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\n\n\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\n\n\t\t}\n\n\t}\n\n\t// top cap\n\n\tif ( !openEnded && radiusTop > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\t\tvar v1 = vertices[ 0 ][ x ];\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\n\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\n\t\t\tvar uv3 = new THREE.UV( uv2.u, 0 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\t// bottom cap\n\n\tif ( !openEnded && radiusBottom > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = new THREE.UV( uv2.u, 1 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n}\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n *  amount: <int>, // Amount\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  material: <int> // material index for front and back faces\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\tshapes = [];\n\t\treturn;\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\t}\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\tvar material = options.material;\n\tvar extrudeMaterial = options.extrudeMaterial;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar shapebb = this.shapebb;\n\t//shapebb = shape.getBoundingBox();\n\n\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initalization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\tvar bevelPoints = [];\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints();\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( !vec ) console.log( \"die\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).addSelf( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length,\n\t\tcont, clen = contour.length;\n\n\n\t// Find directions for point movement\n\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\n\n\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\n\n\t\t// Algorithm 2\n\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\n\n\t}\n\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\n\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\n\n\t\tif ( anglea > angleb ) {\n\n\t\t\tangleb += Math.PI * 2;\n\n\t\t}\n\n\t\tvar anglec = ( anglea + angleb ) / 2;\n\n\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n\n\t\tvar x = - Math.cos( anglec );\n\t\tvar y = - Math.sin( anglec );\n\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\n\n\t\treturn vec;\n\n\t}\n\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\n\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\n\t\t\tv, w,\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\n\t\t\ts, intersection;\n\n\t\t// good reading for line-line intersection\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\n\n\t\t// define a as vector j->i\n\t\t// define b as vectot k->i\n\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\n\n\t\t// get unit vectors\n\n\t\tv = a.normalize();\n\t\tw = b.normalize();\n\n\t\t// normals from pt i\n\n\t\tv_hat.set( -v.y, v.x );\n\t\tw_hat.set( w.y, -w.x );\n\n\t\t// pts from i\n\n\t\tp.copy( pt_i ).addSelf( v_hat );\n\t\tq.copy( pt_i ).addSelf( w_hat );\n\n\t\tif ( p.equals( q ) ) {\n\n\t\t\t//console.log(\"Warning: lines are straight\");\n\t\t\treturn w_hat.clone();\n\n\t\t}\n\n\t\t// Points from j, k. helps prevents points cross overover most of the time\n\n\t\tp.copy( pt_j ).addSelf( v_hat );\n\t\tq.copy( pt_k ).addSelf( w_hat );\n\n\t\tv_dot_w_hat = v.dot( w_hat );\n\t\tq_sub_p_dot_w_hat = q.subSelf( p ).dot( w_hat );\n\n\t\t// We should not reach these conditions\n\n\t\tif ( v_dot_w_hat === 0 ) {\n\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\n\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\n\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\n\n\t\tif ( s < 0 ) {\n\n\t\t\t// in case of emergecy, revert to algorithm 1.\n\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\n\n\t\t}\n\n\t\tintersection = v.multiplyScalar( s ).addSelf( p );\n\n\t\treturn intersection.subSelf( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\n\n\t}\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tvar pt_i = contour[ i ];\n\t\tvar pt_j = contour[ j ];\n\t\tvar pt_k = contour[ k ];\n\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\n\t\t//bs = bevelSize * t ; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n\n\t\t\t\tv( vert.x, vert.y,  -z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( !extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\n\n\t\t\tposition2.copy( extrudePts[0] ).addSelf(normal).addSelf(binormal);\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[s] ).addSelf( normal ).addSelf( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0 ; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( --i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c, isBottom ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\t// normal, color, material\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\n\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n \t\tscope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );\n\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y;\n\n\t\treturn [\n\t\t\tnew THREE.UV( ax, ay ),\n\t\t\tnew THREE.UV( bx, by ),\n\t\t\tnew THREE.UV( cx, cy )\n\t\t];\n\n\t},\n\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\n\n\t},\n\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\n\t                              contourIndex1, contourIndex2 ) {\n\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\t\t\taz = geometry.vertices[ indexA ].z,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\t\t\tbz = geometry.vertices[ indexB ].z,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y,\n\t\t\tcz = geometry.vertices[ indexC ].z,\n\n\t\t\tdx = geometry.vertices[ indexD ].x,\n\t\t\tdy = geometry.vertices[ indexD ].y,\n\t\t\tdz = geometry.vertices[ indexD ].z;\n\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\n\t\t\treturn [\n\t\t\t\tnew THREE.UV( ax, 1 - az ),\n\t\t\t\tnew THREE.UV( bx, 1 - bz ),\n\t\t\t\tnew THREE.UV( cx, 1 - cz ),\n\t\t\t\tnew THREE.UV( dx, 1 - dz )\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew THREE.UV( ay, 1 - az ),\n\t\t\t\tnew THREE.UV( by, 1 - bz ),\n\t\t\t\tnew THREE.UV( cy, 1 - cz ),\n\t\t\t\tnew THREE.UV( dy, 1 - dz )\n\t\t\t];\n\t\t}\n\t}\n};\n\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\tvar shapebb = this.shapebb;\n\n\t//\n\n\tvar i, l, hole, s;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints();\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tvar contour = vertices;\n\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\tvar cont, clen = contour.length;\n\n\tfor ( i = 0; i < vlen; i++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\n\n\t}\n\n};\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n */\n\nTHREE.LatheGeometry = function ( points, steps, angle ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar _steps = steps || 12;\n\tvar _angle = angle || 2 * Math.PI;\n\n\tvar _newV = [];\n\tvar _matrix = new THREE.Matrix4().makeRotationZ( _angle / _steps );\n\n\tfor ( var j = 0; j < points.length; j ++ ) {\n\n\t\t_newV[ j ] = points[ j ].clone();\n\t\tthis.vertices.push( _newV[ j ] );\n\n\t}\n\n\tvar i, il = _steps + 1;\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tfor ( var j = 0; j < _newV.length; j ++ ) {\n\n\t\t\t_newV[ j ] = _matrix.multiplyVector3( _newV[ j ].clone() );\n\t\t\tthis.vertices.push( _newV[ j ] );\n\n\t\t}\n\n\t}\n\n\tfor ( i = 0; i < _steps; i ++ ) {\n\n\t\tfor ( var k = 0, kl = points.length; k < kl - 1; k ++ ) {\n\n\t\t\tvar a = i * kl + k;\n\t\t\tvar b = ( ( i + 1 ) % il ) * kl + k;\n\t\t\tvar c = ( ( i + 1 ) % il ) * kl + ( k + 1 ) % kl;\n\t\t\tvar d = i * kl + ( k + 1 ) % kl;\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.UV( 1 - i / _steps, k / kl ),\n\t\t\t\tnew THREE.UV( 1 - ( i + 1 ) / _steps, k / kl ),\n\t\t\t\tnew THREE.UV( 1 - ( i + 1 ) / _steps, ( k + 1 ) / kl ),\n\t\t\t\tnew THREE.UV( 1 - i / _steps, ( k + 1 ) / kl )\n\n\t\t\t] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar ix, iz,\n\twidth_half = width / 2,\n\theight_half = height / 2,\n\tgridX = widthSegments || 1,\n\tgridZ = heightSegments || 1,\n\tgridX1 = gridX + 1,\n\tgridZ1 = gridZ + 1,\n\tsegment_width = width / gridX,\n\tsegment_height = height / gridZ,\n\tnormal = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\t\t\tvar y = iz * segment_height - height_half;\n\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\n\n\t\t}\n\n\t}\n\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iz;\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\n\n\t\t\tvar face = new THREE.Face4( a, b, c, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\t\t\t\tnew THREE.UV( ix / gridX, 1 - iz / gridZ ),\n\t\t\t\tnew THREE.UV( ix / gridX, 1 - ( iz + 1 ) / gridZ ),\n\t\t\t\tnew THREE.UV( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),\n\t\t\t\tnew THREE.UV( ( ix + 1 ) / gridX, 1 - iz / gridZ )\n\t\t\t] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradius = radius || 50;\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar segmentsX = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\tvar segmentsY = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= segmentsY; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tfor ( x = 0; x <= segmentsX; x ++ ) {\n\n\t\t\tvar u = x / segmentsX;\n\t\t\tvar v = y / segmentsY;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.UV( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tfor ( y = 0; y < segmentsY; y ++ ) {\n\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\n\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) == radius ) {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\n\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) ==  radius ) {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = { radius: radius };\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For creating 3D text geometry in three.js\n *\n * Text = 3D Text\n *\n * parameters = {\n *  size: \t\t\t<float>, \t// size of the text\n *  height: \t\t<float>, \t// thickness to extrude text\n *  curveSegments: \t<int>,\t\t// number of points on the curves\n *\n *  font: \t\t\t<string>,\t\t// font name\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n *\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n *  }\n *\n */\n\n/*\tUsage Examples\n\n\t// TextGeometry wrapper\n\n\tvar text3d = new TextGeometry( text, options );\n\n\t// Complete manner\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\n*/\n\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.tubularSegments = tubularSegments || 6;\n\tthis.arc = arc || Math.PI * 2;\n\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\n\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / this.tubularSegments * this.arc;\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\n\n\t\t\tcenter.x = this.radius * Math.cos( u );\n\t\t\tcenter.y = this.radius * Math.sin( u );\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = this.tube * Math.sin( v );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tuvs.push( new THREE.UV( i / this.tubularSegments, j / this.radialSegments ) );\n\t\t\tnormals.push( vertex.clone().subSelf( center ).normalize() );\n\n\t\t}\n\t}\n\n\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\n\n\t\t\tvar face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );\n\t\t\tface.normal.addSelf( normals[ a ] );\n\t\t\tface.normal.addSelf( normals[ b ] );\n\t\t\tface.normal.addSelf( normals[ c ] );\n\t\t\tface.normal.addSelf( normals[ d ] );\n\t\t\tface.normal.normalize();\n\n\t\t\tthis.faces.push( face );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author oosmoxiecode\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 200;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 64;\n\tthis.tubularSegments = tubularSegments || 8;\n\tthis.p = p || 2;\n\tthis.q = q || 3;\n\tthis.heightScale = heightScale || 1;\n\tthis.grid = new Array(this.radialSegments);\n\n\tvar tang = new THREE.Vector3();\n\tvar n = new THREE.Vector3();\n\tvar bitan = new THREE.Vector3();\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\n\t\t\tvar p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );\n\t\t\tvar p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );\n\t\t\tvar cx, cy;\n\n\t\t\ttang.sub( p2, p1 );\n\t\t\tn.add( p2, p1 );\n\n\t\t\tbitan.cross( tang, n );\n\t\t\tn.cross( bitan, tang );\n\t\t\tbitan.normalize();\n\t\t\tn.normalize();\n\n\t\t\tcx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.tube * Math.sin( v );\n\n\t\t\tp1.x += cx * n.x + cy * bitan.x;\n\t\t\tp1.y += cx * n.y + cy * bitan.y;\n\t\t\tp1.z += cx * n.z + cy * bitan.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\n\n\t\t\tvar a = this.grid[ i ][ j ];\n\t\t\tvar b = this.grid[ ip ][ j ];\n\t\t\tvar c = this.grid[ ip ][ jp ];\n\t\t\tvar d = this.grid[ i ][ jp ];\n\n\t\t\tvar uva = new THREE.UV( i / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvb = new THREE.UV( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvc = new THREE.UV( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\t\t\tvar uvd = new THREE.UV( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\tfunction getPos( u, v, in_q, in_p, radius, heightScale ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar cv = Math.cos( v );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = in_q / in_p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.path = path;\n\tthis.segments = segments || 64;\n\tthis.radius = radius || 1;\n\tthis.radiusSegments = radiusSegments || 8;\n\tthis.closed = closed || false;\n\n\tif ( debug ) this.debug = new THREE.Object3D();\n\n\tthis.grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = this.segments + 1,\n\n\t\tx, y, z,\n\t\ttx, ty, tz,\n\t\tu, v,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\n\t// consruct the grid\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tthis.grid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tif ( this.debug ) {\n\n\t\t\tthis.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );\n\t\t\tthis.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );\n\t\t\tthis.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );\n\n\t\t}\n\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\n\n\t\t\tv = j / this.radiusSegments * 2 * Math.PI;\n\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.radius * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < this.segments; i++ ) {\n\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\n\n\t\t\tip = ( closed ) ? (i + 1) % this.segments : i + 1;\n\t\t\tjp = (j + 1) % this.radiusSegments;\n\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = this.grid[ ip ][ j ];\n\t\t\tc = this.grid[ ip ][ jp ];\n\t\t\td = this.grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.UV( i / this.segments, j / this.radiusSegments );\n\t\t\tuvb = new THREE.UV( ( i + 1 ) / this.segments, j / this.radiusSegments );\n\t\t\tuvc = new THREE.UV( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );\n\t\t\tuvd = new THREE.UV( i / this.segments, ( j + 1 ) / this.radiusSegments );\n\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n\n\tvar\n\t\ttangent = new THREE.Vector3(),\n\t\tnormal = new THREE.Vector3(),\n\t\tbinormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tepsilon = 0.0001,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u, v;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].cross( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].cross( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().sub( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().cross( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].cross( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].cross( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\n\tfunction initialNormal3() {\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t}\n\n\t\tvec.cross( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].cross( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].cross( tangents[ 0 ], normals[ 0 ] );\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\tnormals[ i ] = normals[ i-1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\n\n\t\tvec.cross( tangents[ i-1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > epsilon ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );\n\n\t\t\tmat.makeRotationAxis( vec, theta ).multiplyVector3( normals[ i ] );\n\n\t\t}\n\n\t\tbinormals[ i ].cross( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.cross( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\n\n\t\t\ttheta = -theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\t\t// twist a little...\n\t\t\tmat.makeRotationAxis( tangents[ i ], theta * i ).multiplyVector3( normals[ i ] );\n\t\t\tbinormals[ i ].cross( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n};\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\n\n\t}\n\n\tvar midpoints = [], p = this.vertices;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tmake( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );\n\n\t}\n\n\tthis.mergeVertices();\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.UV( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3, detail ) {\n\n\t\tif ( detail < 1 ) {\n\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\t\tface.centroid.addSelf( v1 ).addSelf( v2 ).addSelf( v3 ).divideScalar( 3 );\n\t\t\tface.normal = face.centroid.clone().normalize();\n\t\t\tthat.faces.push( face );\n\n\t\t\tvar azi = azimuth( face.centroid );\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t\t] );\n\n\t\t} else {\n\n\t\t\tdetail -= 1;\n\n\t\t\t// split triangle into 4 smaller triangles\n\n\t\t\tmake( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant\n\t\t\tmake( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant\n\t\t\tmake( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant\n\t\t\tmake( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant\n\n\t\t}\n\n\t}\n\n\tfunction midpoint( v1, v2 ) {\n\n\t\tif ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];\n\t\tif ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];\n\n\t\tvar mid = midpoints[ v1.index ][ v2.index ];\n\n\t\tif ( mid === undefined ) {\n\n\t\t\t// generate mean point and project to surface with prepare()\n\n\t\t\tmidpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(\n\t\t\t\tnew THREE.Vector3().add( v1, v2 ).divideScalar( 2 )\n\t\t\t);\n\t\t}\n\n\t\treturn mid;\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, -vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.u === 1 ) ) uv = new THREE.UV( uv.u - 1, uv.v );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.UV( azimuth / 2 / Math.PI + 0.5, uv.v );\n\t\treturn uv;\n\n\t}\n\n\tthis.computeCentroids();\n\n\tthis.boundingSphere = { radius: radius };\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tuseTris = (useTris === undefined) ? false : useTris;\n\n\tvar i, il, j, p;\n\tvar u, v;\n\n\tvar stackCount = stacks + 1;\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = (i + 1) * sliceCount + j;\n\t\t\td = (i + 1) * sliceCount + j + 1;\n\n\t\t\tuva = new THREE.UV( j / slices, i / stacks );\n\t\t\tuvb = new THREE.UV( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.UV( j / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.UV( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\n\t\t\tif ( useTris ) {\n\n\t\t\t\tfaces.push( new THREE.Face3( a, b, c ) );\n\t\t\t\tfaces.push( new THREE.Face3( b, d, c ) );\n\n\t\t\t\tuvs.push( [ uva, uvb, uvc ] );\n\t\t\t\tuvs.push( [ uvb, uvd, uvc ] );\n\n\t\t\t} else {\n\n\t\t\t\tfaces.push( new THREE.Face4( a, b, d, c ) );\n\t\t\t\tuvs.push( [ uva, uvb, uvd, uvc ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author qiao / https://github.com/qiao\n * @fileoverview This is a convex hull generator using the incremental method.\n * The complexity is O(n^2) where n is the number of vertices.\n * O(nlogn) algorithms do exist, but they are much more complicated.\n *\n * Benchmark:\n *\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\n *\n *  Num Vertices\tTime(ms)\n *\n *     10           1\n *     20           3\n *     30           19\n *     40           48\n *     50           107\n */\n\nTHREE.ConvexGeometry = function( vertices ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ];\n\n\tfor ( var i = 3; i < vertices.length; i++ ) {\n\n\t\taddPoint( i );\n\n\t}\n\n\n\tfunction addPoint( vertexId ) {\n\n\t\tvar vertex = vertices[ vertexId ].clone();\n\n\t\tvar mag = vertex.length();\n\t\tvertex.x += mag * randomOffset();\n\t\tvertex.y += mag * randomOffset();\n\t\tvertex.z += mag * randomOffset();\n\n\t\tvar hole = [];\n\n\t\tfor ( var f = 0; f < faces.length; ) {\n\n\t\t\tvar face = faces[ f ];\n\n\t\t\t// for each face, if the vertex can see it,\n\t\t\t// then we try to add the face's edges into the hole.\n\t\t\tif ( visible( face, vertex ) ) {\n\n\t\t\t\tfor ( var e = 0; e < 3; e++ ) {\n\n\t\t\t\t\tvar edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];\n\t\t\t\t\tvar boundary = true;\n\n\t\t\t\t\t// remove duplicated edges.\n\t\t\t\t\tfor ( var h = 0; h < hole.length; h++ ) {\n\n\t\t\t\t\t\tif ( equalEdge( hole[ h ], edge ) ) {\n\n\t\t\t\t\t\t\thole[ h ] = hole[ hole.length - 1 ];\n\t\t\t\t\t\t\thole.pop();\n\t\t\t\t\t\t\tboundary = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundary ) {\n\n\t\t\t\t\t\thole.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// remove faces[ f ]\n\t\t\t\tfaces[ f ] = faces[ faces.length - 1 ];\n\t\t\t\tfaces.pop();\n\n\t\t\t} else { // not visible\n\n\t\t\t\tf++;\n\n\t\t\t}\n\t\t}\n\n\t\t// construct the new faces formed by the edges of the hole and the vertex\n\t\tfor ( var h = 0; h < hole.length; h++ ) {\n\n\t\t\tfaces.push( [\n\t\t\t\thole[ h ][ 0 ],\n\t\t\t\thole[ h ][ 1 ],\n\t\t\t\tvertexId\n\t\t\t] );\n\n\t\t}\n\t}\n\n\t/**\n\t * Whether the face is visible from the vertex\n\t */\n\tfunction visible( face, vertex ) {\n\n\t\tvar va = vertices[ face[ 0 ] ];\n\t\tvar vb = vertices[ face[ 1 ] ];\n\t\tvar vc = vertices[ face[ 2 ] ];\n\n\t\tvar n = normal( va, vb, vc );\n\n\t\t// distance from face to origin\n\t\tvar dist = n.dot( va );\n\n\t\treturn n.dot( vertex ) >= dist;\n\n\t}\n\n\t/**\n\t * Face normal\n\t */\n\tfunction normal( va, vb, vc ) {\n\n\t\tvar cb = new THREE.Vector3();\n\t\tvar ab = new THREE.Vector3();\n\n\t\tcb.sub( vc, vb );\n\t\tab.sub( va, vb );\n\t\tcb.crossSelf( ab );\n\n\t\tif ( !cb.isZero() ) {\n\n\t\t\tcb.normalize();\n\n\t\t}\n\n\t\treturn cb;\n\n\t}\n\n\t/**\n\t * Detect whether two edges are equal.\n\t * Note that when constructing the convex hull, two same edges can only\n\t * be of the negative direction.\n\t */\n\tfunction equalEdge( ea, eb ) {\n\n\t\treturn ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ];\n\n\t}\n\n\t/**\n\t * Create a random offset between -1e-6 and 1e-6.\n\t */\n\tfunction randomOffset() {\n\n\t\treturn ( Math.random() - 0.5 ) * 2 * 1e-6;\n\n\t}\n\n\n\t/**\n\t * XXX: Not sure if this is the correct approach. Need someone to review.\n\t */\n\tfunction vertexUv( vertex ) {\n\n\t\tvar mag = vertex.length();\n\t\treturn new THREE.UV( vertex.x / mag, vertex.y / mag );\n\n\t}\n\n\t// Push vertices into `this.vertices`, skipping those inside the hull\n\tvar id = 0;\n\tvar newId = new Array( vertices.length ); // map from old vertex id to new id\n\n\tfor ( var i = 0; i < faces.length; i++ ) {\n\n\t\t var face = faces[ i ];\n\n\t\t for ( var j = 0; j < 3; j++ ) {\n\n\t\t\t\tif ( newId[ face[ j ] ] === undefined ) {\n\n\t\t\t\t\t\tnewId[ face[ j ] ] = id++;\n\t\t\t\t\t\tthis.vertices.push( vertices[ face[ j ] ] );\n\n\t\t\t\t}\n\n\t\t\t\tface[ j ] = newId[ face[ j ] ];\n\n\t\t }\n\n\t}\n\n\t// Convert faces into instances of THREE.Face3\n\tfor ( var i = 0; i < faces.length; i++ ) {\n\n\t\tthis.faces.push( new THREE.Face3(\n\t\t\t\tfaces[ i ][ 0 ],\n\t\t\t\tfaces[ i ][ 1 ],\n\t\t\t\tfaces[ i ][ 2 ]\n\t\t) );\n\n\t}\n\n\t// Compute UVs\n\tfor ( var i = 0; i < this.faces.length; i++ ) {\n\n\t\tvar face = this.faces[ i ];\n\n\t\tthis.faceVertexUvs[ 0 ].push( [\n\t\t\tvertexUv( this.vertices[ face.a ] ),\n\t\t\tvertexUv( this.vertices[ face.b ] ),\n\t\t\tvertexUv( this.vertices[ face.c ])\n\t\t] );\n\n\t}\n\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tgeometry.vertices.push(\n\t\tnew THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )\n\t);\n\n\tgeometry.colors.push(\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\n\t);\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  hex - color in hex value\n */\n\nTHREE.ArrowHelper = function ( dir, origin, length, hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tif ( hex === undefined ) hex = 0xffff00;\n\tif ( length === undefined ) length = 20;\n\n\tvar lineGeometry = new THREE.Geometry();\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\n\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\n\tthis.add( this.line );\n\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );\n\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\n\tthis.cone.position.set( 0, 1, 0 );\n\tthis.add( this.cone );\n\n\tif ( origin instanceof THREE.Vector3 ) this.position = origin;\n\n\tthis.setDirection( dir );\n\tthis.setLength( length );\n\n};\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ArrowHelper.prototype.setDirection = function ( dir ) {\n\n\tvar axis = new THREE.Vector3( 0, 1, 0 ).crossSelf( dir );\n\n\tvar radians = Math.acos( new THREE.Vector3( 0, 1, 0 ).dot( dir.clone().normalize() ) );\n\n\tthis.matrix = new THREE.Matrix4().makeRotationAxis( axis.normalize(), radians );\n\n\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\n\n};\n\nTHREE.ArrowHelper.prototype.setLength = function ( length ) {\n\n\tthis.scale.set( length, length, length );\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\n\n\tthis.line.material.color.setHex( hex );\n\tthis.cone.material.color.setHex( hex );\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tTHREE.Line.call( this );\n\n\tvar scope = this;\n\n\tthis.geometry = new THREE.Geometry();\n\tthis.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\tthis.type = THREE.LinePieces;\n\n\tthis.matrixWorld = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tthis.camera = camera;\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tscope.geometry.vertices.push( new THREE.Vector3() );\n\t\tscope.geometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];\n\n\t\tscope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );\n\n\t}\n\n\tthis.update( camera );\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar scope = this;\n\n\tvar w = 1, h = 1;\n\n\t// we need just camera projection matrix\n\t// world matrix must be identity\n\n\tTHREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t// center / target\n\n\tsetPoint( \"c\", 0, 0, -1 );\n\tsetPoint( \"t\", 0, 0,  1 );\n\n\t// near\n\n\tsetPoint( \"n1\", -w, -h, -1 );\n\tsetPoint( \"n2\",  w, -h, -1 );\n\tsetPoint( \"n3\", -w,  h, -1 );\n\tsetPoint( \"n4\",  w,  h, -1 );\n\n\t// far\n\n\tsetPoint( \"f1\", -w, -h, 1 );\n\tsetPoint( \"f2\",  w, -h, 1 );\n\tsetPoint( \"f3\", -w,  h, 1 );\n\tsetPoint( \"f4\",  w,  h, 1 );\n\n\t// up\n\n\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\n\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\n\tsetPoint( \"u3\",        0, h * 2,   -1 );\n\n\t// cross\n\n\tsetPoint( \"cf1\", -w,  0, 1 );\n\tsetPoint( \"cf2\",  w,  0, 1 );\n\tsetPoint( \"cf3\",  0, -h, 1 );\n\tsetPoint( \"cf4\",  0,  h, 1 );\n\n\tsetPoint( \"cn1\", -w,  0, -1 );\n\tsetPoint( \"cn2\",  w,  0, -1 );\n\tsetPoint( \"cn3\",  0, -h, -1 );\n\tsetPoint( \"cn4\",  0,  h, -1 );\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tTHREE.CameraHelper.__v.set( x, y, z );\n\t\tTHREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );\n\n\t\tvar points = scope.pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.geometry.verticesNeedUpdate = true;\n\n};\n\nTHREE.CameraHelper.__projector = new THREE.Projector();\nTHREE.CameraHelper.__v = new THREE.Vector3();\nTHREE.CameraHelper.__c = new THREE.Camera();\n\n/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tSubdivision Geometry Modifier\n *\t\tusing Catmull-Clark Subdivision Surfaces\n *\t\tfor creating smooth geometry meshes\n *\n *\tNote: a modifier modifies vertices and faces of geometry,\n *\t\tso use THREE.GeometryUtils.clone() if orignal geoemtry needs to be retained\n *\n *\tReadings:\n *\t\thttp://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\n *\t\thttp://www.rorydriscoll.com/2008/08/01/catmull-clark-subdivision-the-basics/\n *\t\thttp://xrt.wikidot.com/blog:31\n *\t\t\"Subdivision Surfaces in Character Animation\"\n *\n *\t\t(on boundary edges)\n *\t\thttp://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\n *\t\thttps://graphics.stanford.edu/wikis/cs148-09-summer/Assignment3Description\n *\n *\tSupports:\n *\t\tClosed and Open geometries.\n *\n *\tTODO:\n *\t\tcrease vertex and \"semi-sharp\" features\n *\t\tselective subdivision\n */\n\n\nTHREE.SubdivisionModifier = function( subdivisions ) {\n\n\tthis.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;\n\n\t// Settings\n\tthis.useOldVertexColors = false;\n\tthis.supportUVs = true;\n\tthis.debug = false;\n\n};\n\n// Applies the \"modify\" pattern\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats-- > 0 ) {\n\t\tthis.smooth( geometry );\n\t}\n\n};\n\n/// REFACTORING THIS OUT\n\nTHREE.GeometryUtils.orderedKey = function ( a, b ) {\n\n\treturn Math.min( a, b ) + \"_\" + Math.max( a, b );\n\n};\n\n\n// Returns a hashmap - of { edge_key: face_index }\nTHREE.GeometryUtils.computeEdgeFaces = function ( geometry ) {\n\n\tvar i, il, v1, v2, j, k,\n\t\tface, faceIndices, faceIndex,\n\t\tedge,\n\t\thash,\n\t\tedgeFaceMap = {};\n\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\n\n\tfunction mapEdgeHash( hash, i ) {\n\n\t\tif ( edgeFaceMap[ hash ] === undefined ) {\n\n\t\t\tedgeFaceMap[ hash ] = [];\n\n\t\t}\n\n\t\tedgeFaceMap[ hash ].push( i );\n\t}\n\n\n\t// construct vertex -> face map\n\n\tfor( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\tface = geometry.faces[ i ];\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\thash = orderedKey( face.a, face.b );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.b, face.c );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.c, face.a );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\thash = orderedKey( face.a, face.b );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.b, face.c );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.c, face.d );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.d, face.a );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t}\n\n\t}\n\n\t// extract faces\n\n\t// var edges = [];\n\t//\n\t// var numOfEdges = 0;\n\t// for (i in edgeFaceMap) {\n\t// \tnumOfEdges++;\n\t//\n\t// \tedge = edgeFaceMap[i];\n\t// \tedges.push(edge);\n\t//\n\t// }\n\n\t//debug('edgeFaceMap', edgeFaceMap, 'geometry.edges',geometry.edges, 'numOfEdges', numOfEdges);\n\n\treturn edgeFaceMap;\n\n}\n\n/////////////////////////////\n\n// Performs an iteration of Catmull-Clark Subdivision\nTHREE.SubdivisionModifier.prototype.smooth = function ( oldGeometry ) {\n\n\t//debug( 'running smooth' );\n\n\t// New set of vertices, faces and uvs\n\tvar newVertices = [], newFaces = [], newUVs = [];\n\n\tfunction v( x, y, z ) {\n\t\tnewVertices.push( new THREE.Vector3( x, y, z ) );\n\t}\n\n\tvar scope = this;\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\n\tvar computeEdgeFaces = THREE.GeometryUtils.computeEdgeFaces;\n\n\tfunction assert() {\n\t\tif (scope.debug && console && console.assert) console.assert.apply(console, arguments);\n\t}\n\n\tfunction debug() {\n\t\tif (scope.debug) console.log.apply(console, arguments);\n\t}\n\n\tfunction warn() {\n\t\tif (console)\n\t\tconsole.log.apply(console, arguments);\n\t}\n\n\tfunction f4( a, b, c, d, oldFace, orders, facei ) {\n\n\t\t// TODO move vertex selection over here!\n\n\t\tvar newFace = new THREE.Face4( a, b, c, d, null, oldFace.color, oldFace.materialIndex );\n\n\t\tif (scope.useOldVertexColors) {\n\n\t\t\tnewFace.vertexColors = [];\n\n\t\t\tvar color, tmpColor, order;\n\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\torder = orders[i];\n\n\t\t\t\tcolor = new THREE.Color(),\n\t\t\t\tcolor.setRGB(0,0,0);\n\n\t\t\t\tfor (var j=0, jl=0; j<order.length;j++) {\n\t\t\t\t\ttmpColor = oldFace.vertexColors[order[j]-1];\n\t\t\t\t\tcolor.r += tmpColor.r;\n\t\t\t\t\tcolor.g += tmpColor.g;\n\t\t\t\t\tcolor.b += tmpColor.b;\n\t\t\t\t}\n\n\t\t\t\tcolor.r /= order.length;\n\t\t\t\tcolor.g /= order.length;\n\t\t\t\tcolor.b /= order.length;\n\n\t\t\t\tnewFace.vertexColors[i] = color;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnewFaces.push( newFace );\n\n\t\tif (scope.supportUVs) {\n\n\t\t\tvar aUv = [\n\t\t\t\tgetUV(a, ''),\n\t\t\t\tgetUV(b, facei),\n\t\t\t\tgetUV(c, facei),\n\t\t\t\tgetUV(d, facei)\n\t\t\t];\n\n\t\t\tif (!aUv[0]) debug('a :( ', a+':'+facei);\n\t\t\telse if (!aUv[1]) debug('b :( ', b+':'+facei);\n\t\t\telse if (!aUv[2]) debug('c :( ', c+':'+facei);\n\t\t\telse if (!aUv[3]) debug('d :( ', d+':'+facei);\n\t\t\telse\n\t\t\t\tnewUVs.push( aUv );\n\n\t\t}\n\t}\n\n\tvar originalPoints = oldGeometry.vertices;\n\tvar originalFaces = oldGeometry.faces;\n\tvar originalVerticesLength = originalPoints.length;\n\n\tvar newPoints = originalPoints.concat(); // New set of vertices to work on\n\n\tvar facePoints = [], // these are new points on exisiting faces\n\t\tedgePoints = {}; // these are new points on exisiting edges\n\n\tvar sharpEdges = {}, sharpVertices = []; // Mark edges and vertices to prevent smoothening on them\n\t// TODO: handle this correctly.\n\n\tvar uvForVertices = {}; // Stored in {vertex}:{old face} format\n\n\n\tfunction debugCoreStuff() {\n\t\tconsole.log('facePoints', facePoints, 'edgePoints', edgePoints);\n\t\tconsole.log('edgeFaceMap', edgeFaceMap, 'vertexEdgeMap', vertexEdgeMap);\n\n\t}\n\n\tfunction getUV(vertexNo, oldFaceNo) {\n\t\tvar j,jl;\n\n\t\tvar key = vertexNo+':'+oldFaceNo;\n\t\tvar theUV = uvForVertices[key];\n\n\t\tif (!theUV) {\n\t\t\tif (vertexNo>=originalVerticesLength && vertexNo < (originalVerticesLength + originalFaces.length)) {\n\t\t\t\tdebug('face pt');\n\t\t\t} else {\n\t\t\t\tdebug('edge pt');\n\t\t\t}\n\n\t\t\twarn('warning, UV not found for', key);\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn theUV;\n\n\t\t// Original faces -> Vertex Nos.\n\t\t// new Facepoint -> Vertex Nos.\n\t\t// edge Points\n\n\t}\n\n\tfunction addUV(vertexNo, oldFaceNo, value) {\n\n\t\tvar key = vertexNo+':'+oldFaceNo;\n\t\tif (!(key in uvForVertices)) {\n\t\t\tuvForVertices[key] = value;\n\t\t} else {\n\t\t\twarn('dup vertexNo', vertexNo, 'oldFaceNo', oldFaceNo, 'value', value, 'key', key, uvForVertices[key]);\n\t\t}\n\t}\n\n\t// Step 1\n\t//\tFor each face, add a face point\n\t//\tSet each face point to be the centroid of all original points for the respective face.\n\t// debug(oldGeometry);\n\tvar i, il, j, jl, face;\n\n\t// For Uvs\n\tvar uvs = oldGeometry.faceVertexUvs[0];\n\tvar abcd = 'abcd', vertice;\n\n\tdebug('originalFaces, uvs, originalVerticesLength', originalFaces.length, uvs.length, originalVerticesLength);\n\tif (scope.supportUVs)\n\tfor (i=0, il = uvs.length; i<il; i++ ) {\n\t\tfor (j=0,jl=uvs[i].length;j<jl;j++) {\n\t\t\tvertice = originalFaces[i][abcd.charAt(j)];\n\n\t\t\taddUV(vertice, i, uvs[i][j]);\n\n\t\t}\n\t}\n\n\tif (uvs.length == 0) scope.supportUVs = false;\n\n\t// Additional UVs check, if we index original\n\tvar uvCount = 0;\n\tfor (var u in uvForVertices) {\n\t\tuvCount++;\n\t}\n\tif (!uvCount) {\n\t\tscope.supportUVs = false;\n\t\tdebug('no uvs');\n\t}\n\n\tvar avgUv ;\n\tfor (i=0, il = originalFaces.length; i<il ;i++) {\n\t\tface = originalFaces[ i ];\n\t\tfacePoints.push( face.centroid );\n\t\tnewPoints.push( face.centroid );\n\n\n\t\tif (!scope.supportUVs) continue;\n\n\t\t// Prepare subdivided uv\n\n\t\tavgUv = new THREE.UV();\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\t\t\tavgUv.u = getUV( face.a, i ).u + getUV( face.b, i ).u + getUV( face.c, i ).u;\n\t\t\tavgUv.v = getUV( face.a, i ).v + getUV( face.b, i ).v + getUV( face.c, i ).v;\n\t\t\tavgUv.u /= 3;\n\t\t\tavgUv.v /= 3;\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\t\t\tavgUv.u = getUV( face.a, i ).u + getUV( face.b, i ).u + getUV( face.c, i ).u + getUV( face.d, i ).u;\n\t\t\tavgUv.v = getUV( face.a, i ).v + getUV( face.b, i ).v + getUV( face.c, i ).v + getUV( face.d, i ).v;\n\t\t\tavgUv.u /= 4;\n\t\t\tavgUv.v /= 4;\n\t\t}\n\n\t\taddUV(originalVerticesLength + i, '', avgUv);\n\n\t}\n\n\t// Step 2\n\t//\tFor each edge, add an edge point.\n\t//\tSet each edge point to be the average of the two neighbouring face points and its two original endpoints.\n\n\tvar edgeFaceMap = computeEdgeFaces ( oldGeometry ); // Edge Hash -> Faces Index  eg { edge_key: [face_index, face_index2 ]}\n\tvar edge, faceIndexA, faceIndexB, avg;\n\n\t// debug('edgeFaceMap', edgeFaceMap);\n\n\tvar edgeCount = 0;\n\n\tvar edgeVertex, edgeVertexA, edgeVertexB;\n\n\t////\n\n\tvar vertexEdgeMap = {}; // Gives edges connecting from each vertex\n\tvar vertexFaceMap = {}; // Gives faces connecting from each vertex\n\n\tfunction addVertexEdgeMap(vertex, edge) {\n\t\tif (vertexEdgeMap[vertex]===undefined) {\n\t\t\tvertexEdgeMap[vertex] = [];\n\t\t}\n\n\t\tvertexEdgeMap[vertex].push(edge);\n\t}\n\n\tfunction addVertexFaceMap(vertex, face, edge) {\n\t\tif (vertexFaceMap[vertex]===undefined) {\n\t\t\tvertexFaceMap[vertex] = {};\n\t\t}\n\n\t\tvertexFaceMap[vertex][face] = edge;\n\t\t// vertexFaceMap[vertex][face] = null;\n\t}\n\n\t// Prepares vertexEdgeMap and vertexFaceMap\n\tfor (i in edgeFaceMap) { // This is for every edge\n\t\tedge = edgeFaceMap[i];\n\n\t\tedgeVertex = i.split('_');\n\t\tedgeVertexA = edgeVertex[0];\n\t\tedgeVertexB = edgeVertex[1];\n\n\t\t// Maps an edgeVertex to connecting edges\n\t\taddVertexEdgeMap(edgeVertexA, [edgeVertexA, edgeVertexB] );\n\t\taddVertexEdgeMap(edgeVertexB, [edgeVertexA, edgeVertexB] );\n\n\n\t\tfor (j=0,jl=edge.length;j<jl;j++) {\n\t\t\tface = edge[j];\n\n\t\t\taddVertexFaceMap(edgeVertexA, face, i);\n\t\t\taddVertexFaceMap(edgeVertexB, face, i);\n\t\t}\n\n\t\t// {edge vertex: { face1: edge_key, face2: edge_key.. } }\n\n\t\t// this thing is fishy right now.\n\t\tif (edge.length < 2) {\n\t\t\t// edge is \"sharp\";\n\t\t\tsharpEdges[i] = true;\n\t\t\tsharpVertices[edgeVertexA] = true;\n\t\t\tsharpVertices[edgeVertexB] = true;\n\n\t\t}\n\n\t}\n\n\tfor (i in edgeFaceMap) {\n\t\tedge = edgeFaceMap[i];\n\n\t\tfaceIndexA = edge[0]; // face index a\n\t\tfaceIndexB = edge[1]; // face index b\n\n\t\tedgeVertex = i.split('_');\n\t\tedgeVertexA = edgeVertex[0];\n\t\tedgeVertexB = edgeVertex[1];\n\n\n\t\tavg = new THREE.Vector3();\n\n\t\t//debug(i, faceIndexB,facePoints[faceIndexB]);\n\n\t\tassert(edge.length > 0, 'an edge without faces?!');\n\n\t\tif (edge.length==1) {\n\n\t\t\tavg.addSelf(originalPoints[edgeVertexA]);\n\t\t\tavg.addSelf(originalPoints[edgeVertexB]);\n\t\t\tavg.multiplyScalar(0.5);\n\n\t\t\tsharpVertices[newPoints.length] = true;\n\n\t\t} else {\n\n\t\t\tavg.addSelf(facePoints[faceIndexA]);\n\t\t\tavg.addSelf(facePoints[faceIndexB]);\n\n\t\t\tavg.addSelf(originalPoints[edgeVertexA]);\n\t\t\tavg.addSelf(originalPoints[edgeVertexB]);\n\n\t\t\tavg.multiplyScalar(0.25);\n\n\t\t}\n\n\t\tedgePoints[i] = originalVerticesLength + originalFaces.length + edgeCount;\n\n\t\tnewPoints.push( avg );\n\n\t\tedgeCount ++;\n\n\t\tif (!scope.supportUVs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Prepare subdivided uv\n\n\t\tavgUv = new THREE.UV();\n\n\t\tavgUv.u = getUV(edgeVertexA, faceIndexA).u + getUV(edgeVertexB, faceIndexA).u;\n\t\tavgUv.v = getUV(edgeVertexA, faceIndexA).v + getUV(edgeVertexB, faceIndexA).v;\n\t\tavgUv.u /= 2;\n\t\tavgUv.v /= 2;\n\n\t\taddUV(edgePoints[i], faceIndexA, avgUv);\n\n\t\tif (edge.length>=2) {\n\t\tassert(edge.length == 2, 'did we plan for more than 2 edges?');\n\t\tavgUv = new THREE.UV();\n\n\t\tavgUv.u = getUV(edgeVertexA, faceIndexB).u + getUV(edgeVertexB, faceIndexB).u;\n\t\tavgUv.v = getUV(edgeVertexA, faceIndexB).v + getUV(edgeVertexB, faceIndexB).v;\n\t\tavgUv.u /= 2;\n\t\tavgUv.v /= 2;\n\n\t\taddUV(edgePoints[i], faceIndexB, avgUv);\n\t\t}\n\n\t}\n\n\tdebug('-- Step 2 done');\n\n\t// Step 3\n\t//\tFor each face point, add an edge for every edge of the face,\n\t//\tconnecting the face point to each edge point for the face.\n\n\tvar facePt, currentVerticeIndex;\n\n\tvar hashAB, hashBC, hashCD, hashDA, hashCA;\n\n\tvar abc123 = ['123', '12', '2', '23'];\n\tvar bca123 = ['123', '23', '3', '31'];\n\tvar cab123 = ['123', '31', '1', '12'];\n\tvar abc1234 = ['1234', '12', '2', '23'];\n\tvar bcd1234 = ['1234', '23', '3', '34'];\n\tvar cda1234 = ['1234', '34', '4', '41'];\n\tvar dab1234 = ['1234', '41', '1', '12'];\n\n\n\tfor (i=0, il = facePoints.length; i<il ;i++) { // for every face\n\t\tfacePt = facePoints[i];\n\t\tface = originalFaces[i];\n\t\tcurrentVerticeIndex = originalVerticesLength+ i;\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t// create 3 face4s\n\n\t\t\thashAB = orderedKey( face.a, face.b );\n\t\t\thashBC = orderedKey( face.b, face.c );\n\t\t\thashCA = orderedKey( face.c, face.a );\n\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc123, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCA], face, bca123, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCA], face.a, edgePoints[hashAB], face, cab123, i );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\t\t\t// create 4 face4s\n\n\t\t\thashAB = orderedKey( face.a, face.b );\n\t\t\thashBC = orderedKey( face.b, face.c );\n\t\t\thashCD = orderedKey( face.c, face.d );\n\t\t\thashDA = orderedKey( face.d, face.a );\n\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCD], face, bcd1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCD], face.d, edgePoints[hashDA], face, cda1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashDA], face.a, edgePoints[hashAB], face, dab1234, i );\n\n\n\t\t} else {\n\t\t\tdebug('face should be a face!', face);\n\t\t}\n\t}\n\n\tnewVertices = newPoints;\n\n\t// Step 4\n\n\t//\tFor each original point P,\n\t//\t\ttake the average F of all n face points for faces touching P,\n\t//\t\tand take the average R of all n edge midpoints for edges touching P,\n\t//\t\twhere each edge midpoint is the average of its two endpoint vertices.\n\t//\tMove each original point to the point\n\n\n\tvar F = new THREE.Vector3();\n\tvar R = new THREE.Vector3();\n\n\tvar n;\n\tfor (i=0, il = originalPoints.length; i<il; i++) {\n\t\t// (F + 2R + (n-3)P) / n\n\n\t\tif (vertexEdgeMap[i]===undefined) continue;\n\n\t\tF.set(0,0,0);\n\t\tR.set(0,0,0);\n\t\tvar newPos =  new THREE.Vector3(0,0,0);\n\n\t\tvar f = 0; // this counts number of faces, original vertex is connected to (also known as valance?)\n\t\tfor (j in vertexFaceMap[i]) {\n\t\t\tF.addSelf(facePoints[j]);\n\t\t\tf++;\n\t\t}\n\n\t\tvar sharpEdgeCount = 0;\n\n\t\tn = vertexEdgeMap[i].length; // given a vertex, return its connecting edges\n\n\t\t// Are we on the border?\n\t\tvar boundary_case = f != n;\n\n\t\t// if (boundary_case) {\n\t\t// \tconsole.error('moo', 'o', i, 'faces touched', f, 'edges',  n, n == 2);\n\t\t// }\n\n\n\t\tfor (j=0;j<n;j++) {\n\t\t\tif (\n\t\t\t\tsharpEdges[\n\t\t\t\t\torderedKey(vertexEdgeMap[i][j][0],vertexEdgeMap[i][j][1])\n\t\t\t\t]) {\n\t\t\t\t\tsharpEdgeCount++;\n\t\t\t\t}\n\t\t}\n\n\t\t// if ( sharpEdgeCount==2 ) {\n\t\t// \tcontinue;\n\t\t// \t// Do not move vertex if there's 2 connecting sharp edges.\n\t\t// }\n\n\t\t/*\n\t\tif (sharpEdgeCount>2) {\n\t\t\t// TODO\n\t\t}\n\t\t*/\n\n\t\tF.divideScalar(f);\n\n\n\t\tvar boundary_edges = 0;\n\n\n\n\t\tif (boundary_case) {\n\n\t\t\tvar bb_edge;\n\t\t\tfor (j=0; j<n;j++) {\n\t\t\t\tedge = vertexEdgeMap[i][j];\n\t\t\t\tbb_edge = edgeFaceMap[orderedKey(edge[0], edge[1])].length == 1\n\t\t\t\tif (bb_edge) {\n\t\t\t\t\tvar midPt = originalPoints[edge[0]].clone().addSelf(originalPoints[edge[1]]).divideScalar(2);\n\t\t\t\t\tR.addSelf(midPt);\n\t\t\t\t\tboundary_edges++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tR.divideScalar(4);\n\t\t\t// console.log(j + ' --- ' + n + ' --- ' + boundary_edges);\n\t\t\tassert(boundary_edges == 2, 'should have only 2 boundary edges');\n\n\t\t} else {\n\t\t\tfor (j=0; j<n;j++) {\n\t\t\t\tedge = vertexEdgeMap[i][j];\n\t\t\t\tvar midPt = originalPoints[edge[0]].clone().addSelf(originalPoints[edge[1]]).divideScalar(2);\n\t\t\t\tR.addSelf(midPt);\n\t\t\t}\n\n\t\t\tR.divideScalar(n);\n\t\t}\n\n\t\t// Sum the formula\n\t\tnewPos.addSelf(originalPoints[i]);\n\n\n\t\tif (boundary_case) {\n\n\t\t\tnewPos.divideScalar(2);\n\t\t\tnewPos.addSelf(R);\n\n\t\t} else {\n\n\t\t\tnewPos.multiplyScalar(n - 3);\n\n\t\t\tnewPos.addSelf(F);\n\t\t\tnewPos.addSelf(R.multiplyScalar(2));\n\t\t\tnewPos.divideScalar(n);\n\n\t\t}\n\n\t\tnewVertices[i] = newPos;\n\n\n\t}\n\n\tvar newGeometry = oldGeometry; // Let's pretend the old geometry is now new :P\n\n\tnewGeometry.vertices = newVertices;\n\tnewGeometry.faces = newFaces;\n\tnewGeometry.faceVertexUvs[ 0 ] = newUVs;\n\n\tdelete newGeometry.__tmpVertices; // makes __tmpVertices undefined :P\n\n\tnewGeometry.computeCentroids();\n\tnewGeometry.computeFaceNormals();\n\tnewGeometry.computeVertexNormals();\n\n};/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.render = function ( renderCallback ) { };\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\n\n\n/*\n * Add: adds another flare\n */\n\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\n\n\tif( size === undefined ) size = -1;\n\tif( distance === undefined ) distance = 0;\n\tif( opacity === undefined ) opacity = 1;\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\n\tif( blending === undefined ) blending = THREE.NormalBlending;\n\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\n\t\t                    scale: 1, \t\t\t\t\t// scale\n\t\t                    rotation: 1, \t\t\t\t// rotation\n\t\t                    opacity: opacity,\t\t\t// opacity\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\n\t\t                    blending: blending } );\t\t// blending\n\n};\n\n\n/*\n * Update lens flares update positions on all flares based on the screen position\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n */\n\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n\n\tvar f, fl = this.lensFlares.length;\n\tvar flare;\n\tvar vecX = -this.positionScreen.x * 2;\n\tvar vecY = -this.positionScreen.y * 2;\n\n\tfor( f = 0; f < fl; f ++ ) {\n\n\t\tflare = this.lensFlares[ f ];\n\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t}\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstartFrame: start,\n\t\tendFrame: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\t\t\tvar num = chunks[ 2 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = -1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = -1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= -1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t}\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( ) {\n\n\tvar _gl, _renderer, _lensFlare = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\n\t\t_lensFlare.faces = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\ti = 0;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\n\n\t\t// buffers\n\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\n\n\t\t\t_lensFlare.hasVertexTexture = false;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ] );\n\n\t\t} else {\n\n\t\t\t_lensFlare.hasVertexTexture = true;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ] );\n\n\t\t}\n\n\t\t_lensFlare.attributes = {};\n\t\t_lensFlare.uniforms = {};\n\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\n\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\n\n\t\t_lensFlare.attributesEnabled = false;\n\n\t};\n\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\t *         update transparency of flares. Then they are rendered.\n\t *\n\t */\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar flares = scene.__webglFlares,\n\t\t\tnFlares = flares.length;\n\n\t\tif ( ! nFlares ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewportHeight / viewportWidth,\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\tvar size = 16 / viewportHeight,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar uniforms = _lensFlare.uniforms,\n\t\t\tattributes = _lensFlare.attributes;\n\n\t\t// set _lensFlare program and reset blending\n\n\t\t_gl.useProgram( _lensFlare.program );\n\n\t\tif ( ! _lensFlare.attributesEnabled ) {\n\n\t\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\n\t\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\n\n\t\t\t_lensFlare.attributesEnabled = true;\n\n\t\t}\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/unforms\n\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t_gl.uniform1i( uniforms.map, 1 );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.depthMask( false );\n\n\t\tvar i, j, jl, flare, sprite;\n\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\n\n\t\t\tsize = 16 / viewportHeight;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tflare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\n\n\t\t\tcamera.matrixWorldInverse.multiplyVector3( tempPosition );\n\t\t\tcamera.projectionMatrix.multiplyVector3( tempPosition );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition )\n\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n\n\t\t\t// screen cull\n\n\t\t\tif ( _lensFlare.hasVertexTexture || (\n\t\t\t\tscreenPositionPixels.x > 0 &&\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\n\t\t\t\tscreenPositionPixels.y > 0 &&\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition )\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\n\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthMask( true );\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t_gl.shaderSource( fragmentShader, shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n};/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShadowMapPlugin = function ( ) {\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_min = new THREE.Vector3(),\n\t_max = new THREE.Vector3();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tshadowMap, shadowMatrix, shadowCamera,\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tlights = [],\n\t\tk = 0,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.frontFace( _gl.CCW );\n\n\t\tif ( _renderer.shadowMapCullFrontFaces ) {\n\n\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t} else {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// preprocess lights\n\t\t// \t- skip lights that are not casting shadows\n\t\t//\t- create virtual lights for cascaded shadow maps\n\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\n\n\t\t\tlight = scene.__lights[ i ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\n\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\n\n\t\t\t\t\tvar virtualLight;\n\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\n\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\n\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\n\n\t\t\t\t\t\tgyro.add( virtualLight );\n\t\t\t\t\t\tgyro.add( virtualLight.target );\n\n\t\t\t\t\t\tcamera.add( gyro );\n\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\n\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateVirtualLight( light, n );\n\n\t\t\t\t\tlights[ k ] = virtualLight;\n\t\t\t\t\tk ++;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlights[ k ] = light;\n\t\t\t\tk ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render depth map\n\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tlight = lights[ i ];\n\n\t\t\tif ( ! light.shadowMap ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\n\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tif ( ! light.shadowCamera ) {\n\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( light.shadowCamera );\n\n\t\t\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\n\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\n\n\t\t\t}\n\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\n\n\t\t\t\tupdateShadowCamera( camera, light );\n\n\t\t\t}\n\n\t\t\tshadowMap = light.shadowMap;\n\t\t\tshadowMatrix = light.shadowMatrix;\n\t\t\tshadowCamera = light.shadowCamera;\n\n\t\t\tshadowCamera.position.copy( light.matrixWorld.getPosition() );\n\t\t\tshadowCamera.lookAt( light.target.matrixWorld.getPosition() );\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\n\n\t\t\t// compute shadow matrix\n\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\n\n\t\t\tshadowMatrix.multiplySelf( shadowCamera.projectionMatrix );\n\t\t\tshadowMatrix.multiplySelf( shadowCamera.matrixWorldInverse );\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( ! shadowCamera._viewMatrixArray ) shadowCamera._viewMatrixArray = new Float32Array( 16 );\n\t\t\tif ( ! shadowCamera._projectionMatrixArray ) shadowCamera._projectionMatrixArray = new Float32Array( 16 );\n\n\t\t\tshadowCamera.matrixWorldInverse.flattenToArray( shadowCamera._viewMatrixArray );\n\t\t\tshadowCamera.projectionMatrix.flattenToArray( shadowCamera._projectionMatrixArray );\n\n\t\t\t_projScreenMatrix.multiply( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t// render shadow map\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// set object matrices & frustum culling\n\n\t\t\trenderList = scene.__webglObjects;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\twebglObject.render = false;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {\n\n\t\t\t\t\t\tobject._modelViewMatrix.multiply( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render regular objects\n\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\n\t\t\t\tif ( webglObject.render ) {\n\n\t\t\t\t\tobject = webglObject.object;\n\t\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t\t// culling is overriden globally for all objects\n\t\t\t\t\t// while rendering depth map\n\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\n\t\t\t\t\t// in that case just use the first of geometry.materials for now\n\t\t\t\t\t// (proper solution would require to break objects by materials\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\n\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// set matrices and render immediate objects\n\n\t\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiply( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\tif ( _renderer.shadowMapCullFrontFaces ) {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t};\n\n\tfunction createVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = new THREE.DirectionalLight();\n\n\t\tvirtualLight.isVirtual = true;\n\n\t\tvirtualLight.onlyShadow = true;\n\t\tvirtualLight.castShadow = true;\n\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\n\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\n\n\t\tvirtualLight.pointsWorld = [];\n\t\tvirtualLight.pointsFrustum = [];\n\n\t\tvar pointsWorld = virtualLight.pointsWorld,\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\n\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\n\n\t\treturn virtualLight;\n\n\t}\n\n\t// Synchronize virtual light with the original light\n\n\tfunction updateVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\n\n\t\tvirtualLight.position.copy( light.position );\n\t\tvirtualLight.target.position.copy( light.target.position );\n\t\tvirtualLight.lookAt( virtualLight.target );\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\n\n\t\tpointsFrustum[ 0 ].z = nearZ;\n\t\tpointsFrustum[ 1 ].z = nearZ;\n\t\tpointsFrustum[ 2 ].z = nearZ;\n\t\tpointsFrustum[ 3 ].z = nearZ;\n\n\t\tpointsFrustum[ 4 ].z = farZ;\n\t\tpointsFrustum[ 5 ].z = farZ;\n\t\tpointsFrustum[ 6 ].z = farZ;\n\t\tpointsFrustum[ 7 ].z = farZ;\n\n\t}\n\n\t// Fit shadow camera's ortho frustum to camera frustum\n\n\tfunction updateShadowCamera( camera, light ) {\n\n\t\tvar shadowCamera = light.shadowCamera,\n\t\t\tpointsFrustum = light.pointsFrustum,\n\t\t\tpointsWorld = light.pointsWorld;\n\n\t\t_min.set( Infinity, Infinity, Infinity );\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar p = pointsWorld[ i ];\n\n\t\t\tp.copy( pointsFrustum[ i ] );\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\n\t\t\tshadowCamera.matrixWorldInverse.multiplyVector3( p );\n\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\n\t\t}\n\n\t\tshadowCamera.left = _min.x;\n\t\tshadowCamera.right = _max.x;\n\t\tshadowCamera.top = _max.y;\n\t\tshadowCamera.bottom = _min.y;\n\n\t\t// can't really fit near/far\n\t\t//shadowCamera.near = _min.z;\n\t\t//shadowCamera.far = _max.z;\n\n\t\tshadowCamera.updateProjectionMatrix();\n\n\t}\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial ? object.geometry.materials[ 0 ] : object.material;\n\n\t}\n\n};\n\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( ) {\n\n\tvar _gl, _renderer, _sprite = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_sprite.vertices = new Float32Array( 8 + 8 );\n\t\t_sprite.faces    = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;\t// vertex 0\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;\t// uv 0\n\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;\t// vertex 1\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;\t// uv 1\n\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// vertex 2\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// uv 2\n\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;\t// vertex 3\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;\t// uv 3\n\n\t\ti = 0;\n\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;\n\n\t\t_sprite.vertexBuffer  = _gl.createBuffer();\n\t\t_sprite.elementBuffer = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );\n\n\t\t_sprite.program = createProgram( THREE.ShaderSprite[ \"sprite\" ] );\n\n\t\t_sprite.attributes = {};\n\t\t_sprite.uniforms = {};\n\n\t\t_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, \"position\" );\n\t\t_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, \"uv\" );\n\n\t\t_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, \"uvOffset\" );\n\t\t_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, \"uvScale\" );\n\n\t\t_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, \"rotation\" );\n\t\t_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, \"scale\" );\n\t\t_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, \"alignment\" );\n\n\t\t_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, \"color\" );\n\t\t_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, \"map\" );\n\t\t_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, \"opacity\" );\n\n\t\t_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, \"useScreenCoordinates\" );\n\t\t_sprite.uniforms.affectedByDistance   = _gl.getUniformLocation( _sprite.program, \"affectedByDistance\" );\n\t\t_sprite.uniforms.screenPosition    \t  = _gl.getUniformLocation( _sprite.program, \"screenPosition\" );\n\t\t_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, \"modelViewMatrix\" );\n\t\t_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, \"projectionMatrix\" );\n\n\t\t_sprite.attributesEnabled = false;\n\n\t};\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar sprites = scene.__webglSprites,\n\t\t\tnSprites = sprites.length;\n\n\t\tif ( ! nSprites ) return;\n\n\t\tvar attributes = _sprite.attributes,\n\t\t\tuniforms = _sprite.uniforms;\n\n\t\tvar invAspect = viewportHeight / viewportWidth;\n\n\t\tvar halfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\tvar mergeWith3D = true;\n\n\t\t// setup gl\n\n\t\t_gl.useProgram( _sprite.program );\n\n\t\tif ( ! _sprite.attributesEnabled ) {\n\n\t\t\t_gl.enableVertexAttribArray( attributes.position );\n\t\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t\t_sprite.attributesEnabled = true;\n\n\t\t}\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.BLEND );\n\t\t_gl.depthMask( true );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera._projectionMatrixArray );\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t_gl.uniform1i( uniforms.map, 0 );\n\n\t\t// update positions and sort\n\n\t\tvar i, sprite, screenPosition, size, scale = [];\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\n\t\t\tif ( ! sprite.visible || sprite.opacity === 0 ) continue;\n\n\t\t\tif( ! sprite.useScreenCoordinates ) {\n\n\t\t\t\tsprite._modelViewMatrix.multiply( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[14];\n\n\t\t\t} else {\n\n\t\t\t\tsprite.z = - sprite.position.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tsprites.sort( painterSort );\n\n\t\t// render all sprites\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\n\t\t\tif ( ! sprite.visible || sprite.opacity === 0 ) continue;\n\n\t\t\tif ( sprite.map && sprite.map.image && sprite.map.image.width ) {\n\n\t\t\t\tif ( sprite.useScreenCoordinates ) {\n\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 1 );\n\t\t\t\t\t_gl.uniform3f(\n\t\t\t\t\t\tuniforms.screenPosition,\n\t\t\t\t\t\t( sprite.position.x - halfViewportWidth  ) / halfViewportWidth,\n\t\t\t\t\t\t( halfViewportHeight - sprite.position.y ) / halfViewportHeight,\n\t\t\t\t\t\tMath.max( 0, Math.min( 1, sprite.position.z ) )\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 0 );\n\t\t\t\t\t_gl.uniform1i( uniforms.affectedByDistance, sprite.affectedByDistance ? 1 : 0 );\n\t\t\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\n\n\t\t\t\t}\n\n\t\t\t\tsize = sprite.map.image.width / ( sprite.scaleByViewport ? viewportHeight : 1 );\n\n\t\t\t\tscale[ 0 ] = size * invAspect * sprite.scale.x;\n\t\t\t\tscale[ 1 ] = size * sprite.scale.y;\n\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, sprite.uvScale.x, sprite.uvScale.y );\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, sprite.uvOffset.x, sprite.uvOffset.y );\n\t\t\t\t_gl.uniform2f( uniforms.alignment, sprite.alignment.x, sprite.alignment.y );\n\n\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\t\t\t_gl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tif ( sprite.mergeWith3D && !mergeWith3D ) {\n\n\t\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t\t\t\tmergeWith3D = true;\n\n\t\t\t\t} else if ( ! sprite.mergeWith3D && mergeWith3D ) {\n\n\t\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\t\t\t\t\tmergeWith3D = false;\n\n\t\t\t\t}\n\n\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t_renderer.setTexture( sprite.map, 0 );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthMask( true );\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t_gl.shaderSource( fragmentShader, shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n\tfunction painterSort ( a, b ) {\n\n\t\treturn b.z - a.z;\n\n\t};\n\n};\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DepthPassPlugin = function ( ) {\n\n\tthis.enabled = false;\n\tthis.renderTarget = null;\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! this.enabled ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// update scene\n\n\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( ! camera._viewMatrixArray ) camera._viewMatrixArray = new Float32Array( 16 );\n\t\tif ( ! camera._projectionMatrixArray ) camera._projectionMatrixArray = new Float32Array( 16 );\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\tcamera.matrixWorldInverse.flattenToArray( camera._viewMatrixArray );\n\t\tcamera.projectionMatrix.flattenToArray( camera._projectionMatrixArray );\n\n\t\t_projScreenMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// render depth map\n\n\t\t_renderer.setRenderTarget( this.renderTarget );\n\t\t_renderer.clear();\n\n\t\t// set object matrices & frustum culling\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {\n\n\t\t\t\t\t//object.matrixWorld.flattenToArray( object._modelMatrixArray );\n\t\t\t\t\tobject._modelViewMatrix.multiply( camera.matrixWorldInverse, object.matrixWorld);\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render regular objects\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\tif ( object.material ) _renderer.setMaterialFaces( object.material );\n\n\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t} else if ( object.geometry.morphTargets.length ) {\n\n\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// set matrices and render immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t/*\n\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\tobject.matrixWorld.flattenToArray( object._modelMatrixArray );\n\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tobject._modelViewMatrix.multiply( camera.matrixWorldInverse, object.matrixWorld);\n\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t};\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n *\n */\n\nTHREE.ShaderFlares = {\n\n\t'lensFlareVertexTexture': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\t\t\t\"uniform int renderType;\",\n\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\",\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\"vVisibility = (       visibility.r / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.g / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"(       visibility.b / 9.0 ) *\",\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.a / 9.0 );\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform int renderType;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t},\n\n\n\t'lensFlare': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\t\t\t\"uniform int renderType;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform int renderType;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\",\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n/**\n * @author mikael emtinger / http://gomo.se/\n *\n */\n\nTHREE.ShaderSprite = {\n\n\t'sprite': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform int useScreenCoordinates;\",\n\t\t\t\"uniform int affectedByDistance;\",\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform float rotation;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform vec2 alignment;\",\n\t\t\t\"uniform vec2 uvOffset;\",\n\t\t\t\"uniform vec2 uvScale;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uvOffset + uv * uvScale;\",\n\n\t\t\t\t\"vec2 alignedPosition = position + alignment;\",\n\n\t\t\t\t\"vec2 rotatedPosition;\",\n\t\t\t\t\"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\n\t\t\t\t\"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\n\n\t\t\t\t\"vec4 finalPosition;\",\n\n\t\t\t\t\"if( useScreenCoordinates != 0 ) {\",\n\n\t\t\t\t\t\"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\n\t\t\t\t\t\"finalPosition.xy += rotatedPosition * ( affectedByDistance == 1 ? 1.0 : finalPosition.z );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = finalPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform vec3 color;\",\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n\nmodule.exports = THREE;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/shared/lib/gcode/three.js\n// module id = ./src/app/shared/lib/gcode/three.js\n// module chunks = main","export function roundTo(value, decimals, f = Math.round) {\r\n  return Number(f(Number(value + 'e' + (-decimals))) + 'e' + decimals);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/lib/round-to.ts","/**\r\n   * standardizes time to show\r\n   * receives input in seconds\r\n   * returns in 'Xd Xh Xm' format\r\n   */\r\nexport function stringizedTime(t) {\r\n  let days, hours, minutes, seconds;\r\n  days = Math.floor(t / 86400);\r\n  t -= days * 86400;\r\n  hours = Math.floor(t / 3600) % 24;\r\n  t -= hours * 3600;\r\n  minutes = Math.floor(t / 60) % 60;\r\n  t -= minutes * 60;\r\n  seconds = t % 60;\r\n\r\n  return [\r\n    days,\r\n    'd ',\r\n    hours,\r\n    'h ',\r\n    minutes,\r\n    'm',\r\n  ].join('');\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/lib/stringedTime.ts","export class ServerMatch {\r\n\r\n  public static STATIC: string = '/static/';\r\n\r\n  /**\r\n   * STATIC is for development-mode\r\n   * But for the server, it's input should be changed to a server static value, which for flask is '/static/'\r\n   * For every image urls, local links, etc. in the application, this must be used before the url\r\n   * e.g.\r\n   *  let imageUrl = ServerMatch.STATIC + 'assets/custom_image.png';\r\n   * \r\n   * \r\n   * CHANGING THIS FOR LOCAL AND SERVER IS DONE AUTOMATICALLY\r\n   */\r\n\r\n  constructor() {}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/servermatch.ts","import {Injectable, OnInit} from '@angular/core';\nimport {HttpService} from './http.service';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\nimport {ThemesEnum} from '../enum/themes.enum';\nimport {PrinterTemperatures} from '../classes/temperatures.interface';\nimport {PrinterSettings} from '../classes/printer-settings.interface';\n\n@Injectable()\nexport class DataService {\n  // IMPORTANT NOTE: REMEMBER!\n  // NEVER EVER implement from onInit in a SERVICE! IT BREAKS!\n\n  ipList = [];\n  usedTheme$ = new BehaviorSubject<ThemesEnum>(ThemesEnum.default);\n  temps$ = new BehaviorSubject<PrinterTemperatures>({bed: {cur: 0, goal: 0}, ext: {cur: 0, goal: 0}});\n  hardwareInfo$ = new BehaviorSubject<any>({});\n  isExtendedBoardConnected$ = new BehaviorSubject<boolean>(null);\n  isFanOn$ = new BehaviorSubject<boolean>(null);\n\n  printerSettings$ = new BehaviorSubject<PrinterSettings>(null);\n\n  // Ask-Before-Start\n  abs = true;\n\n  constructor(private hs: HttpService) {\n    this.getInitialSettings();\n    this.setIntervals();\n    this.getFanStatus();\n  }\n\n  private setIntervals() {\n    this.getTemperatures();\n    setInterval(() => this.getTemperatures(), 2000);\n\n    this.getHardwareInfo();\n    setInterval(() => this.getHardwareInfo(), 4000);\n  }\n\n  private getTemperatures() {\n    this.hs.get('temperatures', {spin: false}).subscribe((data: PrinterTemperatures) => {\n      this.temps$.next(data);\n    });\n  }\n\n  private getHardwareInfo() {\n    this.hs.get('hardware-info', {spin: false}).subscribe(data => {\n      this.hardwareInfo$.next(data);\n    });\n  }\n\n  private getInitialSettings() {\n    this.hs.get('settings', {spin: false}).subscribe((res: PrinterSettings) => {\n      this.printerSettings$.next(res);\n    });\n  }\n\n  public getFanStatus() {\n    this.hs.get('fan_speed', {spin: false}).subscribe(data => {\n      this.isFanOn$.next(!!data['fan']);\n    });\n  }\n\n\n  public setFanStatus(status: boolean) {\n    return new Promise((resolve, reject) => {\n      const statusStr = !status ? 'OFF' : 'ON';\n      this.hs.post('fan_speed', {status: statusStr}, {throwError: true})\n        .subscribe(data => {\n          this.isFanOn$.next(status);\n          resolve();\n        }, err => reject(err));\n    });\n  }\n\n  public setAbs(abs) {\n    return new Promise((resolve, reject) => {\n      this.hs.post('abs', {abs}).subscribe(res => {\n        this.abs = abs;\n      });\n    });\n  }\n\n  public getAbs() {\n    return new Promise((resolve, reject) => {\n      this.hs.get('abs', {throwError: true}).subscribe(res => {\n        this.abs = res['abs'];\n        resolve();\n      }, err => reject(err));\n    });\n  }\n\n  public updateIpList() {\n    return new Promise((resolve, reject) => {\n      this.hs.post('ip', {}, {throwError: true}).subscribe(data => {\n        this.ipList = data['ips'];\n        resolve();\n      }, err => reject(err));\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/data.service.ts","import {Injectable, isDevMode} from '@angular/core';\r\nimport {HttpClient, HttpHeaders} from '@angular/common/http';\r\nimport 'rxjs/add/operator/map';\r\nimport 'rxjs/add/operator/finally';\r\nimport 'rxjs/add/operator/catch';\r\nimport 'rxjs/add/observable/empty';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {SpinnerService} from './spinner.service';\r\nimport {RequestArgument} from '../classes/request-argument.interface';\r\n\r\n@Injectable()\r\nexport class HttpService {\r\n\r\n  public static Host;\r\n  private serverAddress = '/api/';\r\n  defaultRequestArgument: RequestArgument = {\r\n    spin: true\r\n  };\r\n\r\n  constructor(private http: HttpClient, private spins: SpinnerService) {\r\n    HttpService.Host = isDevMode() ? 'http://192.168.1.111' : '';\r\n  }\r\n\r\n  get(url, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    return this.http\r\n      .get(this.serverAddress + url, {observe: 'response'})\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'GET', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  options(url, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    return this.http\r\n      .options(this.serverAddress + url, {observe: 'response'})\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'OPTIONS', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  put(url, values, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    return this.http\r\n      .put(this.serverAddress + url, values, {observe: 'response'})\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'PUT', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  post(url, values, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    return this.http\r\n      .post(this.serverAddress + url, values, {observe: 'response'})\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'POST', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  postFile(url, file, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    const headers = new HttpHeaders();\r\n    const formData = new FormData();\r\n    formData.append('uploadFile', file);\r\n    headers.append('Content-Type', 'multipart/form-data');\r\n    headers.append('enctype', 'multipart/form-data');\r\n    headers.append('Accept', 'application/json');\r\n    return this.http\r\n      .post(HttpService.Host + this.serverAddress + url, formData, {\r\n        headers\r\n        , observe: 'response'\r\n      })\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'POST FILE', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  delete(url, args: RequestArgument = this.defaultRequestArgument): Observable<any> {\r\n    this.enableSpin(args);\r\n    return this.http\r\n      .delete(this.serverAddress + url, {observe: 'response'})\r\n      .map(data => data.body)\r\n      .catch(e => this.catchRequest(e, 'DELETE', url, args.throwError))\r\n      .finally(() => this.finallyRequest(args));\r\n  }\r\n\r\n  enableSpin(args: RequestArgument) {\r\n    if (args.spin)\r\n      this.spins.en(args.spinTimeout);\r\n  }\r\n\r\n  catchRequest(e, method, url, throwError): Observable<any> {\r\n    this.defaultErrorHandler(e, method, url);\r\n\r\n    if (throwError)\r\n      return Observable.throw(e);\r\n    return Observable.empty();\r\n  }\r\n\r\n  finallyRequest(args: RequestArgument) {\r\n    if (args.spin)\r\n      this.spins.dis();\r\n  }\r\n\r\n  defaultErrorHandler(e, method, url) {\r\n    console.debug(`ERROR (${method}) in '${url}':`, e);\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/http.service.ts","import {Injectable} from '@angular/core';\nimport {MatSnackBar} from '@angular/material';\nimport {TranslatorService} from './translator.service';\nimport {MsgType} from '../enum/msgtype.enum';\n\n@Injectable()\nexport class MessageService {\n\n  constructor(private snackbar: MatSnackBar, private trlService: TranslatorService) {}\n\n  open(type: MsgType = MsgType.error, msg?: string) {\n    let panelTypeClass: string;\n    switch (type) {\n      case MsgType.info:\n        panelTypeClass = 'msg-info';\n        if (!msg) msg = 'Successfully Done';\n        break;\n      default: // is error\n        panelTypeClass = 'msg-error';\n        if (!msg) msg = 'Data Could Not Be Loaded';\n        break;\n    }\n\n    this.snackbar.open(this.trlService.lookup(msg), null,\n      {\n        duration: 2400,\n        extraClasses: `font-${this.trlService.lang$.getValue()}`,\n        panelClass: [panelTypeClass, `font-${this.trlService.lang$.getValue()}`],\n      });\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/message.service.ts","import {Injectable} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\nimport {HttpService} from './http.service';\nimport {PrintStatus} from '../enum/print-status.enum';\nimport {PrintSpeed} from '../classes/print-speed.interface';\nimport {DataService} from './data.service';\n\n@Injectable()\nexport class PrintService {\n  onPrintPage$ = new BehaviorSubject<boolean>(false);\n  printStatus$ = new BehaviorSubject<PrintStatus>(PrintStatus.printing);\n  printPercent$ = new BehaviorSubject<number>(0);\n  zPosition$ = new BehaviorSubject<number>(0);\n  printSpeed$ = new BehaviorSubject<PrintSpeed>({feedrate: 100, flow: 100});\n  printTime$ = new BehaviorSubject<number>(0);\n\n  // a local client-specific to show that we're on the print page or not.\n  // this is different from onPrintPage$ and has the following usage.\n  // when the print is finished, the onPrintPage$ might immediately be set to false\n  // and therefore a dialog opens and says you are in an inaccessible page.\n  // however, if a new client joins, he mustn't be redirected to print page and must\n  // stay in home (etc.) page. and when showing inaccessible page dialog, we must check\n  // this variable that for the active clients, they should not be redirected to home\n  // page implicitly without completion dialog, but others should stay in home page!\n  // changes:\n  // is set to true  if anyhow onPrintPage be true\n  // is set to false only after leaving print page\n  isActivePrint = false;\n\n  // TODO: check for filament finished\n  shouldCheckForFilament = false;\n  filamentStatus$ = new BehaviorSubject<boolean>(null);\n\n  constructor(private hs: HttpService, private ds: DataService) {\n    this.setIntervals();\n    setTimeout(() => this.checkSettings());\n  }\n\n  private checkSettings() {\n    this.ds.printerSettings$.subscribe(res => {\n      if (!res) return;\n      this.shouldCheckForFilament = res.filament;\n    });\n  }\n\n  private setIntervals() {\n    this.getOnPrintPage();\n    setInterval(() => this.getOnPrintPage(), 6000);\n\n    this.updateTermsBasedOnPrintPage();\n  }\n\n  private updateTermsBasedOnPrintPage() {\n    let percentAndZInterval;\n    let timeInterval;\n    this.onPrintPage$.subscribe(isOnPrintPage => {\n      if (isOnPrintPage) {\n        this.getUsualPrintInfo();\n        this.getTime();\n        percentAndZInterval = setInterval(() => this.getUsualPrintInfo(), 5000);\n        timeInterval = setInterval(() => this.getTime(), 1 * 60 * 1000);\n      } else {\n        if (percentAndZInterval)\n          clearInterval(percentAndZInterval);\n        if (timeInterval)\n          clearInterval(timeInterval);\n\n        // get the final values\n        this.getUsualPrintInfo();\n        this.getTime();\n      }\n    });\n  }\n\n  private getUsualPrintInfo() {\n    this.getPercentAndZ();\n    this.getPauseStatus();\n    this.getPrintSpeed();\n\n    if (this.shouldCheckForFilament)\n      this.checkFilament();\n  }\n\n  getPauseStatus() {\n    this.hs.post('interaction', {pkey: 'print_status'}, {spin: false}).subscribe(data => {\n      if (data['pvalue'] === undefined || data['pvalue'] === null)\n        return;\n\n      // pvalue is number, whilst isPaused is of PrintStatus type\n      if (data['pvalue'] === this.printStatus$.getValue())\n        return;\n\n      this.printStatus$.next(data['pvalue']);\n    });\n  }\n\n  private getPercentAndZ() {\n    this.hs.post('print', {action: 'percentage'}, {spin: false}).subscribe(data => {\n      this.printPercent$.next(data['percentage']);\n    });\n    this.hs.get('get_z', {spin: false}).subscribe(data => {\n      this.zPosition$.next(data['z']);\n    });\n  }\n\n  private getTime() {\n    this.hs.get('get_time', {spin: false}).subscribe(data => {\n      this.printTime$.next(data['time']);\n    });\n  }\n\n  // also call when print speed changes\n  public getPrintSpeed() {\n    this.hs.get('speed', {spin: false}).subscribe((data: PrintSpeed) => {\n      this.printSpeed$.next(data);\n    });\n  }\n\n  // NOTE: it only updates filamentStatus$ only if the value changes!\n  private checkFilament() {\n    // const preVal = this.filamentStatus$.getValue();\n    this.hs.get('filament', {spin: false}).subscribe(data => {\n      const newVal = data && data['filament_flag'];\n      // if (newVal === preVal)\n        // return;\n\n      this.filamentStatus$.next(newVal);\n    });\n  }\n\n  // NOTE: it only updates onPrintPage$ value if the value changes\n  // so e.g. three (true, true, true) would only emit 'true' once!\n  private getOnPrintPage() {\n    const preVal = this.onPrintPage$.getValue();\n    this.hs.post('on_print_page', {}, {spin: false}).subscribe(data => {\n      const newVal = data && data['page'] === 'print';\n      if (newVal === preVal)\n        return;\n\n      this.onPrintPage$.next(newVal);\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/print.service.ts","import {Injectable} from '@angular/core';\nimport {ReplaySubject} from 'rxjs/ReplaySubject';\n\nexport enum ProgressModeEnum {\n  determinate = 'determinate',\n  indeterminate = 'indeterminate',\n  buffer = 'buffer',\n  query = 'query',\n}\n\n@Injectable()\nexport class ProgressService {\n  progressModeEnum = ProgressModeEnum;\n  showProgress: ReplaySubject<boolean> = new ReplaySubject(1);\n  progressMode: ReplaySubject<any> = new ReplaySubject(1);\n  progressValue: ReplaySubject<number> = new ReplaySubject(1);\n  progressBufferValue: ReplaySubject<number> = new ReplaySubject(1);\n\n  constructor() {\n    this.showProgress.next(false);\n\n    // Set default values\n    this.progressMode.next(this.progressModeEnum.indeterminate);\n    this.progressValue.next(50);\n    this.progressBufferValue.next(null);\n  }\n\n  enable() {\n    this.showProgress.next(true);\n  }\n\n  disable() {\n    this.showProgress.next(false);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/progress.service.ts","import {Injectable} from '@angular/core';\r\nimport * as io from 'socket.io-client';\r\nimport {Observable} from 'rxjs/observable';\r\n\r\n@Injectable()\r\nexport class SocketService {\r\n  private url = 'http://localhost';\r\n  private socketConfig = {\r\n    transports: ['websocket']\r\n  };\r\n  private socket: SocketIOClient.Socket;\r\n\r\n  // private orderLineSocket;\r\n\r\n  // private orderLineObsevable = new Observable(observer => {\r\n  //   this.orderLineSocket.on('ans', (data) => {\r\n  //     observer.next(data);\r\n  //   });\r\n  // });\r\n\r\n  constructor() {\r\n    // this.socket = io(this.url);//, this.socketConfig);\r\n\r\n    // this.socket.emit('message', {message: 'hi'});\r\n    // this.socket.on('message', msg => {\r\n    //   console.log('received from socket: ', msg);\r\n    //   // setTimeout(() => this.socket.emit('message', {message: 'hello'}), 1000);\r\n    // });\r\n  }\r\n\r\n  // public init() {\r\n  //   this.orderLineSocket = io(this.url + '/orderline', this.socketConfig);\r\n  // }\r\n\r\n  // getOrderLineMessage() {\r\n  //   return this.orderLineObsevable;\r\n  // }\r\n\r\n  // disconnect() {\r\n  //   this.orderLineSocket.disconnect();\r\n  // }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/socket.service.ts","import {Injectable} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\n\n@Injectable()\nexport class SpinnerService {\n  // all the \"en\"ed spinners must be \"dis\"ed\n  // in order to disable spinner block ui\n  // if not, it will be disabled automatically\n  // after the default timeout seconds' passed\n  spin$ = new BehaviorSubject<boolean>(false);\n  count = 0;\n  timeoutCount = 0;\n  defaultTimeout = 5;\n\n  constructor() {\n  }\n\n  // activates spinner (with timeout (seconds))\n  en(timeoutSeconds = this.defaultTimeout) {\n    this.count++;\n    this.timeoutCount++;\n\n    this.spin$.next(true);\n\n    setTimeout(() => this.checkError(), timeoutSeconds * 1000);\n  }\n\n  // deactivates spinner\n  dis() {\n    this.count--;\n    if (this.count <= 0) {\n      this.spin$.next(false);\n      this.count = 0;\n    }\n  }\n\n  // check error after timeout\n  checkError() {\n    this.timeoutCount--;\n    console.debug(`(Count: ${this.count}, TimeoutCount: ${this.timeoutCount})`);\n    if (this.timeoutCount > 0)\n      return;\n\n    if (this.count <= 0)\n      return;\n\n    console.error(\"spinner timeout is passed. disabling...\");\n    this.spin$.next(false);\n    this.timeoutCount = 0;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/spinner.service.ts","import {Injectable, OnInit} from '@angular/core';\nimport {HttpService} from './http.service';\nimport {HttpClient} from '@angular/common/http';\nimport {ServerMatch} from '../servermatch';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\n\n@Injectable()\nexport class TranslatorService {\n  /**\n   * For adding support for a new language, you just need to create a '<language-name>.json' file\n   * in the 'assets/languages' folder, having the keys from a sample '.json' file with the translated values.\n   * The rest is taken care of automatically by the program!\n   *\n   * You might need to add specific font for your language. In that case, head over to 'styles.scss'\n   * and add a new class with name e.g. 'font-<language-name>' with corresponding font and styles.\n   */\n  languages = ['en']; // this is the default language\n  lang$ = new BehaviorSubject<string>(this.languages[0]);\n  dict = {};\n\n  constructor(private hs: HttpService, private http: HttpClient) {\n    this.getLanguageList();\n  }\n\n  // this function is used when we need instant translated word,\n  // trl component is used when we need constant translated word\n  lookup(word) {\n    if (this.dict.hasOwnProperty(word)) {\n      return this.dict[word];\n    } else {\n      return word;\n    }\n  }\n\n  getLanguageList() {\n    this.hs.get('language-list').subscribe(langs => {\n      this.languages = langs['languages']\n      this.getCurrentLanguage();\n    });\n  }\n\n  getCurrentLanguage() {\n    this.hs.post('interaction', {pkey: 'lang'}).subscribe(data => {\n      if (!this.languages.includes(data['pvalue'])) {\n        console.error(\"language is not supported!\");\n        return;\n      }\n\n      this.changeLanguageTo(data['pvalue']);\n    });\n  }\n\n  changeLanguageTo(lng) {\n    if (lng === this.lang$.getValue()) {\n      console.log(`language '${lng}' is already active!`);\n      return;\n    }\n\n    this.hs.put('interaction', {pkey: 'lang', pvalue: lng}).subscribe(res => {\n      this.http.get(`${ServerMatch.STATIC}assets/languages/${lng}.json`).subscribe(data => {\n        this.dict = data;\n        this.lang$.next(lng);\n      }, err => {\n        if (lng === 'en') { // if set to default lang (i.e. en) from another lang\n          this.dict = {};\n          this.lang$.next(lng);\n          return;\n        }\n        console.error(\"could not load corresponding json language file: \", err);\n      });\n    });\n  }\n\n  direction() {\n    return this.dict && this.dict['dir'] || 'ltr';\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/translator.service.ts","import {Injectable} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\nimport {HttpService} from './http.service';\n\n@Injectable()\nexport class ViewerService {\n\n  printFileDir$ = new BehaviorSubject<string>(null);\n  fileGcodeLink$ = new BehaviorSubject<string>(null);\n  gcodeIndex$ = new BehaviorSubject<number>(100);\n\n  constructor(private hs: HttpService) {\n  }\n\n  updateGcodeLink(link) {\n    if (!link) {\n      this.fileGcodeLink$.next(null);\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const oldLink = this.fileGcodeLink$.getValue();\n      if (!link)\n        link = oldLink;\n      this.hs.put('interaction', {pkey: 'gcode_downloadable_link', pvalue: link}, {spin: false, throwError: true}).subscribe(data => {\n        if (link === oldLink)\n          return;\n\n        this.fileGcodeLink$.next(link);\n        resolve();\n      }, err => {\n        reject();\n      });\n    });\n  }\n\n  getGcodeLink() {\n    this.hs.post('interaction', {pkey: 'gcode_downloadable_link'}).subscribe(data => {\n      this.fileGcodeLink$.next(data['pvalue']);\n    });\n  }\n\n  updatePrintFileDir(dir) {\n    return new Promise((resolve, reject) => {\n      this.hs.put('interaction', {pkey: 'print_file_dir', pvalue: dir}, {spin: false, throwError: true}).subscribe(data => {\n        this.printFileDir$.next(dir);\n        resolve();\n      }, err => {\n        reject();\n      });\n    });\n  }\n\n  getPrintFileDir() {\n    this.hs.post('interaction', {pkey: 'print_file_dir'}).subscribe(data => {\n      this.printFileDir$.next(data['pvalue']);\n    });\n  }\n\n  setGcodeIndex(idx = 100) {\n    if (idx < 0 || idx > 100)\n      return;\n\n    this.gcodeIndex$.next(idx);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/viewer.service.ts","import {Injectable} from '@angular/core';\r\nimport {BehaviorSubject} from 'rxjs/BehaviorSubject';\r\n\r\nfunction _window() {\r\n  return window;\r\n}\r\n\r\n@Injectable()\r\nexport class WindowService {\r\n  curWidth$ = new BehaviorSubject<number>(this.getWindow().innerWidth);\r\n  curHeight$ = new BehaviorSubject<number>(this.getWindow().innerHeight);\r\n  isMobile = false;\r\n\r\n  constructor() {\r\n    this.curWidth$.subscribe(w => {\r\n      this.isMobile = w < 960;\r\n    });\r\n  }\r\n\r\n  checkIsMobile() {\r\n    return this.curWidth$.getValue() < 960;\r\n  }\r\n\r\n  getWindow() {\r\n    return _window();\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/shared/services/window.service.ts","module.exports = \"<ng-template>\\n  <div>\\n    <!-- <div fxLayout=\\\"row\\\" fxLayout.xs=\\\"column\\\" fxLayoutAlign=\\\"start center\\\">\\n        <div fxFlex=\\\"40\\\">\\n          <p>sample clicking button:</p>\\n        </div>\\n        <div fxFlex=\\\"10\\\">\\n          <button mat-mini-fab color=\\\"primary\\\" (click)=\\\"normalClick()\\\">\\n            <mat-icon>\\n              done\\n            </mat-icon>\\n          </button>\\n        </div>\\n        <div fxFlex=\\\"50\\\">\\n          {{answer}}\\n        </div>\\n      </div>\\n      <div fxLayout=\\\"row\\\" fxLayout.xs=\\\"column\\\" fxLayoutAlign=\\\"start center\\\">\\n        <div fxFlex=\\\"40\\\">\\n          <p>sample async clicking button:</p>\\n        </div>\\n        <div fxFlex=\\\"10\\\">\\n          <button mat-mini-fab color=\\\"primary\\\" (click)=\\\"asyncClick()\\\">\\n            <i class=\\\"fa fa-eraser\\\"></i>\\n          </button>\\n        </div>\\n        <div fxFlex=\\\"50\\\">\\n          {{answerAsync}}\\n        </div>\\n      </div> -->\\n    <!-- <mat-sidenav-container class=\\\"example-container\\\">\\n        <mat-sidenav mode=\\\"side\\\" opened>Sidenav content</mat-sidenav>\\n        <mat-sidenav-content>Main content</mat-sidenav-content>\\n      </mat-sidenav-container> -->\\n    <app-upload-file></app-upload-file>\\n    <app-progress></app-progress>\\n    <button mat-button color=\\\"primary\\\">Button</button>\\n    <button mat-button color=\\\"accent\\\">Button</button>\\n    <button mat-button color=\\\"warn\\\">Button</button>\\n    <button mat-raised-button color=\\\"primary\\\">Button</button>\\n    <button mat-raised-button color=\\\"accent\\\">Button</button>\\n    <button mat-raised-button color=\\\"warn\\\">Button</button>\\n    <button mat-flat-button color=\\\"primary\\\">Button</button>\\n    <button mat-flat-button color=\\\"accent\\\">Button</button>\\n    <button mat-flat-button color=\\\"warn\\\">Button</button>\\n    <button mat-stroked-button color=\\\"primary\\\">Button</button>\\n    <button mat-stroked-button color=\\\"accent\\\">Button</button>\\n    <button mat-stroked-button color=\\\"warn\\\">Button</button>\\n    <mat-toolbar color=\\\"primary\\\">\\n      <mat-toolbar-row>\\n        <span>Custom Toolbar</span>\\n      </mat-toolbar-row>\\n\\n      <mat-toolbar-row>\\n        <span>Second Line</span>\\n        <span class=\\\"example-spacer\\\"></span>\\n        <mat-icon class=\\\"example-icon\\\">verified_user</mat-icon>\\n      </mat-toolbar-row>\\n\\n      <mat-toolbar-row>\\n        <span>Third Line</span>\\n        <span class=\\\"example-spacer\\\"></span>\\n        <mat-icon class=\\\"example-icon\\\">favorite</mat-icon>\\n        <mat-icon class=\\\"example-icon\\\">delete</mat-icon>\\n      </mat-toolbar-row>\\n    </mat-toolbar>\\n    <p class=\\\"font-persian\\\">یک متن نمونه</p>\\n    <div class=\\\"font-english\\\">\\n      <p>A sample Text</p>\\n    </div>\\n    <button mat-icon-button [matMenuTriggerFor]=\\\"menu\\\">\\n      <mat-icon>more_vert</mat-icon>\\n    </button>\\n    <mat-menu #menu=\\\"matMenu\\\">\\n      <button mat-menu-item>\\n        <mat-icon>dialpad</mat-icon>\\n        <span>Redial</span>\\n      </button>\\n      <button mat-menu-item disabled>\\n        <mat-icon>voicemail</mat-icon>\\n        <span>Check voicemail</span>\\n      </button>\\n      <button mat-menu-item>\\n        <mat-icon>notifications_off</mat-icon>\\n        <span>Disable alerts</span>\\n      </button>\\n    </mat-menu>\\n    <mat-card class=\\\"example-card\\\" matRipple>\\n      <mat-card-header>\\n        <div mat-card-avatar class=\\\"example-header-image\\\"></div>\\n        <mat-card-title>Shiba Inu</mat-card-title>\\n        <mat-card-subtitle>Dog Breed</mat-card-subtitle>\\n      </mat-card-header>\\n      <img mat-card-image src=\\\"https://material.angular.io/assets/img/examples/shiba2.jpg\\\" alt=\\\"Photo of a Shiba Inu\\\">\\n      <mat-card-content>\\n        <p>\\n          The Shiba Inu is the smallest of the six original and distinct spitz breeds of dog from Japan.\\n          A small, agile dog that copes very well with mountainous terrain, the Shiba Inu was originally\\n          bred for hunting.\\n        </p>\\n      </mat-card-content>\\n      <mat-card-actions>\\n        <button mat-button>LIKE</button>\\n        <button mat-button>SHARE</button>\\n      </mat-card-actions>\\n    </mat-card>\\n    <div>Every-3D-things' going to happen here:</div>\\n    <div style=\\\"\\n          width: 400px;\\n          height: 400px;\\n          margin-left: 100px;\\n          margin-top: 100px;\\n          border: 1px solid grey;\\n        \\\">\\n      <router-outlet></router-outlet>\\n    </div>\\n  </div>\\n</ng-template>\\n\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Stages'\\\"></ptrl>\\n</h4>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"40\\\" class=\\\"stage-wrapper\\\" (click)=\\\"bedLevelOnStage(1)\\\">\\n    <button mat-button class=\\\"stage-item\\\">1</button>\\n  </div>\\n  <div fxFlex=\\\"40\\\" class=\\\"stage-wrapper\\\" (click)=\\\"bedLevelOnStage(2)\\\">\\n    <button mat-button class=\\\"stage-item\\\">2</button>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"40\\\" class=\\\"stage-wrapper\\\" (click)=\\\"bedLevelOnStage(3)\\\">\\n    <button mat-button class=\\\"stage-item\\\">3</button>\\n  </div>\\n  <div fxFlex=\\\"40\\\" class=\\\"stage-wrapper\\\" (click)=\\\"bedLevelOnStage(4)\\\">\\n    <button mat-button class=\\\"stage-item\\\">4</button>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/bedlevel/bedlevel.component.html\n// module id = ./src/app/site/bedlevel/bedlevel.component.html\n// module chunks = main","module.exports = \".stage-wrapper {\\n  margin: 8px; }\\n\\n.stage-item {\\n  width: 100%;\\n  height: 200px;\\n  font-size: 3em;\\n  border: 8px solid grey; }\\n\\n.example-card {\\n  max-width: 400px; }\\n\\n.example-header-image {\\n  background-image: url(\\\"https://material.angular.io/assets/img/examples/shiba1.jpg\\\");\\n  background-size: cover; }\\n\\n.example-icon {\\n  padding: 0 14px; }\\n\\n.example-spacer {\\n  -webkit-box-flex: 1;\\n      -ms-flex: 1 1 auto;\\n          flex: 1 1 auto; }\\n\\n.example-container {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  background: #eee; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/bedlevel/bedlevel.component.scss\n// module id = ./src/app/site/bedlevel/bedlevel.component.scss\n// module chunks = main","import {Component, OnInit} from '@angular/core';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {MessageService} from 'app/shared/services/message.service';\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\nimport {PageBase} from 'app/shared/classes/page-base.class';\n\n@Component({\n  selector: 'app-bedlevel',\n  templateUrl: './bedlevel.component.html',\n  styleUrls: ['./bedlevel.component.scss']\n})\nexport class BedlevelComponent extends PageBase implements OnInit {\n\n  constructor(private hs: HttpService, private ms: MessageService) {\n    super('Bedleveling');\n  }\n\n  ngOnInit() {\n  }\n\n  bedLevelOnStage(stage) {\n    this.hs.post('bedleveling', {stage}).subscribe(res => {\n      this.ms.open(MsgType.info);\n    });\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/bedlevel/bedlevel.component.ts","module.exports = \"<br>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Offset'\\\"></ptrl>\\n  </div>\\n  <div fxFlex=\\\"150px\\\" class=\\\"centerize\\\">\\n    <ptrl [text]=\\\"'Feedrate'\\\"></ptrl>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" class=\\\"centerize\\\">\\n    <mat-slider color=\\\"primary\\\" [thumbLabel]=\\\"true\\\" [vertical]=\\\"true\\\" [min]=\\\"1\\\" [max]=\\\"10\\\" [step]=\\\"1\\\" [tickInterval]=\\\"2\\\"\\n      class=\\\"offset-slider\\\" [(ngModel)]=\\\"value\\\">\\n    </mat-slider>\\n  </div>\\n  <div fxFlex=\\\"150px\\\" class=\\\"centerize\\\">\\n    <mat-slider color=\\\"primary\\\" [thumbLabel]=\\\"true\\\" [vertical]=\\\"true\\\" [min]=\\\"250\\\" [max]=\\\"1500\\\" [step]=\\\"250\\\"\\n      [tickInterval]=\\\"2\\\" class=\\\"offset-slider\\\" [(ngModel)]=\\\"feedrate\\\">\\n    </mat-slider>\\n  </div>\\n</div>\\n<br>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple (click)=\\\"extrude(false)\\\" class=\\\"card-base-shorter\\\">\\n      <img mat-card-image [src]=\\\"upImage\\\">\\n    </mat-card>\\n  </div>\\n  <div fxFlex=\\\"150px\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple (click)=\\\"extrude(true)\\\" class=\\\"card-base-shorter\\\">\\n      <img mat-card-image [src]=\\\"downImage\\\">\\n    </mat-card>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/extruder/extruder.component.html\n// module id = ./src/app/site/extruder/extruder.component.html\n// module chunks = main","module.exports = \".offset-slider {\\n  height: 200px;\\n  width: 56px;\\n  padding: 0 !important; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/extruder/extruder.component.scss\n// module id = ./src/app/site/extruder/extruder.component.scss\n// module chunks = main","import {Component, OnInit} from '@angular/core';\nimport {PageBase} from 'app/shared/classes/page-base.class';\nimport {DataService} from 'app/shared/services/data.service';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {MatDialog} from '@angular/material';\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\nimport {DialogType} from 'app/shared/enum/dialog.enum';\nimport {Router} from '@angular/router';\nimport {MessageService} from 'app/shared/services/message.service';\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\nimport {ServerMatch} from 'app/shared/servermatch';\n\n@Component({\n  selector: 'app-extruder',\n  templateUrl: './extruder.component.html',\n  styleUrls: ['./extruder.component.scss']\n})\nexport class ExtruderComponent extends PageBase implements OnInit {\n  value = 2;\n  feedrate = 500;\n  injected = 0;\n\n  upImage;\n  downImage;\n\n  constructor(private ds: DataService, private hs: HttpService,\n    private dialog: MatDialog, private router: Router,\n    private ms: MessageService) {\n    super('Extrude');\n\n    this.upImage = ServerMatch.STATIC + 'assets/up.png';\n    this.downImage = ServerMatch.STATIC + 'assets/down.png';\n  }\n\n  ngOnInit() {\n    this.checkInitialTemperature();\n  }\n\n  checkInitialTemperature() {\n    setTimeout(() => {\n      if (this.ds.temps$.getValue().ext['cur'] < 178) {\n        this.dialog.open(GenericDialogComponent, {\n          data: {\n            usage: DialogType.needPreheating,\n          }\n        }).afterClosed().subscribe(res => {\n          this.router.navigate(['/home']);\n        });\n      }\n    });\n  }\n\n  extrude(out = false) {\n    const extrudeValue = out ? this.value : -this.value;\n    this.hs.post('extrude', {\n      value: extrudeValue,\n      feedrate: this.feedrate\n    }).subscribe(res => {\n      this.injected += extrudeValue;\n      this.ms.open(MsgType.info);\n    });\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/extruder/extruder.component.ts","module.exports = \"<!-- DASHBOARD -->\\n<mat-card>\\n  <mat-card-header class=\\\"card-name-header\\\">\\n    <mat-card-title>\\n      <ptrl [text]=\\\"'Dashboard'\\\"></ptrl>\\n    </mat-card-title>\\n  </mat-card-header>\\n  <mat-card-content class=\\\"card-content-center\\\">\\n    <ptrl *ngIf=\\\"!notifs.length\\\" [text]=\\\"'No New Notifications'\\\"></ptrl>\\n    <mat-card *ngFor=\\\"let notif of notifs; let i = index\\\" (click)=\\\"openNotif(i)\\\" class=\\\"notif-card\\\">\\n      <mat-card-header class=\\\"card-name-header\\\">\\n        <mat-card-title>\\n          <ptrl [text]=\\\"notif.title\\\"></ptrl>\\n        </mat-card-title>\\n      </mat-card-header>\\n      <mat-card-content>\\n        <ptrl [text]=\\\"notif.desc\\\"></ptrl>\\n      </mat-card-content>\\n    </mat-card>\\n  </mat-card-content>\\n</mat-card>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Choose Entry -->\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"40px\\\">\\n    <button mat-icon-button (click)=\\\"getEntries()\\\">\\n      <mat-icon>refresh</mat-icon>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"200px\\\">\\n    <h4 class=\\\"title\\\">\\n      <ptrl [text]=\\\"'Choose Entry'\\\"></ptrl>\\n    </h4>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" *ngFor=\\\"let usb of entries; let l = last;\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple (click)=\\\"changeEntry(usb)\\\" class=\\\"card-base\\\" [class.active-item]=\\\"selectedEntry === usb\\\"\\n      style=\\\"height: 220px;\\\">\\n      <mat-card-header class=\\\"card-name-header\\\">\\n        <mat-card-title>\\n          <ptrl [text]=\\\"usb\\\"></ptrl>\\n        </mat-card-title>\\n      </mat-card-header>\\n      <img mat-card-image [src]=\\\"l ? uploadImage : usbImage\\\" alt=\\\"usb\\\">\\n    </mat-card>\\n  </div>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Upload File -->\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Upload File'\\\"></ptrl>\\n</h4>\\n<div class=\\\"uploader-center\\\">\\n  <app-upload-file (onsubmit)=\\\"getEntries(); getUploadedFiles();\\\"></app-upload-file>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Choose File -->\\n<h4 class=\\\"title scroll-to\\\" id=\\\"fileitems\\\" #fileitems>\\n  <ptrl [text]=\\\"'Choose File'\\\"></ptrl>\\n</h4>\\n<div fxLayout=\\\"column\\\" class=\\\"mat-elevation-z8 hide-cd-overflow\\\">\\n  <div>\\n    <button mat-icon-button matTooltip=\\\"Back\\\" (click)=\\\"changeDir(cd, false)\\\"\\n      [disabled]=\\\"selectedEntry === cd || selectedEntry.toLowerCase() === 'uploads'\\\">\\n      <mat-icon>arrow_back</mat-icon>\\n    </button>\\n    <span class=\\\"word-wrap\\\">{{cd}}</span>\\n  </div>\\n  <div>\\n    <mat-table #table [dataSource]=\\\"dataSource\\\">\\n      <ng-container matColumnDef=\\\"type\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column\\\">\\n          <ptrl [text]=\\\"'Type'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column\\\">\\n          <mat-icon [color]=\\\"item.type === 'folder' ? 'primary' : ''\\\" [class.file-icon-color]=\\\"item.type === 'file'\\\">\\n            {{item.type === 'file' ? 'insert_drive_file' : 'folder'}}\\n          </mat-icon>\\n        </mat-cell>\\n      </ng-container>\\n      <ng-container matColumnDef=\\\"name\\\" matRipple>\\n        <mat-header-cell *matHeaderCellDef>\\n          <ptrl [text]=\\\"'Name'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\">{{item.name}}</mat-cell>\\n      </ng-container>\\n      <ng-container matColumnDef=\\\"view\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column-wider\\\">3D View</mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column-wider\\\">\\n          <button *ngIf=\\\"item.type !== 'folder'\\\" mat-icon-button class=\\\"success\\\" (click)=\\\"viewItem($event, item)\\\">\\n            <mat-icon>visibility</mat-icon>\\n          </button>\\n        </mat-cell>\\n      </ng-container>\\n      <ng-container matColumnDef=\\\"delete\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column\\\">Delete</mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column\\\">\\n          <button *ngIf=\\\"isUpload()\\\" mat-icon-button color=\\\"warn\\\" (click)=\\\"deleteItem($event, item)\\\">\\n            <mat-icon>delete</mat-icon>\\n          </button>\\n        </mat-cell>\\n      </ng-container>\\n      <mat-header-row *matHeaderRowDef=\\\"displayedColumns\\\"></mat-header-row>\\n      <mat-row *matRowDef=\\\"let row; columns: displayedColumns;\\\" (click)=\\\"selectItem(row)\\\" class=\\\"table-row\\\"\\n        [class.active-item]=\\\"isSelected(row)\\\" [class.mat-elevation-z16]=\\\"isSelected(row)\\\"></mat-row>\\n    </mat-table>\\n    <mat-paginator #paginator [pageSize]=\\\"5\\\" [pageSizeOptions]=\\\"[3, 5, 10]\\\" [showFirstLastButtons]=\\\"false\\\"\\n      class=\\\"paginator-go-behind\\\">\\n    </mat-paginator>\\n  </div>\\n</div>\\n<div [class.print-button-wrapper]=\\\"ws.isMobile\\\" *ngIf=\\\"!ws.isMobile || (ws.isMobile && shouldPrintButtonBeActive())\\\">\\n  <button class=\\\"print-button\\\" mat-raised-button [disabled]=\\\"!shouldPrintButtonBeActive()\\\" color=\\\"primary\\\"\\n    (click)=\\\"makePrint()\\\" [class.mat-elevation-z24]=\\\"shouldPrintButtonBeActive()\\\">\\n    <ptrl [text]=\\\"'Print'\\\"></ptrl>\\n  </button>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- 3d Viewer -->\\n<div #view3d id=\\\"view3d\\\"></div>\\n<button mat-icon-button (click)=\\\"scrollToPos('fileitems'); clearGcodeLink();\\\" class=\\\"upward-button\\\"\\n  [class.hide-area]=\\\"!modelFileLink\\\">\\n  <mat-icon>arrow_upward</mat-icon>\\n</button>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/home/home.component.html\n// module id = ./src/app/site/home/home.component.html\n// module chunks = main","module.exports = \".notif-card {\\n  cursor: pointer;\\n  -webkit-box-shadow: 0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);\\n          box-shadow: 0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12); }\\n\\n.notif-card:hover {\\n  -webkit-box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);\\n          box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12); }\\n\\n.uploader-center {\\n  margin-left: calc(50% - 155px); }\\n\\n.table-column {\\n  max-width: 15%; }\\n\\n.table-column-wider {\\n  max-width: 20%; }\\n\\n.print-button {\\n  width: 100%;\\n  height: 60px;\\n  margin-top: 5px;\\n  font-size: 1.4em; }\\n\\n.print-button-wrapper {\\n  position: fixed;\\n  bottom: 0;\\n  width: 100%;\\n  left: 0;\\n  z-index: 2; }\\n\\n.upward-button {\\n  background-color: rebeccapurple;\\n  width: 4em;\\n  height: 4em; }\\n\\n.hide-cd-overflow {\\n  overflow: hidden; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/home/home.component.scss\n// module id = ./src/app/site/home/home.component.scss\n// module chunks = main","import {Component, OnInit, ViewChild, ElementRef} from '@angular/core';\nimport {PageBase} from 'app/shared/classes/page-base.class';\nimport {ServerMatch} from 'app/shared/servermatch';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {ScrollToService} from '@nicky-lenaers/ngx-scroll-to';\nimport {WindowService} from 'app/shared/services/window.service';\nimport {MatTableDataSource, MatPaginator, MatDialog} from '@angular/material';\nimport {DataService} from 'app/shared/services/data.service';\nimport {SpinnerService} from 'app/shared/services/spinner.service';\nimport {MessageService} from 'app/shared/services/message.service';\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\nimport {DialogType} from 'app/shared/enum/dialog.enum';\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\nimport {ViewerService} from 'app/shared/services/viewer.service';\nimport {Router} from '@angular/router';\nimport {PrintService} from 'app/shared/services/print.service';\nimport {DashboardNotification} from 'app/shared/classes/notification.interface';\n\nconst GCODE_EXT = '.gcode';\nconst UPLOAD_PROTOCOL = 'upload://';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent extends PageBase implements OnInit {\n  // should have the same name for scrolling to work\n  // mobile uses first name, standalone uses second!\n  @ViewChild('fileitems') fileitems: ElementRef;\n  @ViewChild('view3d') view3d: ElementRef;\n\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n\n  usbImage;\n  uploadImage;\n\n  cd = '';\n  entries = [];\n  selectedEntry = '';\n  notifs: DashboardNotification[] = [];\n\n\n  // from the length of this, we can determine if we're in uploaded or usb\n  // 'delete' is disabled for usbs\n  // 'view' is disabled for folders\n  // 'type' is either 'file' (i.e. gcode file) or 'folder'\n  displayedColumns = ['type', 'name', 'view', /*, 'delete' -> only for uploads */];\n  dataSource = new MatTableDataSource();\n  // the couple of (type, name) is unique\n  selectedFile = {type: '', name: ''};\n\n  // this is the link for the up button to become visible\n  modelFileLink = '';\n\n  // used for temporary storing unfinished print info (cd, line, etc.)\n  tempUnfinishedPrintInfo;\n\n  constructor(private hs: HttpService, private scrollSer: ScrollToService,\n    public ws: WindowService, private ds: DataService,\n    private spins: SpinnerService, private dialog: MatDialog,\n    private ms: MessageService, private vs: ViewerService,\n    private router: Router, private ps: PrintService) {\n    super('Main Page');\n    this.usbImage = ServerMatch.STATIC + 'assets/usb.png';\n    this.uploadImage = ServerMatch.STATIC + 'assets/cloud_upload.png';\n  }\n\n  ngOnInit() {\n    this.getEntries();\n    this.initTable();\n\n    this.vs.fileGcodeLink$.subscribe(link => {\n      this.modelFileLink = link;\n    });\n\n    this.tempUnfinishedPrintInfo = {cd: '', line: 0};\n    this.checkNotifications();\n  }\n\n  initTable() {\n    setTimeout(() => {\n      this.dataSource.data = [];\n      this.paginator._intl.itemsPerPageLabel = \"\";\n      this.dataSource.paginator = this.paginator;\n    });\n  }\n\n  checkNotifications() {\n    // - unfinished notif\n    this.ds.getAbs().then(() => {\n      if (this.ds.abs)\n        return Promise.resolve(false);\n      return Promise.resolve(true);\n    }).then(shouldPrintInstantly => {\n      return this.getUnfinishedInfo().then(res => {\n        this.tempUnfinishedPrintInfo = res;\n\n        if (shouldPrintInstantly) {\n          this.callPrint(this.tempUnfinishedPrintInfo['cd'], this.tempUnfinishedPrintInfo['line']);\n          return;\n        }\n\n        this.notifs.push({\n          title: 'You have an unfinished print!',\n          desc: 'Tap here for more info',\n          action: this.checkForUnfinishedPrint,\n        });\n      });\n    }).catch(err => console.log(err));\n\n  }\n\n  openNotif(i) {\n    this.notifs[i].action.apply(this);\n    this.notifs.splice(i, 1);\n  }\n\n  checkForUnfinishedPrint() {\n    this.showUnfinishedDialog(this.tempUnfinishedPrintInfo['cd']).then(res => {\n      if (!res) {\n        this.hs.delete('print').subscribe();\n        return;\n      }\n\n      this.callPrint(this.tempUnfinishedPrintInfo['cd'], this.tempUnfinishedPrintInfo['line']);\n    }).catch(err => console.log(err));\n  }\n\n  getUnfinishedInfo() {\n    return new Promise((resolve, reject) => {\n      this.hs.post('print', {action: 'unfinished'}, {spin: false, throwError: true}).subscribe(res => {\n        if (!res['unfinished']['exist'])\n          reject('no unfinished print');\n        resolve({\n          cd: res['unfinished']['cd'],\n          line: res['unfinished']['line']\n        });\n      }, err => reject(err));\n    });\n  }\n\n  showUnfinishedDialog(cd) {\n    return new Promise((resolve, reject) => {\n      if (this.dialog.openDialogs.length)\n        return reject('already open dialog');\n\n      this.dialog.open(GenericDialogComponent, {\n        data: {\n          usage: DialogType.askForUnfinishedPrint,\n          cd\n        }\n      }).afterClosed().subscribe(res => {\n        return resolve(res);\n      });\n    });\n  }\n\n  async viewItem($event, item) {\n    await this.vs.updateGcodeLink(this.makeModelDir(item.name));\n    setTimeout(() => {\n      this.scrollToPos('view3d');\n    }, 500);\n  }\n\n  selectItem(item) {\n    // change dir for usbs\n    if (this.selectedEntry && !this.isUpload())\n      this.changeDir(item.name, true);\n\n    this.selectedFile = item;\n\n    // uploaded files don't need to be approved as a valid gcode file\n    if (this.isUpload())\n      this.approveGCode();\n  }\n\n  deleteItem($event, item) {\n    $event.stopPropagation();\n    if (this.selectedFile.name === item.name)\n      this.clearSelectedFile();\n\n    this.dialog.open(GenericDialogComponent, {\n      data: {\n        usage: DialogType.confirmDelete\n      }\n    }).afterClosed().subscribe(res => {\n      if (!res) return;\n\n      this.hs.delete(`upload-file/${item.name}`).subscribe(data => {\n        this.ms.open(MsgType.info);\n        this.getUploadedFiles();\n      });\n    });\n  }\n\n  makePrint() {\n    let printFileDir = '';\n    if (this.isUpload()) {\n      printFileDir = UPLOAD_PROTOCOL + this.selectedFile.name;\n    } else {\n      printFileDir = this.cd + '/' + this.selectedFile.name;\n    }\n\n    const dialog = this.dialog.open(GenericDialogComponent, {\n      data: {\n        usage: DialogType.confirmPrint,\n        name: this.selectedFile.name,\n      }\n    });\n    // dialog.afterOpen().subscribe(res => {\n    //   this.vs.updatePrintFileDir(printFileDir);\n    // });\n    dialog.afterClosed().subscribe(res => {\n      if (!res) return;\n\n      this.callPrint(printFileDir);\n    });\n  }\n\n  callPrint(cd, line = 0) {\n    this.hs.post('print', {cd, line, action: 'print'}).subscribe(data => {\n      // navigate to print page as a new print is started\n      this.ps.isActivePrint = true;\n      this.router.navigate(['/print-page']);\n\n      // temporarily set this to true\n      // to avoid inaccessible page error\n      // this.ps.onPrintPage$.next(true);\n    });\n  }\n\n  changeEntry(ent) {\n    this.selectedEntry = ent;\n    this.cd = '';\n    this.clearSelectedFile();\n\n    if (this.isUpload())\n      this.getUploadedFiles();\n    else\n      this.changeDir(ent);\n  }\n\n  // folders use (<folder-name>, true)\n  // back use (cd, false)\n  // files use (<file-name>, true) -> if file truthy detected, print button will become active\n  // for upload, print button will become active and cd will change to 'upload://<file-name>'\n  changeDir(dir, isAdd = true) {\n    if (!dir || dir === '')\n      return;\n\n    // clear selection\n    this.clearSelectedFile();\n\n    // if just entry selected, scroll to fileitems\n    if (this.cd === '')\n      this.scrollToPos('fileitems');\n\n    let newDir = this.cd;\n    if (isAdd) {\n      newDir += (newDir ? '/' : '') + dir;\n    } else {\n      const tempDir = dir.split('/');\n      newDir = tempDir.splice(0, tempDir.length - 1).join('/');\n    }\n\n    this.hs.post('directory', {cd: newDir}, {spin: this.cd === ''}).subscribe(data => {\n      if (data && data.type === 'file') {\n        this.approveGCode();\n      } else {\n        this.cd = newDir;\n        this.dataSource.data = this.makeData(data.data, false);\n      }\n    });\n  }\n\n  scrollToPos(sc) {\n    // each method worked in either mobile or standalone, not both!  :|\n    // so functionality needed to be splitted to work cross-platformly!\n    if (this.ws.isMobile) {\n      // this.fileitemshtml.nativeElement.scrollIntoView({behavior: 'smooth', block: 'start', inline: 'nearest'});\n      window.scroll({\n        top: this[sc].nativeElement.offsetTop,\n        behavior: 'smooth'\n      });\n    } else {\n      this.scrollSer.scrollTo({\n        target: sc\n      });\n    }\n    // if (window.scrollY)\n    // window.scroll(0, window.scrollY - 56);\n  }\n\n  // gets the list of usbs (+ upload place)\n  getEntries() {\n    return this.hs.post('directory', {cd: ''}).subscribe(res => {\n      if (res.data.length === 0 || (res.data.length === 1 && res.data[0] === '')) {\n        this.entries = [];\n      } else {\n        this.entries = res.data;\n        this.entries.push('Uploads');\n      }\n    });\n  }\n\n  getUploadedFiles() {\n    this.hs.get('upload-file').subscribe(res => {\n      this.dataSource.data = this.makeData(res.files, true);\n      this.scrollToPos('fileitems');\n    });\n  }\n\n  private makeData(data, isUpload = false) {\n    const res = [];\n    data.forEach(el => {\n      res.push({\n        'name': el,\n        'type': isUpload || el.endsWith(GCODE_EXT) ? 'file' : 'folder'\n      });\n    });\n\n    this.displayedColumns = ['type', 'name', 'view'];\n    if (isUpload) this.displayedColumns.push('delete');\n\n    return res;\n  }\n\n  makeModelDir(name) {\n    let modelLink = HttpService.Host + '/api/download/';\n\n    if (this.isUpload())\n      modelLink += `files/${name}`;\n    else\n      modelLink += `usbs/${this.cd}/${name}`;\n\n    return modelLink;\n  }\n\n  clearSelectedFile() {\n    this.selectedFile = {\n      type: '',\n      name: ''\n    };\n    this.clearGcodeLink();\n  }\n\n  approveGCode() {\n    this.selectedFile['gcode-approved'] = true;\n  }\n\n  isGCodeApproved() {\n    return this.selectedFile['gcode-approved'] || false;\n  }\n\n  isUpload() {\n    return this.selectedEntry.toLowerCase() === 'uploads';\n  }\n\n  isFile(file) {\n    return file.endsWith(GCODE_EXT);\n  }\n\n  isSelected(row) {\n    return this.selectedFile.type === 'file' && this.selectedFile.name === row.name;\n  }\n\n  shouldPrintButtonBeActive() {\n    return (this.selectedFile && this.selectedFile.type === 'file' && this.isGCodeApproved());\n  }\n\n  clearGcodeLink() {\n    this.vs.updateGcodeLink(null);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/home/home.component.ts","module.exports = \"<div fxLayout=\\\"column\\\" class=\\\"mat-elevation-z8 hide-cd-overflow\\\">\\n  <div>\\n    <h4 class=\\\"title\\\">\\n      <ptrl [text]=\\\"'Recent Prints'\\\"></ptrl>\\n    </h4>\\n  </div>\\n  <div>\\n    <mat-table #table [dataSource]=\\\"dataSource\\\">\\n      <ng-container matColumnDef=\\\"num\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column-narrow\\\">\\n          <ptrl [text]=\\\"'Num'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column-narrow\\\">\\n          {{item.num}}\\n        </mat-cell>\\n      </ng-container>\\n\\n      <ng-container matColumnDef=\\\"file_name\\\">\\n        <mat-header-cell *matHeaderCellDef>\\n          <ptrl [text]=\\\"'Name'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\">\\n          {{item.file_name}}\\n        </mat-cell>\\n      </ng-container>\\n\\n      <ng-container matColumnDef=\\\"filament_type\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column\\\">\\n          <ptrl [text]=\\\"'Filament'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column\\\">\\n          {{item.filament_type}}\\n        </mat-cell>\\n      </ng-container>\\n\\n      <ng-container matColumnDef=\\\"time\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column\\\">\\n          <ptrl [text]=\\\"'Time'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column\\\">\\n          {{item.time}}\\n        </mat-cell>\\n      </ng-container>\\n\\n      <ng-container matColumnDef=\\\"temperature\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column-wider\\\">\\n          <ptrl [text]=\\\"'Temperature'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column-wider\\\">\\n          {{item.temperature}}\\n        </mat-cell>\\n      </ng-container>\\n\\n      <ng-container matColumnDef=\\\"is_finished\\\">\\n        <mat-header-cell *matHeaderCellDef class=\\\"table-column-narrow\\\">\\n          <ptrl [text]=\\\"'Finished'\\\"></ptrl>\\n        </mat-header-cell>\\n        <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column-narrow\\\">\\n          <mat-icon *ngIf=\\\"item.is_finished === 'Yes'\\\">check</mat-icon>\\n          <mat-icon *ngIf=\\\"item.is_finished === 'No'\\\">clear</mat-icon>\\n        </mat-cell>\\n      </ng-container>\\n\\n      <mat-header-row *matHeaderRowDef=\\\"displayedColumns\\\"></mat-header-row>\\n      <mat-row *matRowDef=\\\"let row; columns: displayedColumns;\\\" class=\\\"table-row\\\"></mat-row>\\n    </mat-table>\\n\\n    <mat-paginator #paginator [pageSize]=\\\"5\\\" [pageSizeOptions]=\\\"[3, 5, 10]\\\" [showFirstLastButtons]=\\\"false\\\"\\n      class=\\\"paginator-go-behind\\\">\\n    </mat-paginator>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/last-prints/last-prints.component.html\n// module id = ./src/app/site/last-prints/last-prints.component.html\n// module chunks = main","module.exports = \".table-column-narrow {\\n  max-width: 10%; }\\n\\n.table-column {\\n  max-width: 15%; }\\n\\n.table-column-wider {\\n  max-width: 20%; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/last-prints/last-prints.component.scss\n// module id = ./src/app/site/last-prints/last-prints.component.scss\n// module chunks = main","import {Component, OnInit, ViewChild} from '@angular/core';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {MatTableDataSource, MatPaginator} from '@angular/material';\nimport {stringizedTime} from 'app/shared/lib/stringedTime';\nimport {PrintInfo} from 'app/shared/classes/print-info.interface';\nimport {PageBase} from 'app/shared/classes/page-base.class';\n\n@Component({\n  selector: 'app-last-prints',\n  templateUrl: './last-prints.component.html',\n  styleUrls: ['./last-prints.component.scss']\n})\nexport class LastPrintsComponent extends PageBase implements OnInit {\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n  displayedColumns = ['num', 'file_name', 'filament_type', 'time', 'temperature', 'is_finished'];\n  dataSource = new MatTableDataSource();\n\n  constructor(private hs: HttpService) {\n    super('Recent Prints');\n  }\n\n  ngOnInit() {\n    this.initTable();\n    this.getLastPrints();\n  }\n\n  initTable() {\n    setTimeout(() => {\n      this.paginator._intl.itemsPerPageLabel = \"\";\n      this.dataSource.paginator = this.paginator;\n    }, 0);\n  }\n\n  getLastPrints() {\n    this.hs.get('last_prints').subscribe((res: PrintInfo[]) => {\n      if (!res) return;\n\n      res.forEach((el, i) => {\n        el['num'] = i + 1;\n        el['time'] = stringizedTime(el['time']);\n        if (!el.hasOwnProperty('filament_type'))\n          el['filament_type'] = 'PLA Test';\n        // el['is_finished'] = this.capitalizeFirstLetter(el['is_finished']);\n      });\n      this.dataSource.data = res;\n    });\n  }\n\n  capitalizeFirstLetter(string: String) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/last-prints/last-prints.component.ts","module.exports = \"<!-- General Info -->\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Info'\\\"></ptrl>\\n</h4>\\n<div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"40\\\">\\n    <div class=\\\"title\\\">\\n      <ptrl [text]=\\\"'File Name'\\\"></ptrl>\\n    </div>\\n    <div class=\\\"title word-wrap\\\">\\n      {{fileDir || 'Unknown'}}\\n    </div>\\n  </div>\\n  <div fxFlex=\\\"25\\\" fxFlexOffset=\\\"10%\\\">\\n    <div class=\\\"title\\\">\\n      <ptrl [text]=\\\"'Time'\\\"></ptrl>\\n    </div>\\n    <div class=\\\"title\\\">\\n      {{printTime}}\\n    </div>\\n  </div>\\n  <div fxFlex=\\\"25\\\">\\n    <div class=\\\"title\\\">\\n      <ptrl [text]=\\\"'Z'\\\"></ptrl>\\n    </div>\\n    <div class=\\\"title\\\">\\n      {{zPos}}\\n    </div>\\n  </div>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Status = Percent + Pause/Stop -->\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Status'\\\"></ptrl>\\n</h4>\\n<div>\\n  <div class=\\\"progress progress-wrapper\\\">\\n    <div class=\\\"progress-bar progress-bar-striped progress-bar-animated\\\" role=\\\"progressbar\\\" aria-valuemin=\\\"0\\\"\\n      aria-valuemax=\\\"100\\\" [style.width.%]=\\\"percent || 0\\\">\\n      <div class=\\\"font-en progress-inside\\\">\\n        <i>{{percent || 0}}%</i>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple class=\\\"card-base-shorter\\\" (click)=\\\"changePauseState()\\\">\\n      <img mat-card-image [src]=\\\"(printStatus === printStatusEnum.paused ? playImage : pauseImage)\\\">\\n    </mat-card>\\n  </div>\\n  <div fxFlex=\\\"150px\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple class=\\\"card-base-shorter\\\" (click)=\\\"stopPrint()\\\">\\n      <img mat-card-image [src]=\\\"stopImage\\\">\\n    </mat-card>\\n  </div>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Speed Part -->\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Speed'\\\"></ptrl>\\n</h4>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center center\\\" class=\\\"speed-slider-container\\\">\\n  <div fxFlex=\\\"150px\\\" fxLayout=\\\"column\\\">\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <ptrl [text]=\\\"'Flow'\\\"></ptrl>\\n    </div>\\n    <div fxFlex=\\\"20%\\\">\\n      <span>{{maxSpeed['flow']}}%</span>\\n    </div>\\n    <div fxFlex=\\\"20%\\\">\\n      <mat-slider color=\\\"primary\\\" class=\\\"speed-slider\\\" (click)=\\\"$event.stopPropagation(); $event.preventDefault();\\\"\\n        (change)=\\\"changePrintSpeedSlider('flow')\\\" [max]=\\\"maxSpeed['flow']\\\" [min]=\\\"minSpeed['flow']\\\" [step]=\\\"10\\\"\\n        [thumbLabel]=\\\"true\\\" [tickInterval]=\\\"2\\\" [(ngModel)]=\\\"printSpeed['flow']\\\" [vertical]=\\\"true\\\">\\n      </mat-slider>\\n    </div>\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <span>{{minSpeed['flow']}}%</span>\\n    </div>\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <button mat-raised-button (click)=\\\"resetPrintSpeed('flow')\\\">\\n        <ptrl [text]=\\\"'Reset'\\\"></ptrl>\\n      </button>\\n    </div>\\n  </div>\\n\\n  <div fxFlex=\\\"150px\\\" fxLayout=\\\"column\\\">\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <ptrl [text]=\\\"'Feedrate'\\\"></ptrl>\\n    </div>\\n    <div fxFlex=\\\"20%\\\">\\n      <span>{{maxSpeed['feedrate']}}%</span>\\n    </div>\\n    <div fxFlex=\\\"20%\\\">\\n      <mat-slider color=\\\"primary\\\" class=\\\"speed-slider\\\" (click)=\\\"$event.stopPropagation(); $event.preventDefault();\\\"\\n        (change)=\\\"changePrintSpeedSlider('feedrate')\\\" [max]=\\\"maxSpeed['feedrate']\\\" [min]=\\\"minSpeed['feedrate']\\\"\\n        [step]=\\\"10\\\" [thumbLabel]=\\\"true\\\" [tickInterval]=\\\"2\\\" [(ngModel)]=\\\"printSpeed['feedrate']\\\" [vertical]=\\\"true\\\">\\n      </mat-slider>\\n    </div>\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <span>{{minSpeed['feedrate']}}%</span>\\n    </div>\\n    <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\n      <button mat-raised-button (click)=\\\"resetPrintSpeed('feedrate')\\\">\\n        <ptrl [text]=\\\"'Reset'\\\"></ptrl>\\n      </button>\\n    </div>\\n  </div>\\n</div>\\n\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/print-page/print-page.component.html\n// module id = ./src/app/site/print-page/print-page.component.html\n// module chunks = main","module.exports = \".collapse, .collapse.in {\\n  display: block !important;\\n  -webkit-transition: all .25s ease-in-out;\\n  transition: all .25s ease-in-out; }\\n\\n.collapse {\\n  opacity: 0;\\n  height: 0; }\\n\\n.collapse.in {\\n  opacity: 1;\\n  height: 100%; }\\n\\n.progress-inside {\\n  font-size: 30px;\\n  position: relative; }\\n\\n.progress-wrapper {\\n  height: 32px; }\\n\\n.action-button-icon {\\n  font-size: 150px; }\\n\\n.speed-slider-container {\\n  margin-top: 1em;\\n  text-align: center; }\\n\\n.margin-bottom {\\n  margin-bottom: 16px; }\\n\\n.speed-slider {\\n  height: 200px;\\n  width: 56px;\\n  padding: 0 !important; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/print-page/print-page.component.scss\n// module id = ./src/app/site/print-page/print-page.component.scss\n// module chunks = main","import {Component, OnInit, OnDestroy} from '@angular/core';\nimport {DataService} from 'app/shared/services/data.service';\nimport {PageBase} from 'app/shared/classes/page-base.class';\nimport {ViewerService} from 'app/shared/services/viewer.service';\nimport {MatDialog} from '@angular/material';\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\nimport {PrintService} from 'app/shared/services/print.service';\nimport {Router} from '@angular/router';\nimport {stringizedTime} from '../../shared/lib/stringedTime';\nimport {DialogType} from 'app/shared/enum/dialog.enum';\nimport {ServerMatch} from 'app/shared/servermatch';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {PrintStatus} from 'app/shared/enum/print-status.enum';\nimport {PrintSpeed} from 'app/shared/classes/print-speed.interface';\nimport {roundTo} from 'app/shared/lib/round-to';\n\n@Component({\n  selector: 'app-print-page',\n  templateUrl: './print-page.component.html',\n  styleUrls: ['./print-page.component.scss']\n})\nexport class PrintPageComponent extends PageBase implements OnInit, OnDestroy {\n  playImage;\n  pauseImage;\n  stopImage;\n\n  percent = 0;\n  zPos = 0;\n  fileDir = '';\n  printTime = '0d 0h 0m';\n  filamentFinished = false;\n\n  printStatusEnum = PrintStatus;\n  printStatus: PrintStatus = PrintStatus.printing;\n\n  printSpeed: PrintSpeed = {feedrate: 100, flow: 100};\n  minSpeed: PrintSpeed = {feedrate: 0, flow: 0};\n  maxSpeed: PrintSpeed = {feedrate: 200, flow: 200};\n  limitSpeedChange: PrintSpeed = {feedrate: 0, flow: 0};\n\n  constructor(private ds: DataService, private vs: ViewerService,\n    private dialog: MatDialog, private ps: PrintService,\n    private router: Router, private hs: HttpService) {\n    super('Print');\n    this.playImage = ServerMatch.STATIC + 'assets/play.png';\n    this.pauseImage = ServerMatch.STATIC + 'assets/pause.png';\n    this.stopImage = ServerMatch.STATIC + 'assets/stop.png';\n  }\n\n  ngOnInit() {\n    this.ps.printStatus$.next(PrintStatus.printing);\n\n    setTimeout(() => {\n      this.checkPercentage();\n      this.checkFileAndGcodeDirs();\n      this.checkPrintTime();\n      this.checkPrintStatus();\n      this.checkZPos();\n      this.checkPrintSpeed();\n      this.checkFilament();\n    });\n  }\n\n  checkFileAndGcodeDirs() {\n    this.vs.getGcodeLink();\n    this.vs.getPrintFileDir();\n    this.vs.fileGcodeLink$.subscribe(dat => {\n      this.vs.setGcodeIndex(this.percent);\n    });\n    this.vs.printFileDir$.subscribe(dir => {\n      if (!dir) return;\n      this.fileDir = dir;\n    });\n  }\n\n  checkPercentage() {\n    this.ps.printPercent$.subscribe(perc => {\n      // happens if go to print-page with hand!\n      if (this.percent === 0 && perc === 100) {\n        return;\n      }\n\n      this.percent = perc;\n      this.vs.setGcodeIndex(this.percent);\n\n      if (this.percent === 100)\n        this.printCompletion();\n    });\n  }\n\n  checkPrintStatus() {\n    this.ps.printStatus$.subscribe(st => {\n      this.printStatus = st;\n\n      if (this.printStatus === PrintStatus.idle) {\n        // only when the print is stopped by someone else we\n        // come here, and we should only go to the home page\n        this.router.navigate(['/home']);\n\n        // just temporarily set PrintPage to false, in order to\n        // make up for the delay till its next update iteration\n        this.ps.onPrintPage$.next(false);\n      }\n    });\n  }\n\n  checkPrintTime() {\n    this.ps.printTime$.subscribe(t => {\n      if (!t) return;\n      this.printTime = stringizedTime(t);\n    });\n  }\n\n  checkZPos() {\n    this.ps.zPosition$.subscribe(z => {\n      this.zPos = z;\n    });\n  }\n\n  checkPrintSpeed() {\n    this.ps.printSpeed$.subscribe(speed => {\n      this.printSpeed = speed;\n      Object.keys(this.printSpeed).forEach(el => this.updateMinMax(el));\n    });\n  }\n\n  checkFilament() {\n    this.ps.filamentStatus$.subscribe(filamentFinished => {\n      this.filamentFinished = filamentFinished;\n\n      if (!filamentFinished)\n        return;\n\n      if (this.printStatus === this.printStatusEnum.paused)\n        return;\n\n      if (this.dialog.openDialogs.length)\n        return;\n\n      this.changePauseState();\n      this.dialog.open(GenericDialogComponent, {\n        data: {\n          usage: DialogType.filamentFinished,\n        }\n      });\n    });\n  }\n\n\n\n  resetPrintSpeed(field) {\n    this.changePrintSpeed(field, 100);\n  }\n\n  changePrintSpeedSlider(field) {\n    if (this.limitSpeedChange[field]) {\n      this.printSpeed = this.ps.printSpeed$.getValue();\n      return;\n    }\n\n    this.setSpeedChangeLimit(field);\n    this.changePrintSpeed(field, this.printSpeed[field]);\n    this.updateMinMax(field);\n  }\n\n  changePrintSpeed(field, value) {\n    this.hs.post('speed', {field: (field === 'feedrate' ? 'print' : 'flow'), value}, {spin: false}).subscribe(data => {\n      this.printSpeed[field] = value;\n      this.ps.getPrintSpeed();\n    });\n  }\n\n  updateMinMax(field) {\n    this.minSpeed[field] = roundTo(Math.abs(this.printSpeed[field] - 50), 2, Math.floor);\n    this.maxSpeed[field] = roundTo(this.printSpeed[field] + 50, 2, Math.ceil);\n  }\n\n  setSpeedChangeLimit(field) {\n    this.limitSpeedChange[field] = 500;\n    setTimeout(() => {\n      this.limitSpeedChange[field] = 0;\n    }, 500);\n  }\n\n\n\n  changePauseState() {\n    const isPaused = this.printStatus === PrintStatus.paused;\n\n    // if (isPaused && this.filamentFinished) {\n    //   this.dialog.open(GenericDialogComponent, {\n    //     data: {\n    //       usage: DialogType.filamentFinished\n    //     }\n    //   });\n    //   return;\n    // }\n\n    this.hs.post('print', {action: isPaused ? 'resume' : 'pause'}).subscribe(data => {\n      // set instantly to true, and then in the next\n      // iterate, it will get real true from server!\n      // btw, this value is truthy. If the request was successfull, the value\n      // would change (so would in the server) and if it fails, it stays the\n      // same. This is just to make up for the delay between this request and\n      // the next printStatus update in the print service, not a false assumption!\n      if (isPaused)\n        this.printStatus = PrintStatus.printing;\n      else\n        this.printStatus = PrintStatus.paused;\n    });\n  }\n\n  stopPrint() {\n    this.dialog.open(GenericDialogComponent, {\n      data: {\n        usage: DialogType.confirmStopPrint,\n      }\n    }).afterClosed().subscribe(res => {\n      if (!res) return;\n\n      this.hs.post('print', {action: 'stop'}).subscribe(data => {\n        this.router.navigate(['/home']);\n      });\n    });\n  }\n\n\n\n  printCompletion() {\n    if (this.dialog.openDialogs.length)\n      return;\n\n    this.dialog.open(GenericDialogComponent, {\n      data: {\n        usage: DialogType.printCompleted,\n        fileDir: this.fileDir,\n        time: this.printTime,\n      }\n    }).afterClosed().subscribe(res => {\n      this.router.navigate(['/home']);\n    });\n  }\n\n  ngOnDestroy() {\n    this.ps.isActivePrint = false;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/print-page/print-page.component.ts","module.exports = \"<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'General Settings'\\\"></ptrl>\\n</h4>\\n<form (ngSubmit)=\\\"submit()\\\" [formGroup]=\\\"settingsForm\\\" [dir]=\\\"trl.direction()\\\">\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'view3d'\\\">\\n    <ptrl title [text]=\\\"'Show 3D Model'\\\"></ptrl>\\n    <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"view3d\\\">\\n    </mat-slide-toggle>\\n  </app-form-item>\\n\\n  <!-- Super Cool Usage Of ng-template/ng-content/ng-container in one place! -->\\n  <ng-template #rotate_template let-disabled=\\\"view3d.value\\\">\\n    <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'rotate'\\\">\\n      <ptrl title [text]=\\\"'Rotate 3D Model'\\\"></ptrl>\\n      <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"rotate\\\" [disabled]=\\\"!disabled\\\">\\n      </mat-slide-toggle>\\n    </app-form-item>\\n  </ng-template>\\n  <ng-container *ngTemplateOutlet=\\\"rotate_template; context: settingsForm.controls\\\"></ng-container>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'abs'\\\">\\n    <ptrl title [text]=\\\"'Ask Before Print'\\\"></ptrl>\\n    <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"abs\\\">\\n    </mat-slide-toggle>\\n  </app-form-item>\\n\\n  <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'timelapse'\\\">\\n    <ptrl title [text]=\\\"'Take Timelapse'\\\"></ptrl>\\n    <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"timelapse\\\">\\n    </mat-slide-toggle>\\n  </app-form-item>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'filament'\\\">\\n    <ptrl title [text]=\\\"'Use Sensor Filament'\\\"></ptrl>\\n    <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"filament\\\">\\n    </mat-slide-toggle>\\n  </app-form-item>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'lcd'\\\">\\n    <ptrl title [text]=\\\"'LCD Existence'\\\"></ptrl>\\n    <mat-slide-toggle control color=\\\"warn\\\" formControlName=\\\"lcd\\\">\\n    </mat-slide-toggle>\\n  </app-form-item>\\n\\n  <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'width'\\\">\\n    <ptrl title [text]=\\\"'Printer Width'\\\"></ptrl>\\n    <mat-form-field control style=\\\"width: 100px;\\\">\\n      <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"width\\\" />\\n    </mat-form-field>\\n  </app-form-item>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'height'\\\">\\n    <ptrl title [text]=\\\"'Printer Height'\\\"></ptrl>\\n    <mat-form-field control style=\\\"width: 100px;\\\">\\n      <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"height\\\" />\\n    </mat-form-field>\\n  </app-form-item>\\n\\n  <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'extruders'\\\">\\n    <ptrl title [text]=\\\"'Extruder Number'\\\"></ptrl>\\n    <mat-form-field control style=\\\"width: 100px;\\\">\\n      <mat-select color=\\\"primary\\\" formControlName=\\\"extruders\\\">\\n        <mat-option [value]=\\\"1\\\">1</mat-option>\\n        <mat-option [value]=\\\"2\\\">2</mat-option>\\n      </mat-select>\\n    </mat-form-field>\\n  </app-form-item>\\n\\n  <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n  <mat-accordion>\\n    <mat-expansion-panel>\\n      <mat-expansion-panel-header style=\\\"padding-top: 16px;\\\">\\n        <mat-panel-title style=\\\"justify-content: center;\\\">\\n          <h4 class=\\\"title\\\">\\n            <ptrl [text]=\\\"'Advanced Settings'\\\"></ptrl>\\n          </h4>\\n        </mat-panel-title>\\n      </mat-expansion-panel-header>\\n\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'serial_port'\\\">\\n        <ptrl title [text]=\\\"'Serial Port'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput color=\\\"primary\\\" formControlName=\\\"serial_port\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'baudrate'\\\">\\n        <ptrl title [text]=\\\"'Baudrate'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"baudrate\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n      <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n      <h4 class=\\\"title\\\">\\n        <ptrl [text]=\\\"'Bedleveling'\\\"></ptrl>\\n      </h4>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_X1'\\\">\\n        <ptrl title [text]=\\\"'X1 Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_X1\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_X2'\\\">\\n        <ptrl title [text]=\\\"'X2 Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_X2\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_Y1'\\\">\\n        <ptrl title [text]=\\\"'Y1 Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_Y1\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_Y2'\\\">\\n        <ptrl title [text]=\\\"'Y2 Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_Y2\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'traveling_feedrate'\\\">\\n        <ptrl title [text]=\\\"'Travelling Feedrate'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"traveling_feedrate\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_Z_offset'\\\">\\n        <ptrl title [text]=\\\"'Z Offset'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_Z_offset\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'bedleveling_Z_move_feedrate'\\\">\\n        <ptrl title [text]=\\\"'Z Move Feedrate'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"bedleveling_Z_move_feedrate\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n      <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n      <h4 class=\\\"title\\\">\\n        <ptrl [text]=\\\"'Hibernate'\\\"></ptrl>\\n      </h4>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'hibernate_Z_offset'\\\">\\n        <ptrl title [text]=\\\"'Z Offset'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"hibernate_Z_offset\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'hibernate_Z_move_feedrate'\\\">\\n        <ptrl title [text]=\\\"'Z Move Feedrate'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"hibernate_Z_move_feedrate\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n      <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n      <h4 class=\\\"title\\\">\\n        <ptrl [text]=\\\"'Pause'\\\"></ptrl>\\n      </h4>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'pause_Z_offset'\\\">\\n        <ptrl title [text]=\\\"'Z Offset'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"pause_Z_offset\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'pause_Z_move_feedrate'\\\">\\n        <ptrl title [text]=\\\"'Z Move Feedrate'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"pause_Z_move_feedrate\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'X_pause_position'\\\">\\n        <ptrl title [text]=\\\"'X Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"X_pause_position\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'Y_pause_position'\\\">\\n        <ptrl title [text]=\\\"'Y Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"Y_pause_position\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n      <mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n      <h4 class=\\\"title\\\">\\n        <ptrl [text]=\\\"'Timelapse'\\\"></ptrl>\\n      </h4>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'X_timelapse_position'\\\">\\n        <ptrl title [text]=\\\"'X Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"X_timelapse_position\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n      <app-form-item [form]=\\\"settingsForm\\\" [name]=\\\"'Y_timelapse_position'\\\">\\n        <ptrl title [text]=\\\"'Y Position'\\\"></ptrl>\\n        <mat-form-field control style=\\\"width: 100px;\\\">\\n          <input matInput type=\\\"number\\\" color=\\\"primary\\\" formControlName=\\\"Y_timelapse_position\\\" />\\n        </mat-form-field>\\n      </app-form-item>\\n\\n    </mat-expansion-panel>\\n  </mat-accordion>\\n\\n  <br>\\n  <button mat-raised-button color=\\\"primary\\\" type=\\\"submit\\\" style=\\\"width: 100%;\\\" aria-hidden=\\\"true\\\"\\n    [disabled]=\\\"!settingsForm.valid || !anyChanges\\\">\\n    <ptrl [text]=\\\"'Confirm'\\\"></ptrl>\\n  </button>\\n</form>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/settings/settings.component.html\n// module id = ./src/app/site/settings/settings.component.html\n// module chunks = main","module.exports = \".item {\\n  cursor: help;\\n  text-align: center;\\n  margin-bottom: 8px;\\n  padding: 8px 0; }\\n\\n.item:hover {\\n  background: rgba(255, 255, 255, 0.04); }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/settings/settings.component.scss\n// module id = ./src/app/site/settings/settings.component.scss\n// module chunks = main","import {Component, OnInit} from '@angular/core';\nimport {PageBase} from 'app/shared/classes/page-base.class';\nimport {FormGroup, FormBuilder, Validators} from '@angular/forms';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {PrinterSettings} from 'app/shared/classes/printer-settings.interface';\nimport {TranslatorService} from 'app/shared/services/translator.service';\nimport {NEEDS_REFRESH, NEEDS_RESTART} from 'app/shared/consts/settings-after-action.const';\nimport {MatDialog} from '@angular/material';\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\nimport {DialogType} from 'app/shared/enum/dialog.enum';\n\n@Component({\n  selector: 'app-settings',\n  templateUrl: './settings.component.html',\n  styleUrls: ['./settings.component.scss']\n})\nexport class SettingsComponent extends PageBase implements OnInit {\n  settingsForm: FormGroup;\n  settingsLastSaved: PrinterSettings;\n  anyChanges = false;\n\n  constructor(private hs: HttpService, public trl: TranslatorService,\n    private dialog: MatDialog) {\n    super(\"Settings\");\n  }\n\n  ngOnInit() {\n    this.initForm();\n    this.getInitialSettingsInfo();\n    this.settingsForm.valueChanges.subscribe(fields => this.fieldChanged(fields));\n  }\n\n  getInitialSettingsInfo() {\n    this.hs.get('settings').subscribe((res: PrinterSettings) => {\n      this.settingsLastSaved = res;\n      this.anyChanges = false;\n      Object.keys(res).forEach(el => {\n        this.settingsForm.controls[el].setValue(res[el]);\n      });\n    });\n  }\n\n  initForm() {\n    this.settingsForm = new FormBuilder().group({\n      view3d: [false],\n      rotate: [{value: false}],\n      abs: [false],\n      timelapse: [false],\n      filament: [false],\n      lcd: [false],\n      width: [0, [Validators.required]],\n      height: [0, [Validators.required]],\n      extruders: [1, [Validators.required]],\n      serial_port: ['/dev/ttyUSB0', [Validators.required]],\n      baudrate: [250000, [Validators.required]],\n      printing_buffer: [15, [Validators.required]],\n      bedleveling_X1: [50, [Validators.required]],\n      bedleveling_X2: [180, [Validators.required]],\n      bedleveling_Y1: [50, [Validators.required]],\n      bedleveling_Y2: [180, [Validators.required]],\n      traveling_feedrate: [3000, [Validators.required]],\n      bedleveling_Z_offset: [10, [Validators.required]],\n      bedleveling_Z_move_feedrate: [1500, [Validators.required]],\n      hibernate_Z_offset: [5, [Validators.required]],\n      hibernate_Z_move_feedrate: [1500, [Validators.required]],\n      pause_Z_offset: [10, [Validators.required]],\n      pause_Z_move_feedrate: [1500, [Validators.required]],\n      X_pause_position: [0, [Validators.required]],\n      Y_pause_position: [0, [Validators.required]],\n      X_timelapse_position: [0, [Validators.required]],\n      Y_timelapse_position: [0, [Validators.required]],\n    });\n  }\n\n  fieldChanged(fields = null) {\n    if (!fields) {\n      fields = Object.keys(this.settingsForm.controls).reduce((a, b) => {\n        a[b] = this.settingsForm.controls[b].value;\n        return a;\n      }, {});\n    }\n    if (!this.settingsLastSaved)\n      return;\n    this.anyChanges = Object\n      .keys(fields)\n      .some(el => fields[el] !== this.settingsLastSaved[el]);\n  }\n\n  submit() {\n    const changedFields = {};\n    Object.keys(this.settingsLastSaved).forEach(el => {\n      const originalValue = this.settingsLastSaved[el];\n      const formValue = this.settingsForm.controls[el].value;\n      if (originalValue !== formValue) {\n        changedFields[el] = formValue;\n      }\n    });\n    this.hs.post('settings', changedFields).subscribe(data => {\n      let needsRefresh = false, needsRestart = false;\n      Object.keys(changedFields).forEach(el => {\n        // update new values\n        this.settingsLastSaved[el] = changedFields[el];\n\n        // check the need for refresh/restart\n        needsRefresh = needsRefresh || NEEDS_REFRESH.some(ref => ref === el);\n        needsRestart = needsRestart || NEEDS_RESTART.some(res => res === el);\n      });\n      this.fieldChanged();\n\n      // notify user if refresh/restart needed\n      if (!needsRefresh && !needsRestart)\n        return;\n      this.dialog.open(GenericDialogComponent, {\n        data: {\n          usage: DialogType.afterSettings,\n          needsRefresh, needsRestart\n        }\n      });\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/settings/settings.component.ts","module.exports = \".main-container {\\r\\n  display: -webkit-box;\\r\\n  display: -ms-flexbox;\\r\\n  display: flex;\\r\\n  -webkit-box-orient: vertical;\\r\\n  -webkit-box-direction: normal;\\r\\n      -ms-flex-direction: column;\\r\\n          flex-direction: column;\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  bottom: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  -webkit-user-select: none;\\r\\n     -moz-user-select: none;\\r\\n      -ms-user-select: none;\\r\\n          user-select: none;\\r\\n}\\r\\n\\r\\n.main-toolbar {\\r\\n  position: fixed;\\r\\n  z-index: 2;\\r\\n}\\r\\n\\r\\n.sidenav-container {\\r\\n  -webkit-box-flex: 1;\\r\\n      -ms-flex: 1;\\r\\n          flex: 1;\\r\\n}\\r\\n\\r\\n.mobile-sidenav-container {\\r\\n  -webkit-box-flex: 1;\\r\\n      -ms-flex: 1 0 auto;\\r\\n          flex: 1 0 auto;\\r\\n}\\r\\n\\r\\n.sidenav {\\r\\n  margin-top: 56px;\\r\\n  min-width: 25vw;\\r\\n}\\r\\n\\r\\n.mobile-sidenav {\\r\\n  width: 80% !important;\\r\\n  margin-top: 48px;\\r\\n}\\r\\n\\r\\n.sidenav-content {\\r\\n  margin-top: 56px;\\r\\n  padding: 16px;\\r\\n}\\r\\n\\r\\n.language-label {\\r\\n  margin-right: 50px;\\r\\n}\\r\\n\\r\\n.language-selection {\\r\\n  width: 100px;\\r\\n}\\r\\n\\r\\n.lang-bottom-pos {\\r\\n  position: absolute;\\r\\n  bottom: 60px;\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.theme-bottom-pos {\\r\\n  position: absolute;\\r\\n  bottom: 12px;\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.active-link {\\r\\n  color: rgba(200, 50, 50, 0.9);\\r\\n}\\r\\n\\r\\n.viewer-wrapper {\\r\\n  /* overflow-x: overlay; */\\r\\n  position: relative;\\r\\n  width: 360px;\\r\\n  left: calc(50% - 180px);\\r\\n}\\r\\n\\r\\n.rightnav-slider-container {\\r\\n  height: 310px;\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.margin-bottom {\\r\\n  margin-bottom: 16px;\\r\\n}\\r\\n\\r\\n.heat-slider {\\r\\n  height: 200px;\\r\\n  width: 56px;\\r\\n  padding: 0 !important;\\r\\n}\\r\\n\\r\\n.fan-toggle {\\r\\n  margin-left: 100px;\\r\\n}\\r\\n\\r\\n.thin-line-sep {\\r\\n  margin: 3px 0;\\r\\n}\\r\\n\\r\\n.temperature-card {\\r\\n  padding: 1px;\\r\\n  margin: 10px;\\r\\n}\\r\\n\\r\\n.hardware-item {\\r\\n  margin-bottom: 5px;\\r\\n}\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/site.component.css\n// module id = ./src/app/site/site.component.css\n// module chunks = main","module.exports = \"<div class=\\\"main-container\\\">\\r\\n  <mat-toolbar color=\\\"primary\\\" class=\\\"main-toolbar\\\">\\r\\n    <button mat-icon-button (click)=\\\"toggle(true)\\\">\\r\\n      <mat-icon>settings</mat-icon>\\r\\n    </button>\\r\\n    <h1 style=\\\"margin: auto;\\\">\\r\\n      <ptrl [text]=\\\"title\\\"></ptrl>\\r\\n    </h1>\\r\\n    <button mat-icon-button (click)=\\\"toggle(false)\\\">\\r\\n      <mat-icon>menu</mat-icon>\\r\\n    </button>\\r\\n  </mat-toolbar>\\r\\n  <mat-sidenav-container class=\\\"sidenav-container\\\" [class.mobile-sidenav-container]=\\\"ws.isMobile\\\">\\r\\n    <!-- Left Nav -->\\r\\n    <mat-sidenav class=\\\"sidenav\\\" #leftnav [mode]=\\\"ws.isMobile ? 'over' : 'side'\\\" [fixedInViewport]=\\\"ws.isMobile\\\"\\r\\n      [class.mobile-sidenav]=\\\"ws.isMobile\\\">\\r\\n      <mat-nav-list>\\r\\n        <a mat-list-item *ngFor=\\\"let lni of leftNavItems\\\" (click)=\\\"changeLink(lni.route)\\\" [routerLink]=\\\"lni.route\\\"\\r\\n          [class.active-item]=\\\"selectedLink === lni.route\\\">\\r\\n          <mat-icon class=\\\"icon-margin\\\">{{lni.icon}}</mat-icon>\\r\\n          <ptrl [text]=\\\"lni.label\\\"></ptrl>\\r\\n        </a>\\r\\n        <mat-list-item class=\\\"lang-bottom-pos\\\" (click)=\\\"openSelectLang()\\\">\\r\\n          <mat-icon class=\\\"icon-margin\\\">language</mat-icon>\\r\\n          <mat-label class=\\\"language-label\\\">\\r\\n            <ptrl [text]=\\\"'Language'\\\"></ptrl>\\r\\n          </mat-label>\\r\\n          <mat-select #sellang [(value)]=\\\"selectedLanguage\\\" (change)=\\\"changeLanguage()\\\" class=\\\"language-selection\\\">\\r\\n            <mat-option *ngFor=\\\"let lang of trS.languages\\\" [value]=\\\"lang\\\">\\r\\n              {{lang}}\\r\\n            </mat-option>\\r\\n          </mat-select>\\r\\n        </mat-list-item>\\r\\n        <mat-list-item class=\\\"theme-bottom-pos\\\">\\r\\n          <mat-icon class=\\\"icon-margin\\\">format_color_fill</mat-icon>\\r\\n          <ptrl [text]=\\\"'Theme'\\\"></ptrl>\\r\\n        </mat-list-item>\\r\\n      </mat-nav-list>\\r\\n    </mat-sidenav>\\r\\n\\r\\n    <!-- Right Nav -->\\r\\n    <mat-sidenav class=\\\"sidenav\\\" #rightnav [mode]=\\\"ws.isMobile ? 'over' : 'side'\\\" [fixedInViewport]=\\\"ws.isMobile\\\"\\r\\n      [class.mobile-sidenav]=\\\"ws.isMobile\\\" position=\\\"end\\\">\\r\\n      <mat-nav-list>\\r\\n        <h4 class=\\\"title\\\">\\r\\n          <ptrl [text]=\\\"'Status'\\\"></ptrl>\\r\\n        </h4>\\r\\n        <mat-card class=\\\"temperature-card mat-elevation-z6\\\">\\r\\n          <mat-card-title class=\\\"card-name-header\\\">\\r\\n            <h5 class=\\\"title\\\">\\r\\n              <ptrl [text]=\\\"'Hardware Info'\\\"></ptrl>\\r\\n            </h5>\\r\\n          </mat-card-title>\\r\\n          <mat-card-content>\\r\\n            <div fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center baseline\\\">\\r\\n              <div fxFlex=\\\"50%\\\" fxLayout=\\\"column\\\" fxLayoutAlign=\\\"center center\\\" class=\\\"margin-bottom\\\">\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  <ptrl [text]=\\\"'RAM Usage'\\\"></ptrl>\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  <ptrl [text]=\\\"'CPU Usage'\\\"></ptrl>\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  <ptrl [text]=\\\"'CPU Temp'\\\"></ptrl>\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  <ptrl [text]=\\\"'GPU Temp'\\\"></ptrl>\\r\\n                </div>\\r\\n                <!-- <div class=\\\"hardware-item\\\">\\r\\n                  <ptrl [text]=\\\"'Extended Board'\\\"></ptrl>\\r\\n                </div> -->\\r\\n              </div>\\r\\n              <div fxFlex=\\\"30%\\\" fxLayout=\\\"column\\\" fxLayoutAlign=\\\"center center\\\" class=\\\"margin-bottom\\\">\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  {{hardwareInfo['ram_usage']}}%\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  {{hardwareInfo['cpu_usage']}}%\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  {{hardwareInfo['cpu_temp']}}°\\r\\n                </div>\\r\\n                <div class=\\\"hardware-item\\\">\\r\\n                  {{hardwareInfo['gpu_temp']}}°\\r\\n                </div>\\r\\n                <!-- <div class=\\\"hardware-item\\\">\\r\\n                  <mat-icon *ngIf=\\\"extendedBoardConnection\\\">check</mat-icon>\\r\\n                  <mat-icon *ngIf=\\\"!extendedBoardConnection\\\">clear</mat-icon>\\r\\n                </div> -->\\r\\n              </div>\\r\\n            </div>\\r\\n\\r\\n          </mat-card-content>\\r\\n        </mat-card>\\r\\n        <mat-card class=\\\"temperature-card mat-elevation-z6\\\">\\r\\n          <mat-card-title class=\\\"card-name-header\\\">\\r\\n            <h5 class=\\\"title\\\">\\r\\n              <ptrl [text]=\\\"'Temperature'\\\"></ptrl>\\r\\n            </h5>\\r\\n          </mat-card-title>\\r\\n          <mat-card-content>\\r\\n            <div fxLayout=\\\"column\\\" fxLayoutAlign=\\\"start start\\\">\\r\\n              <div fxFlex=\\\"50\\\" fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center start\\\" style=\\\"width: 100%;\\\">\\r\\n                <div [fxFlex]=\\\" temps['ext2'] ? 50 : 100\\\">\\r\\n                  <div class=\\\"centerize\\\">\\r\\n                    <ptrl [text]=\\\"'Extruder'\\\"></ptrl>\\r\\n                  </div>\\r\\n                  <div class=\\\"title bigger-text\\\">\\r\\n                    {{(temps['ext']['cur'] || 0) + '° | ' + (temps['ext']['goal'] || 0) + '°'}}\\r\\n                  </div>\\r\\n                </div>\\r\\n                <div fxFlex=\\\"50\\\" *ngIf=\\\"temps['ext2']\\\">\\r\\n                  <div class=\\\"centerize\\\">\\r\\n                    <ptrl [text]=\\\"'Extruder'\\\"></ptrl>&nbsp;2\\r\\n                  </div>\\r\\n                  <div class=\\\"title bigger-text\\\">\\r\\n                    {{(temps['ext2']['cur'] || 0) + '° | ' + (temps['ext2']['goal'] || 0) + '°'}}\\r\\n                  </div>\\r\\n                </div>\\r\\n              </div>\\r\\n              <div fxFlex=\\\"50\\\" style=\\\"width: 100%;\\\">\\r\\n                <div class=\\\"centerize\\\">\\r\\n                  <ptrl [text]=\\\"'Bed'\\\"></ptrl>\\r\\n                </div>\\r\\n                <div class=\\\"title bigger-text\\\">\\r\\n                  {{(temps['bed']['cur'] || 0) + '° | ' + (temps['bed']['goal'] || 0) + '°'}}\\r\\n                </div>\\r\\n              </div>\\r\\n            </div>\\r\\n          </mat-card-content>\\r\\n        </mat-card>\\r\\n\\r\\n        <mat-divider class=\\\"thin-line-sep\\\"></mat-divider>\\r\\n\\r\\n        <!-- SHOULD THINK ABOUT HOME AND MOVE VIEW! -->\\r\\n        <mat-list-item class=\\\"fan-list-item\\\" *ngIf=\\\"shouldMoveItemExist\\\" (click)=\\\"openMove()\\\">\\r\\n          <ptrl [text]=\\\"'Home/Move'\\\"></ptrl>\\r\\n        </mat-list-item>\\r\\n\\r\\n        <mat-divider class=\\\"thin-line-sep\\\" *ngIf=\\\"shouldMoveItemExist\\\"></mat-divider>\\r\\n\\r\\n        <mat-list-item class=\\\"fan-list-item\\\" *ngIf=\\\"shouldMoveItemExist\\\" (click)=\\\"releaseMotors()\\\">\\r\\n          <ptrl [text]=\\\"'Release Motors'\\\"></ptrl>\\r\\n        </mat-list-item>\\r\\n\\r\\n        <mat-divider class=\\\"thin-line-sep\\\" *ngIf=\\\"shouldMoveItemExist\\\"></mat-divider>\\r\\n\\r\\n        <h4 class=\\\"title\\\">\\r\\n          <ptrl [text]=\\\"'Heat'\\\"></ptrl>\\r\\n        </h4>\\r\\n        <div class=\\\"rightnav-slider-container\\\" fxLayout=\\\"row\\\" fxLayoutAlign=\\\"center center\\\">\\r\\n          <div fxFlex=\\\"35%\\\" fxLayout=\\\"column\\\">\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <ptrl [text]=\\\"'Bed'\\\"></ptrl>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"60%\\\" class=\\\"margin-bottom\\\">\\r\\n              <mat-slider [color]=\\\"heatTemps.bed.color\\\" (input)=\\\"sliderDrag($event.value, 'bed')\\\" class=\\\"heat-slider\\\"\\r\\n                [max]=\\\"120\\\" [min]=\\\"0\\\" [step]=\\\"10\\\" [thumbLabel]=\\\"true\\\" [tickInterval]=\\\"2\\\"\\r\\n                [(ngModel)]=\\\"heatTemps.bed.value\\\" [vertical]=\\\"true\\\">\\r\\n              </mat-slider>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <button mat-raised-button color=\\\"accent\\\" (click)=\\\"submitHeat('bed')\\\"\\r\\n                [disabled]=\\\"temps['bed']['goal'] === heatTemps.bed.value\\\">\\r\\n                <ptrl [text]=\\\"'Confirm'\\\"></ptrl>\\r\\n              </button>\\r\\n            </div>\\r\\n          </div>\\r\\n          <div fxFlex=\\\"35%\\\" fxLayout=\\\"column\\\">\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <ptrl [text]=\\\"'Extruder'\\\"></ptrl>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"60%\\\" class=\\\"margin-bottom\\\">\\r\\n              <mat-slider [color]=\\\"heatTemps.ext.color\\\" (input)=\\\"sliderDrag($event.value, 'ext')\\\" class=\\\"heat-slider\\\"\\r\\n                [max]=\\\"350\\\" [min]=\\\"0\\\" [step]=\\\"10\\\" [thumbLabel]=\\\"true\\\" [tickInterval]=\\\"5\\\"\\r\\n                [(ngModel)]=\\\"heatTemps.ext.value\\\" [vertical]=\\\"true\\\">\\r\\n              </mat-slider>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <button mat-raised-button color=\\\"accent\\\" (click)=\\\"submitHeat('ext')\\\"\\r\\n                [disabled]=\\\"temps['ext']['goal'] === heatTemps.ext.value\\\">\\r\\n                <ptrl [text]=\\\"'Confirm'\\\"></ptrl>\\r\\n              </button>\\r\\n            </div>\\r\\n          </div>\\r\\n          <div fxFlex=\\\"35%\\\" fxLayout=\\\"column\\\" *ngIf=\\\"temps['ext2']\\\">\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <ptrl [text]=\\\"'Extruder 2'\\\"></ptrl>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"60%\\\" class=\\\"margin-bottom\\\">\\r\\n              <mat-slider [color]=\\\"heatTemps.ext2.color\\\" (input)=\\\"sliderDrag($event.value, 'ext2')\\\" class=\\\"heat-slider\\\"\\r\\n                [max]=\\\"350\\\" [min]=\\\"0\\\" [step]=\\\"10\\\" [thumbLabel]=\\\"true\\\" [tickInterval]=\\\"5\\\"\\r\\n                [(ngModel)]=\\\"heatTemps.ext2.value\\\" [vertical]=\\\"true\\\">\\r\\n              </mat-slider>\\r\\n            </div>\\r\\n            <div fxFlex=\\\"20%\\\" class=\\\"margin-bottom\\\">\\r\\n              <button mat-raised-button color=\\\"accent\\\" (click)=\\\"submitHeat('ext2')\\\"\\r\\n                [disabled]=\\\"temps['ext2']['goal'] === heatTemps.ext2.value\\\">\\r\\n                <ptrl [text]=\\\"'Confirm'\\\"></ptrl>\\r\\n              </button>\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n\\r\\n        <mat-divider class=\\\"thin-line-sep\\\"></mat-divider>\\r\\n\\r\\n        <mat-list-item (click)=\\\"changeFanStatus(!fanStatus)\\\" dir=\\\"rtl\\\" class=\\\"fan-list-item\\\">\\r\\n          <mat-slide-toggle color=\\\"primary\\\" [checked]=\\\"fanStatus\\\" class=\\\"fan-toggle\\\">\\r\\n          </mat-slide-toggle>\\r\\n          <ptrl [text]=\\\"'Fan Status'\\\"></ptrl>\\r\\n        </mat-list-item>\\r\\n\\r\\n        <mat-divider class=\\\"thin-line-sep\\\"></mat-divider>\\r\\n\\r\\n      </mat-nav-list>\\r\\n    </mat-sidenav>\\r\\n    <mat-sidenav-content class=\\\"sidenav-content\\\" id=\\\"matcontent\\\">\\r\\n      <router-outlet (activate)=\\\"pageChanged($event)\\\"></router-outlet>\\r\\n\\r\\n      <!-- Gcode 3D Viewer -->\\r\\n      <div [class.hide-area]=\\\"!gcodeViewingLink\\\" class=\\\"viewer-wrapper\\\" #gcode3dviewer>\\r\\n        <h4 class=\\\"title scroll-to\\\">\\r\\n          <ptrl [text]=\\\"'View 3D'\\\"></ptrl>\\r\\n        </h4>\\r\\n        <app-gcode-viewer [model]=\\\"gcodeViewingLink\\\" [percent]=\\\"gcodeIndex || 100\\\"></app-gcode-viewer>\\r\\n      </div>\\r\\n      <br><br><br><br><br><br>\\r\\n\\r\\n    </mat-sidenav-content>\\r\\n  </mat-sidenav-container>\\r\\n</div>\\r\\n<block-ui>\\r\\n  PLEASE BE PATIENT\\r\\n</block-ui>\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/site.component.html\n// module id = ./src/app/site/site.component.html\n// module chunks = main","import {Component, OnInit, HostListener, ViewChild, ElementRef} from '@angular/core';\r\nimport {WindowService} from '../shared/services/window.service';\r\nimport {HttpService} from '../shared/services/http.service';\r\nimport {TranslatorService} from 'app/shared/services/translator.service';\r\nimport {MatSidenav, MatSelect, MatDialog} from '@angular/material';\r\nimport {leftNavNormalItems, leftNavOnPrintItems} from 'app/shared/consts/leftnav.const';\r\nimport {Router, NavigationEnd} from '@angular/router';\r\nimport {BlockUI, NgBlockUI} from 'ng-block-ui';\r\nimport {SpinnerService} from 'app/shared/services/spinner.service';\r\nimport {DataService} from 'app/shared/services/data.service';\r\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\r\nimport {DialogType} from 'app/shared/enum/dialog.enum';\r\nimport {ViewerService} from 'app/shared/services/viewer.service';\r\nimport {PrintService} from 'app/shared/services/print.service';\r\nimport {PageBase} from 'app/shared/classes/page-base.class';\r\nimport {NavLink} from 'app/shared/classes/navlink.interface';\r\nimport {PrinterTemperatures} from 'app/shared/classes/temperatures.interface';\r\nimport {MessageService} from 'app/shared/services/message.service';\r\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\r\nimport {MoveComponent} from 'app/shared/components/move/move.component';\r\n\r\n@Component({\r\n  selector: 'app-site',\r\n  templateUrl: './site.component.html',\r\n  styleUrls: ['./site.component.css']\r\n})\r\nexport class SiteComponent extends PageBase implements OnInit {\r\n  @ViewChild('leftnav') leftNav: MatSidenav;\r\n  @ViewChild('rightnav') rightNav: MatSidenav;\r\n  @ViewChild('sellang') selLang: MatSelect;\r\n  @ViewChild('gcode3dviewer') gcode3DViewer: ElementRef;\r\n  @BlockUI() bu: NgBlockUI;\r\n\r\n  // left nav vars\r\n  leftNavItems = leftNavNormalItems;\r\n  selectedLanguage;\r\n  selectedLink = '';\r\n\r\n  // these are for gcode viewer\r\n  gcodeViewingLink = null;\r\n  gcodeIndex = 100;\r\n\r\n  // right nav vars\r\n  fanStatus = false;\r\n  hardwareInfo = {};\r\n  temps: PrinterTemperatures = {\r\n    bed: {cur: 0, goal: 0},\r\n    ext: {cur: 0, goal: 0},\r\n    ext2: {cur: 0, goal: 0},\r\n  };\r\n  heatTemps = {\r\n    bed: {\r\n      color: 'primary',\r\n      value: 0,\r\n    },\r\n    ext: {\r\n      color: 'primary',\r\n      value: 0,\r\n    },\r\n    ext2: {\r\n      color: 'primary',\r\n      value: 0,\r\n    }\r\n  };\r\n  colorThreshold = {bed: 50, ext: 180, ext2: 180};\r\n  shouldMoveItemExist = true;\r\n\r\n  constructor(public ws: WindowService, private hs: HttpService,\r\n    private ds: DataService, public trS: TranslatorService,\r\n    private vs: ViewerService, private ps: PrintService,\r\n    private router: Router, private er: ElementRef,\r\n    private spinnerService: SpinnerService, private ms: MessageService,\r\n    private dialog: MatDialog) {\r\n    super('Main Page');\r\n    this.selectedLink = this.router.url;\r\n    this.routeChecking();\r\n  }\r\n\r\n  ngOnInit() {\r\n    // NOTE: Uncomment this code to disable scrollbar in the center part\r\n    // but smooth scrolling when selecting entry, file to view 3d, etc.,\r\n    // will become inactive (only in standalone) as the consequences! :|\r\n    // If found a way to deal with this problem, this code will be used!\r\n    // setTimeout(() => this.hideScrollbar(), 0);\r\n\r\n\r\n    setTimeout(() => this.initializeAll());\r\n  }\r\n\r\n  initializeAll() {\r\n    this.initializeSpinner();\r\n    this.initializeLanguage();\r\n    this.initializeOnPrintPage();\r\n    this.initializeGcodeLink();\r\n    this.initializeRightNavVars();\r\n    this.initializeHardwareInfo();\r\n\r\n    this.checkSideNavStatus();\r\n    this.checkPrinterSettings();\r\n  }\r\n\r\n  routeChecking() {\r\n    this.router.events.subscribe(route => {\r\n      if (route instanceof NavigationEnd)\r\n        return;\r\n\r\n      this.changeLink(route['url']);\r\n      const canHaveGcodeViewer = ['/home', '/print-page'];\r\n      if (canHaveGcodeViewer.some(el => el === route['url'])) {\r\n      } else {\r\n        this.vs.updateGcodeLink(null);\r\n        this.vs.setGcodeIndex(100);\r\n      }\r\n    });\r\n  }\r\n\r\n  initializeSpinner() {\r\n    this.spinnerService.spin$.subscribe(spin => {\r\n      if (spin)\r\n        setTimeout(() => this.bu.start());\r\n      else\r\n        setTimeout(() => this.bu.stop());\r\n    });\r\n  }\r\n\r\n  initializeLanguage() {\r\n    this.trS.lang$.subscribe(lng => {\r\n      this.selectedLanguage = lng;\r\n    });\r\n  }\r\n\r\n  initializeOnPrintPage() {\r\n    this.ps.onPrintPage$.subscribe(isOnPrintPage => {\r\n      if (isOnPrintPage === null)\r\n        return;\r\n\r\n      this.shouldMoveItemExist = !isOnPrintPage;\r\n\r\n      let dialog: DialogType;\r\n      if (isOnPrintPage) {\r\n        this.leftNavItems = leftNavOnPrintItems;\r\n        dialog = DialogType.shouldGoToPrintPage;\r\n        this.ps.isActivePrint = true;\r\n      } else {\r\n        this.leftNavItems = leftNavNormalItems;\r\n        dialog = DialogType.pageNotAllowed;\r\n      }\r\n\r\n      if (!this.leftNavItems.map(el => el['route']).includes(this.router.url)) {\r\n        this.clearSelectedLink();\r\n        if (this.dialog.openDialogs.length)\r\n          return;\r\n\r\n        if (this.router.url === '/print-page' && this.ps.isActivePrint)\r\n          return;\r\n\r\n        // TODO: don't show inaccessible page as it's so buggish!\r\n        if (dialog === DialogType.pageNotAllowed)\r\n          return;\r\n\r\n        this.dialog.open(GenericDialogComponent, {\r\n          data: {\r\n            usage: dialog\r\n          }\r\n        }).afterClosed().subscribe(res => {\r\n          this.router.navigate([this.leftNavItems[0].route]);\r\n          this.changeLink(this.leftNavItems[0].route);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  initializeHardwareInfo() {\r\n    this.ds.hardwareInfo$.subscribe(data => {\r\n      this.hardwareInfo = data;\r\n    });\r\n  }\r\n\r\n  initializeGcodeLink() {\r\n    this.vs.fileGcodeLink$.subscribe(link => {\r\n      this.gcodeViewingLink = link;\r\n    });\r\n    this.vs.gcodeIndex$.subscribe(idx => {\r\n      this.gcodeIndex = idx;\r\n    });\r\n  }\r\n\r\n  hideScrollbar() {\r\n    const el = this.er.nativeElement.querySelector('#matcontent');\r\n    el.addEventListener('wheel', e => {\r\n      el.scrollTop += e.deltaY;\r\n    });\r\n    el.setAttribute('style', \"overflow: hidden;\");\r\n  }\r\n\r\n  changeLanguage() {\r\n    this.trS.changeLanguageTo(this.selectedLanguage);\r\n  }\r\n\r\n  openSelectLang() {\r\n    this.selLang.open();\r\n  }\r\n\r\n  clearSelectedLink() {\r\n    this.selectedLink = '';\r\n  }\r\n\r\n  toggle(isLeft) {\r\n    if (isLeft) this.leftNav.toggle();\r\n    else this.rightNav.toggle();\r\n\r\n    // close least recent sidenav if both are open in mobile view\r\n    if (this.ws.isMobile && this.leftNav.opened && this.rightNav.opened) {\r\n      if (isLeft) this.rightNav.close();\r\n      else this.leftNav.close();\r\n    }\r\n\r\n    // if opened right nav, get initial statuses\r\n    if (!isLeft && this.rightNav.opened)\r\n      this.onOpenedRightNav();\r\n  }\r\n\r\n  changeLink(link, isLeft = true) {\r\n    if (!link) return;\r\n    this.selectedLink = link;\r\n    if (this.ws.isMobile) {\r\n      if (isLeft) {\r\n        this.leftNav.close();\r\n      }\r\n    }\r\n  }\r\n\r\n  onOpenedRightNav() {\r\n    this.ds.getFanStatus();\r\n\r\n    this.heatTemps.bed.value = this.temps.bed['goal'];\r\n    this.heatTemps.ext.value = this.temps.ext['goal'];\r\n    if (this.temps.ext2)\r\n      this.heatTemps.ext2.value = this.temps.ext2['goal'];\r\n    this.checkSliderColors();\r\n  }\r\n\r\n  // right nav related methods\r\n  initializeRightNavVars() {\r\n    this.ds.temps$.subscribe(res => {\r\n      this.temps = res;\r\n    });\r\n\r\n    this.ds.isFanOn$.subscribe(res => {\r\n      if (res === null) return;\r\n      this.fanStatus = res;\r\n    });\r\n  }\r\n\r\n  changeFanStatus(status: boolean) {\r\n    this.ds.setFanStatus(status).then(() => this.fanStatus = status);\r\n  }\r\n\r\n  sliderDrag(value, type) {\r\n    this.sliderSingleColorChange(value, type);\r\n  }\r\n\r\n  checkSliderColors() {\r\n    ['bed', 'ext'].forEach(el => {\r\n      this.sliderSingleColorChange(this.heatTemps[el].value, el);\r\n    });\r\n  }\r\n\r\n  sliderSingleColorChange(value, type) {\r\n    if (value >= this.colorThreshold[type])\r\n      this.heatTemps[type].color = 'warn';\r\n    else\r\n      this.heatTemps[type].color = 'primary';\r\n  }\r\n\r\n  submitHeat(type) {\r\n    let resultObj;\r\n    if (type === 'bed') {\r\n      resultObj = {\r\n        field: 'bed',\r\n        action: this.heatTemps.bed.value === 0 ? 'cooldown' : 'heat',\r\n        value: this.heatTemps.bed.value\r\n      };\r\n    } else if (type === 'ext') {\r\n      resultObj = {\r\n        field: 'hotend',\r\n        action: this.heatTemps.ext.value === 0 ? 'cooldown' : 'heat',\r\n        value: this.heatTemps.ext.value,\r\n        ext_num: 0,\r\n      };\r\n    } else if (type === 'ext2') {\r\n      resultObj = {\r\n        field: 'hotend',\r\n        action: this.heatTemps.ext2.value === 0 ? 'cooldown' : 'heat',\r\n        value: this.heatTemps.ext2.value,\r\n        ext_num: 1,\r\n      }\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    this.hs.post('heat', resultObj).subscribe(res => {\r\n    });\r\n  }\r\n\r\n  openMove() {\r\n    this.dialog.open(MoveComponent, {\r\n      width: '320px',\r\n    });\r\n  }\r\n\r\n  releaseMotors() {\r\n    this.hs.post('release_motor', {}).subscribe(res => {\r\n      this.ms.open(MsgType.info);\r\n    });\r\n  }\r\n\r\n  pageChanged(page: PageBase) {\r\n    this.title = page.title || \"Page\";\r\n    try {\r\n      this.changeLink(this.leftNavItems.find(el => el.route === this.router.url).route);\r\n    } catch (e) {\r\n      console.error(\"current route doesn't exist on leftnavitems!\");\r\n      this.changeLink(this.router.url);\r\n    }\r\n  }\r\n\r\n  @HostListener('window:resize', ['$event'])\r\n  onResize(event, width?, height?) {\r\n    const [w, h] = [event ? event.target.innerWidth : width, event ? event.target.innerHeight : height];\r\n    if (this.ws.curWidth$.getValue() !== w)\r\n      this.ws.curWidth$.next(w);\r\n    if (this.ws.curHeight$.getValue() !== h)\r\n      this.ws.curHeight$.next(h);\r\n\r\n    // if (this.ws.checkIsMobile() && this.leftNav.opened && this.rightNav.opened)\r\n\r\n    // close on resize to avoid view malfunctioning\r\n    if (this.ws.checkIsMobile())\r\n      return;\r\n\r\n    this.checkSideNavStatus();\r\n  }\r\n\r\n  checkSideNavStatus() {\r\n    if (this.ws.checkIsMobile())\r\n      return;\r\n\r\n    this.leftNav.close();\r\n    this.rightNav.close();\r\n    // setTimeout(() => {\r\n    //   this.leftNav.open();\r\n    //   this.rightNav.open();\r\n    // }, 500);\r\n  }\r\n\r\n  checkPrinterSettings() {\r\n    this.ds.printerSettings$.subscribe(res => {\r\n      if (!res) return;\r\n\r\n      if (!res.view3d)\r\n        this.gcode3DViewer.nativeElement.remove();\r\n    });\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/site.component.ts","import {NgModule} from '@angular/core';\r\nimport {SiteRouting} from './site.routing';\r\nimport {CommonModule} from '@angular/common';\r\nimport {SiteComponent} from './site.component';\r\nimport {\r\n  MatButtonModule,\r\n  MatIconModule,\r\n  MatProgressBarModule,\r\n  MatSidenavModule,\r\n  MatFormFieldModule,\r\n  MatInputModule,\r\n  MatToolbarModule,\r\n  MatCardModule,\r\n  MatMenuModule,\r\n  MatRippleModule,\r\n  MatListModule,\r\n  MatSelectModule,\r\n  MatTableModule,\r\n  MatPaginatorModule,\r\n  MatTooltipModule,\r\n  MatDialogModule,\r\n  MatSnackBarModule,\r\n  MatSliderModule,\r\n  MatSlideToggleModule,\r\n  MatExpansionModule\r\n} from '@angular/material';\r\nimport {ProgressComponent} from '../shared/components/progress/progress.component';\r\nimport {BrowserModule} from '@angular/platform-browser';\r\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\r\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\r\nimport {FlexLayoutModule} from '@angular/flex-layout';\r\nimport {GcodeViewerComponent} from '../shared/components/gcode-viewer/gcode-viewer.component';\r\nimport {UploadFileComponent} from 'app/shared/components/upload-file/upload-file.component';\r\nimport {CovalentFileModule} from '@covalent/core/file';\r\nimport {CameraViewerComponent} from 'app/shared/components/camera-viewer/camera-viewer.component';\r\nimport {HomeComponent} from './home/home.component';\r\nimport {TrlComponent} from 'app/shared/components/trl/trl.component';\r\nimport {SettingsComponent} from './settings/settings.component';\r\nimport {ScrollToModule} from '@nicky-lenaers/ngx-scroll-to';\r\nimport {BlockUIModule} from 'ng-block-ui';\r\nimport {PrintPageComponent} from './print-page/print-page.component';\r\nimport {NgbProgressbarModule, NgbModule} from '@ng-bootstrap/ng-bootstrap';\r\nimport {GenericDialogComponent} from 'app/shared/components/generic-dialog/generic-dialog.component';\r\nimport {RouteReuseStrategy} from '@angular/router';\r\nimport {CustomReuseStrategy} from 'app/shared/lib/custom-route-strategy';\r\nimport {LastPrintsComponent} from './last-prints/last-prints.component';\r\nimport {ExtruderComponent} from './extruder/extruder.component';\r\nimport {BedlevelComponent} from './bedlevel/bedlevel.component';\r\nimport {TimelapseComponent} from './timelapse/timelapse.component';\r\nimport {FormItemComponent} from 'app/shared/components/form-item/form-item.component';\r\nimport {MoveComponent} from 'app/shared/components/move/move.component';\r\n\r\n@NgModule({\r\n  imports: [\r\n    BrowserAnimationsModule,\r\n    BrowserModule,\r\n    FormsModule,\r\n    ReactiveFormsModule,\r\n    SiteRouting,\r\n    CommonModule,\r\n    FlexLayoutModule,\r\n    MatSidenavModule,\r\n    MatIconModule,\r\n    MatButtonModule,\r\n    MatInputModule,\r\n    MatToolbarModule,\r\n    MatCardModule,\r\n    MatMenuModule,\r\n    MatRippleModule,\r\n    MatProgressBarModule,\r\n    MatFormFieldModule,\r\n    CovalentFileModule,\r\n    MatExpansionModule,\r\n    MatListModule,\r\n    MatSelectModule,\r\n    ScrollToModule.forRoot(),\r\n    MatTableModule,\r\n    MatPaginatorModule,\r\n    MatTooltipModule,\r\n    BlockUIModule.forRoot(),\r\n    NgbProgressbarModule.forRoot(),\r\n    // NgbModule.forRoot(),\r\n    MatDialogModule,\r\n    MatSnackBarModule,\r\n    MatSliderModule,\r\n    MatSlideToggleModule,\r\n  ],\r\n  declarations: [\r\n    SiteComponent,\r\n    ProgressComponent,\r\n    GcodeViewerComponent,\r\n    UploadFileComponent,\r\n    CameraViewerComponent,\r\n    TrlComponent,\r\n    HomeComponent,\r\n    SettingsComponent,\r\n    PrintPageComponent,\r\n    GenericDialogComponent,\r\n    LastPrintsComponent,\r\n    ExtruderComponent,\r\n    BedlevelComponent,\r\n    TimelapseComponent,\r\n    FormItemComponent,\r\n    MoveComponent,\r\n  ],\r\n  entryComponents: [\r\n    GenericDialogComponent,\r\n    MoveComponent,\r\n  ],\r\n  providers: [\r\n    // {provide: RouteReuseStrategy, useClass: CustomReuseStrategy},\r\n  ]\r\n})\r\nexport class SiteModule {\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/site.module.ts","import {RouterModule, Routes} from '@angular/router';\r\nimport {RouterTestingModule} from '@angular/router/testing';\r\nimport {SiteComponent} from './site.component';\r\nimport {HomeComponent} from './home/home.component';\r\nimport {CameraViewerComponent} from 'app/shared/components/camera-viewer/camera-viewer.component';\r\nimport {SettingsComponent} from './settings/settings.component';\r\nimport {PrintPageComponent} from './print-page/print-page.component';\r\nimport {LastPrintsComponent} from './last-prints/last-prints.component';\r\nimport {ExtruderComponent} from './extruder/extruder.component';\r\nimport {BedlevelComponent} from './bedlevel/bedlevel.component';\r\nimport {TimelapseComponent} from './timelapse/timelapse.component';\r\n\r\nconst Site_ROUTES: Routes = [\r\n  {\r\n    path: '', component: SiteComponent, children: [\r\n      {path: '', redirectTo: 'home', pathMatch: 'full'},\r\n\r\n      // these two paths' components' states are saved via customReuseStrategy!\r\n      // so changing the path of these two should affect the routes there too!\r\n      // NOTE: customReuseStrategy is not used at the moment, So IGNORE this!\r\n      {path: 'home', component: HomeComponent},\r\n      {path: 'print-page', component: PrintPageComponent},\r\n\r\n      {path: 'camera', component: CameraViewerComponent},\r\n      {path: 'extrude', component: ExtruderComponent},\r\n      {path: 'bedleveling', component: BedlevelComponent},\r\n      {path: 'last-prints', component: LastPrintsComponent},\r\n      {path: 'timelapse', component: TimelapseComponent},\r\n      {path: 'settings', component: SettingsComponent},\r\n      // {path: 'home', loadChildren: 'app/site/home/home.module#HomeModule'},\r\n    ]\r\n  }\r\n];\r\n\r\nexport const SiteRouting = RouterModule.forChild(Site_ROUTES);\r\nexport const SiteTestRouting = RouterTestingModule.withRoutes(Site_ROUTES);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/site.routing.ts","module.exports = \"<!-- Choose Departure -->\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center center\\\">\\n  <div fxFlex=\\\"40px\\\">\\n    <button mat-icon-button (click)=\\\"getDepartures()\\\">\\n      <mat-icon>refresh</mat-icon>\\n    </button>\\n  </div>\\n  <div fxFlex=\\\"200px\\\">\\n    <h4 class=\\\"title\\\">\\n      <ptrl [text]=\\\"'Choose Departure'\\\"></ptrl>\\n    </h4>\\n  </div>\\n</div>\\n<div fxLayout=\\\"row wrap\\\" fxLayoutAlign=\\\"center start\\\">\\n  <div fxFlex=\\\"150px\\\" *ngFor=\\\"let usb of departures; let l = last;\\\" class=\\\"card-wrapper-item\\\">\\n    <mat-card matRipple (click)=\\\"changeDeparture(usb)\\\" class=\\\"card-base\\\" [class.active-item]=\\\"selectedDeparture === usb\\\"\\n      style=\\\"height: 220px;\\\">\\n      <mat-card-header class=\\\"card-name-header\\\">\\n        <mat-card-title>\\n          <ptrl [text]=\\\"usb\\\"></ptrl>\\n        </mat-card-title>\\n      </mat-card-header>\\n      <img mat-card-image [src]=\\\"usbImage\\\" alt=\\\"usb\\\">\\n    </mat-card>\\n  </div>\\n</div>\\n\\n<mat-divider class=\\\"line-separator\\\"></mat-divider>\\n\\n<!-- Choose Timelapse -->\\n<h4 class=\\\"title\\\">\\n  <ptrl [text]=\\\"'Choose Timelapse'\\\"></ptrl>\\n</h4>\\n<mat-table #table [dataSource]=\\\"dataSource\\\">\\n  <ng-container matColumnDef=\\\"name\\\" matRipple>\\n    <mat-header-cell *matHeaderCellDef>Name</mat-header-cell>\\n    <mat-cell *matCellDef=\\\"let item\\\">{{item.name}}</mat-cell>\\n  </ng-container>\\n  <ng-container matColumnDef=\\\"delete\\\">\\n    <mat-header-cell *matHeaderCellDef class=\\\"table-column\\\">Delete</mat-header-cell>\\n    <mat-cell *matCellDef=\\\"let item\\\" class=\\\"table-column\\\">\\n      <button mat-icon-button color=\\\"warn\\\" (click)=\\\"deleteTimelapse($event, item)\\\">\\n        <mat-icon>delete</mat-icon>\\n      </button>\\n    </mat-cell>\\n  </ng-container>\\n  <mat-header-row *matHeaderRowDef=\\\"displayedColumns\\\"></mat-header-row>\\n  <mat-row *matRowDef=\\\"let row; columns: displayedColumns;\\\" (click)=\\\"selectTimelapse(row)\\\" class=\\\"table-row\\\"\\n    [class.active-item]=\\\"isSelected(row)\\\" [class.mat-elevation-z16]=\\\"isSelected(row)\\\"></mat-row>\\n</mat-table>\\n<mat-paginator #paginator [pageSize]=\\\"5\\\" [pageSizeOptions]=\\\"[3, 5, 10]\\\" [showFirstLastButtons]=\\\"false\\\"\\n  class=\\\"paginator-go-behind\\\">\\n</mat-paginator>\\n<div [class.export-button-wrapper]=\\\"ws.isMobile\\\" *ngIf=\\\"!ws.isMobile || (ws.isMobile && shouldPrintButtonBeActive())\\\">\\n  <button class=\\\"export-button\\\" mat-raised-button [disabled]=\\\"!shouldPrintButtonBeActive()\\\" color=\\\"primary\\\"\\n    (click)=\\\"exportTimelapse()\\\" [class.mat-elevation-z24]=\\\"shouldPrintButtonBeActive()\\\">\\n    <ptrl [text]=\\\"'Export'\\\"></ptrl>\\n  </button>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/timelapse/timelapse.component.html\n// module id = ./src/app/site/timelapse/timelapse.component.html\n// module chunks = main","module.exports = \".export-button-wrapper {\\n  position: fixed;\\n  bottom: 0;\\n  width: 100%;\\n  left: 0;\\n  z-index: 2; }\\n\\n.export-button {\\n  width: 100%;\\n  height: 60px;\\n  margin-top: 5px;\\n  font-size: 1.4em; }\\n\\n.table-column {\\n  max-width: 15%; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/site/timelapse/timelapse.component.scss\n// module id = ./src/app/site/timelapse/timelapse.component.scss\n// module chunks = main","import {Component, OnInit, ViewChild} from '@angular/core';\nimport {PageBase} from 'app/shared/classes/page-base.class';\nimport {HttpService} from 'app/shared/services/http.service';\nimport {ServerMatch} from 'app/shared/servermatch';\nimport {MatTableDataSource, MatPaginator} from '@angular/material';\nimport {MessageService} from 'app/shared/services/message.service';\nimport {MsgType} from 'app/shared/enum/msgtype.enum';\nimport {WindowService} from 'app/shared/services/window.service';\n\n@Component({\n  selector: 'app-timelapse',\n  templateUrl: './timelapse.component.html',\n  styleUrls: ['./timelapse.component.scss']\n})\nexport class TimelapseComponent extends PageBase implements OnInit {\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n\n  usbImage;\n  departures = [];\n  selectedDeparture = '';\n\n  displayedColumns = ['name', 'delete']; // maybe add 'size' and 'image_num' ?\n  dataSource = new MatTableDataSource();\n  selectedTimelapse = '';\n\n  constructor(private hs: HttpService, private ms: MessageService,\n    public ws: WindowService) {\n    super('Timelapse');\n    this.usbImage = ServerMatch.STATIC + 'assets/usb.png';\n  }\n\n  ngOnInit() {\n    this.initTable();\n    this.getDepartures();\n    this.getTimelapseList();\n  }\n\n  initTable() {\n    setTimeout(() => {\n      this.dataSource.data = [];\n      this.paginator._intl.itemsPerPageLabel = \"\";\n      this.dataSource.paginator = this.paginator;\n    });\n  }\n\n  getDepartures() {\n    this.hs.post('directory', {cd: ''}).subscribe(res => {\n      if (res.data.length === 0 || (res.data.length === 1 && res.data[0] === '')) {\n        this.departures = [];\n      } else {\n        this.departures = res.data;\n      }\n    });\n  }\n\n  changeDeparture(usb) {\n    this.selectedDeparture = usb;\n  }\n\n  getTimelapseList() {\n    this.hs.options('timelapse').subscribe(res => {\n      this.dataSource.data = this.makeDataTable(res.list);\n    });\n  }\n\n  exportTimelapse() {\n    this.hs.post('timelapse', {\n      dirname: this.selectedTimelapse,\n      usbname: this.selectedDeparture,\n    }, {\n        spin: true,\n        spinTimeout: 60,\n        throwError: true,\n      }).subscribe(res => {\n        this.ms.open(MsgType.info);\n        this.clearOut();\n      }, err => {\n        this.ms.open(MsgType.error);\n      });\n  }\n\n  deleteTimelapse($event, item) {\n    $event.stopPropagation();\n    this.hs.put('timelapse', {dirname: item.name}).subscribe(res => {\n      this.ms.open(MsgType.info);\n      this.getTimelapseList();\n    });\n  }\n\n  private makeDataTable(data) {\n    const res = []\n    data.forEach(el => {\n      res.push({\n        'name': el,\n      });\n    });\n\n    return res;\n  }\n\n  clearOut() {\n    this.selectedDeparture = '';\n    this.selectedTimelapse = '';\n  }\n\n  selectTimelapse(item) {\n    this.selectedTimelapse = item.name;\n  }\n\n  isSelected(row) {\n    return this.selectedTimelapse === row.name;\n  }\n\n  shouldPrintButtonBeActive() {\n    return (this.selectedDeparture) && (this.selectedTimelapse);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/site/timelapse/timelapse.component.ts","// The file contents for the current environment will overwrite these during build.\r\n// The build system defaults to the dev environment which uses `environment.ts`, but if you do\r\n// `ng build --env=prod` then `environment.prod.ts` will be used instead.\r\n// The list of which env maps to which file can be found in `.angular-cli.json`.\r\n\r\nexport const environment = {\r\n  production: false\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/environments/environment.ts","import {enableProdMode} from '@angular/core';\r\nimport {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\r\n\r\nimport {AppModule} from './app/app.module';\r\nimport {environment} from './environments/environment';\r\n\r\nimport 'hammerjs';\r\n\r\nif (environment.production) {\r\n  enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(AppModule);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts"],"sourceRoot":"webpack:///"}